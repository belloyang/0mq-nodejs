#ifndef MsgHarvestLog_h__
#define MsgHarvestLog_h__

#include "../IPDBMsgObject.h"

/// <summary>
/// MsgHarvestLog data type.\n
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.c8qb9xshg1d0
/// </summary>
class MsgHarvestLog : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time at which data harvest operation started, nanosecond resolution
    timestamp_t start;
    //! Duration of data harvest operation; milliseconds
    uint64_t duration;
    //! Total quantity of data transferred during data harvest operation;
    //! bytes. Inclusive of all message header and payload structures associated with the PSF/PDB
    uint64_t length;
    //! Identifier of PSF volume from which data will be harvested, and for which lower and upper (etc) apply.
    uint32_t volume_id;
    //! Lower bound PSF sequence number for a range of contiguous PSF data elements within the PSF volume specified by volume
    sequence_number_t lower;
    //! Upper bound PSF sequence number for a range of contiguous PSF data elements within the PSF volume specified by volume
    sequence_number_t upper;
    //! Unused data for alignment; set to 0.
    uint8_t SPARE1[4];
    typedef struct 
    {
      //! Timestamp marking the lower bound of a timespan
      timestamp_t time_lower;
      //! Timestamp marking the upper bound of a timespan
      timestamp_t time_upper;
      //! TRUE: timespan is valid. FALSE: timespan is invalid
      boolean_t valid;
      //! Unused data for alignment; set to 0
      uint8_t SPARE1[7];
    } sTimespan_t;

    //! Client supplied timespan specifying the target (or desired) lower and upper bound data time of the data harvest operation. Set to invalid if not applicable (eg. client doesnï¿½t harvest by time, only sequence number).
    sTimespan_t timespan_target;
    //! Actual timespan result of the data harvest operation in terms of lower and upper bound data time of the data harvest operation. Set to invalid if not applicable (eg. PSF volume does not contain data time values)
    sTimespan_t timespan_actual;
    struct sPlatformDesc_t
    {
      //! Harvester application software name and version; text string up to 64 characters long. Null-padded at end if length is less than maximum.  (note 1).
      //Eg.Pegasus Workstation Utility 1.2.2
      char harvester[64];
      //! Operating system name and version; text string up to 64 characters long. Null-padded at end if length is less than maximum.Eg. Microsoft Windows 10 Pro
      //Eg. Ubuntu Linux 18.10, 
      //Eg. macOS 10.14.4 Mojave
      char os[32];
      //! Kernel name and version; text string up to 64 characters long. Null-padded at end if length is less than maximum.
      //Eg. 4.18.0 - 17 - generic, x86_64
      char kernel[32];
      //! Platform make and model; text string up to 64 characters long.Null - padded at end if length is less than maximum.
      //Eg.Gnarbox 1 TB, Dell OptiPlex 7050
      char platform[32];
      //! Platform BIOS name and version; text string up to 64 characters long.Null - padded at end if length is less than maximum
      //Eg. Dell Inc., 1.11.1, 11/29/2018
      char bios[64];
      //! Platform CPU make and model; text string up to 64 characters long. Null-padded at end if length is less than maximum.
      //Eg.Intel Core i7 7700
      char cpu[32];
      //! Platform RAM information; text string up to 64 characters long.Null - padded at end if length is less than maximum.
      //Eg. 32 GiBytes
      char ram[32];
      //! Platform disk to which harvested data was written; text string up to 64 characters long. Null-padded at end if length is less than maximum.
      //Eg.PC401 NVMe SK hynix 512GB
      char disk[32];
    } platform_desc;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

public:
  //! MsgHarvestLog constructor
  MsgHarvestLog();

  //! MsgHarvestLog destructor
  virtual ~MsgHarvestLog() = default;

  /**
   * Initializes MsgHarvestLog object
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);

  /**
   * Header getter
   * @return  MsgHarvestLog header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }
};

#endif //MsgHarvestLog_h__
