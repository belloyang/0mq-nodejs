#ifndef MsgHealthDigest_h__
#define MsgHealthDigest_h__

#include "../IPDBMsgObject.h"

#define PDB_MAX_HEALTH_DIGESTS_PER_MSG 30

/// <summary>
/// MsgHealthDigest data type.\n
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.378cgpyq2w4r
/// </summary>
class MsgHealthDigest : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time of first sample in the packet, nanosecond resolution
    timestamp_t timestamp;
    //! Sample rate of health digests contained in the message.
    PDB_sSampleRate_t sample_rate;
    //! Number of health digests in the message; 0-30. See PDB_MAX_HEALTH_DIGESTS_PER_MSG above.
    uint16_t n_digest;
    //! Unused data for alignment (set to 0)
    uint8_t SPARE1[4];
    /**
     * Series of contiguous health digests.
     * Each element represents the worst-case status of all digitizer health metrics spanning
     * the corresponding health digest sample interval [ sample time , sample time + sample period ).
     */
    struct sDigest
    {
      //! Sensor input health metrics; one bit per metric up to maximum 32 metrics.
      uint32_t sensor;
      //! Clock subsystem health metrics; one bit per metric up to maximum 32 metrics.
      uint32_t clock;
      //! Power subsystem health metrics; one bit per metric up to maximum 32 metrics.
      uint32_t power;
      //! Recording subsystem health metrics; one bit per metric up to maximum 32 metrics.
      uint32_t record;
    } digests[PDB_MAX_HEALTH_DIGESTS_PER_MSG];

    //! Sensor Input Health Metrics
    typedef enum : uint32_t
    {
      METRIC_S1IN_CLIP    = 0x00000001, /*!< Sensor 1 input clipping. */
      METRIC_S2IN_CLIP    = 0x00000002, /*!< Sensor 2 input clipping. */
      METRIC_S3IN_CLIP    = 0x00000004, /*!< Sensor 3 input clipping. */
      METRIC_S4IN_CLIP    = 0x00000008, /*!< Sensor 4 input clipping. */

      METRIC_S1IN_ZERO    = 0x00000010, /*!< Sensor 1 input zero. */
      METRIC_S2IN_ZERO    = 0x00000020, /*!< Sensor 2 input zero. */
      METRIC_S3IN_ZERO    = 0x00000040, /*!< Sensor 3 input zero. */
      METRIC_S4IN_ZERO    = 0x00000080, /*!< Sensor 4 input zero. */

      METRIC_S1IN_DCOFF   = 0x00000100, /*!< Sensor 1 input excessive DC offset. */
      METRIC_S2IN_DCOFF   = 0x00000200, /*!< Sensor 2 input excessive DC offset. */
      METRIC_S3IN_DCOFF   = 0x00000400, /*!< Sensor 3 input excessive DC offset. */
      METRIC_S4IN_DCOFF   = 0x00000800, /*!< Sensor 4 input excessive DC offset. */

      METRIC_S1IN_STUCK   = 0x00001000, /*!< Sensor 1 input stuck non-zero ADC value. */
      METRIC_S2IN_STUCK   = 0x00002000, /*!< Sensor 2 input stuck non-zero ADC value. */
      METRIC_S3IN_STUCK   = 0x00004000, /*!< Sensor 3 input stuck non-zero ADC value. */
      METRIC_S4IN_STUCK   = 0x00008000, /*!< Sensor 4 input stuck non-zero ADC value. */

      METRIC_S1SOH_HIGH   = 0x00010000, /*!< Sensor 1 SOH high magnitude. */
      METRIC_S2SOH_HIGH   = 0x00020000, /*!< Sensor 2 SOH high magnitude. */
      METRIC_S3SOH_HIGH   = 0x00040000, /*!< Sensor 3 SOH high magnitude. */
      METRIC_S4SOH_HIGH   = 0x00080000, /*!< Sensor 4 SOH high magnitude. */

      METRIC_SENS_ILOW    = 0x00100000, /*!< Sensor current below minimum. */
      METRIC_SENS_IHIGH   = 0x00200000, /*!< Sensor current above maximum. */
      METRIC_SENS_TIMEOUT = 0x00400000, /*!< Timeout receiving samples from FPGA. The digitizer will trigger a jam-set. */
    } eSensorHealthMetrics;

    //! Clock Subsystem Health Metrics
    typedef enum : uint32_t
    {
      METRIC_CLK_ERRLOW   = 0x00000001, /*!< Clock error magnitude when GNSS engine comes online exceeds low threshold (100 µs as per Pegasus specification). Indicates that clock drift is larger than modelling predicts.  */
      METRIC_CLK_ERRHIGH  = 0x00000002, /*!< Clock error magnitude when GNSS engine comes online exceeds high threshold (1000 µs in Centaur). Digitizer triggers a jam-set. */
      METRIC_CLK_LEAP     = 0x00000004, /*!< Leap second event occured. This event is benign but it is useful to include in the health digest. */
      METRIC_CLK_POSITION = 0x00000008, /*!< GNSS engine reports large difference in position compared to station setup. May mean that the station was physically relocated. */
      METRIC_CLK_SVLOW    = 0x00000010, /*!< GNSS engine reports space vehicle count is below threshold for position fix. */
      METRIC_CLK_FIXLOW   = 0x00000020, /*!< GNSS engine position fix time exceeds low threshold. May indicate poor satellite viewing conditions. */
      METRIC_CLK_FIXHIGH  = 0x00000040, /*!< GNSS engine position fix time exceeds high threshold and position fix aborted. */
      METRIC_CLK_LOCKLOW  = 0x00000080, /*!< Clock discipline converge time exceeds low threshold. */
      METRIC_CLK_LOCKHIGH = 0x00000100, /*!< Clock discipline converge time exceeds high threshold and clock discipline aborted. */
      METRIC_CLK_HDOP     = 0x00000200, /*!< GNSS engine reports poor-quality fix based on dilution of precision data. Flag raised when the HDOP value reported by the GNSS engine exceeds threshold. */
      METRIC_CLK_VDOP     = 0x00000400, /*!< GNSS engine reports poor-quality fix based on dilution of precision data. Flag raised when the VDOP value reported by the GNSS engine exceeds threshold. */
      METRIC_CLK_PDOP     = 0x00000800, /*!< GNSS engine reports poor-quality fix based on dilution of precision data. Flag raised when the PDOP value reported by the GNSS engine exceeds threshold. */
      METRIC_CLK_TEMPLOW  = 0x00001000, /*!< VCXO temperature below minimum. */
      METRIC_CLK_TEMPHIGH = 0x00002000, /*!< VCXO temperature above maximum. */
      METRIC_CLK_TEMPRATE = 0x00004000, /*!< VCXO temperature rate of change magnitude exceeds threshold. */
      METRIC_CLK_COMM_ERR = 0x00008000, /*!< Hardware error reported while communicating with the GNSS engine. May indicate electrical noise affecting the communication between microcontroller and GNSS engine. */
      METRIC_CLK_PROTOCOL = 0x00010000, /*!< Protocol error in data from GNSS engine (NMEA checksum error). */
      METRIC_CLK_TOPPS    = 0x00020000, /*!< Timeout receiving PPS signal from GNSS engine. For example, due to a missing PPS signal. Although the clock discipline function may continue under these conditions, missing PPS signals may indicate an error up stream (FPGA, GNSS engine, GNSS antenna, etc). */
      METRIC_CLK_TODATA   = 0x00040000, /*!< Timeout receiving data (NMEA sentence) from GNSS engine. */
      METRIC_CLK_OOBPPS   = 0x00080000, /*!< Out-of-band PPS signal from GNSS engine. */
      METRIC_CLK_OOBDATA  = 0x00100000, /*!< Out-of-band data (eg. NMEA sentence) from GNSS engine. */
      METRIC_CLK_ANTOPEN  = 0x00200000, /*!< GNSS antenna open circuit. May mean cable break or disconnect. */
      METRIC_CLK_ANTSHORT = 0x00400000, /*!< GNSS antenna short circuit. May mean cable damaged. */
    } eClockHealthMetrics;

    //! Power Subsystem Health Metrics
    typedef enum : uint32_t
    {
      METRIC_PWR_VLOW     = 0x00000001, /*!< System voltage below minimum */
      METRIC_PWR_VHIGH    = 0x00000002, /*!< System voltage above maximum */
      METRIC_PWR_ILOW     = 0x00000004, /*!< Sensor current below minimum */
      METRIC_PWR_IHIGH    = 0x00000008, /*!< Sensor current above maximum */
      METRIC_PWR_OFFLINE  = 0x00000010, /*!< Digitizer lost power and was restarted */
      METRIC_OTHER_ERR    = 0x00000020, /*!< SPECIAL CASE: This is a catch-all for any internal error reported by the digitizer but not represented by any other health metric. Analysis of this condition requires the digitizer’s forensic log */
    } ePowerHealthMetrics;

    //! Recording Subsystem Health Metrics
    typedef enum : uint32_t
    {
      METRIC_REC_OFFLINE   = 0x00000001, /*!< Recording offline/paused as part of normal operation. */
      METRIC_REC_PRI_WERR  = 0x00000002, /*!< Error occurred while writing to primary eMMC. */
      METRIC_REC_PRI_RERR  = 0x00000004, /*!< Error occurred while reading from primary eMMC. */
      METRIC_REC_PRI_WTIME = 0x00000008, /*!< Time to complete primary eMMC write operation exceeds maximum. May indicate primary eMMC will fail soon. */
      METRIC_REC_PRI_RTIME = 0x00000010, /*!< Time to complete primary eMMC read operation exceeds maximum. May indicate primary eMMC will fail soon. */
      METRIC_REC_PRI_HASH  = 0x00000020, /*!< Hash validation failed while reading data from primary eMMC. */
      METRIC_REC_SEC_WERR  = 0x00000040, /*!< Error occurred while writing to secondary eMMC. */
      METRIC_REC_SEC_RERR  = 0x00000080, /*!< Error occurred while reading from secondary eMMC. */
      METRIC_REC_SEC_WTIME = 0x00000100, /*!< Time to complete secondary eMMC write operation exceeds maximum. May indicate secondary eMMC will fail soon. */
      METRIC_REC_SEC_RTIME = 0x00000200, /*!< Time to complete secondary eMMC read operation exceeds maximum. May indicate secondary eMMC will fail soon. */
      METRIC_REC_SEC_HASH  = 0x00000400, /*!< Hash validation failed while reading data from secondary eMMC. */
    } eRecordHealthMetrics;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

  /**
   * Header getter
   * @return  MsgHealthDigest header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }

public:
  /**
   * MsgHealthDigest constructor
   */
  MsgHealthDigest();

  /**
   * MsgHealthDigest destructor
   */
  virtual ~MsgHealthDigest() = default;

  /**
   * Initializes MsgHealthDigest object
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);
};

#endif //MsgHealthDigest_h__
