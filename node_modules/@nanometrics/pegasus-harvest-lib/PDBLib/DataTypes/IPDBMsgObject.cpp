#include "IPDBMsgObject.h"

#include <cstring> // memcpy

IPDBMsgObject::IPDBMsgObject(const PDB_eMessageType_t type)
: m_type(type)
, m_size(0)
{
  __DEV_CALLSTACK_FUNC__;
  ::memset(&m_bufferState, 0, sizeof(m_bufferState));
}

IPDBMsgObject::~IPDBMsgObject()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_bufferState.buffer != nullptr)
  {
    ::free(m_bufferState.buffer);
  }
}

bool IPDBMsgObject::restore(const PSFDataElement* pDataElement)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pDataElement != nullptr && "pDataElement cannot be 0 here");
  if (pDataElement == nullptr)
    return false;

  //tss_pdb::get header information
  const sPSFDataElementHeader_t* const pHeader = pDataElement->getHeader();
  if (pHeader == nullptr)
    return false;
  //tss_pdb::check if PSF & PDB types match
  __ASSERT__(pHeader->messageType == m_type && "PSF and PDB types mismatch");
  if (pHeader->messageType != m_type)
    return false;

  //tss_pdb::lock data element buffer
  const void* pData = nullptr;
  const size_t size = pDataElement->getData(&pData);
  if (size > 0)
  {
    //tss_pdb::allocate buffer and copy PSF data to it
    char* pBuffer = this->_alloc_buffer(size);
    ::memcpy(pBuffer, pData, size);
    return true;
  }
  return false;
}

bool IPDBMsgObject::lockBuffer(void** pBuffer, size_t* bufferSize) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(bufferSize != nullptr && "bufferSize should not be NULL");
  if (bufferSize == nullptr)
    return false;

  if (pBuffer != nullptr)
    *pBuffer = m_bufferState.buffer;
  //tss_pdblib::expose only used buffer size
  *bufferSize = m_size;

  return true;
}

char* IPDBMsgObject::_alloc_buffer(const uint32_t size)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(size > 0 && "'size' should be positive value");
  if (size <= 0)
    return nullptr;

  //tss_pdblib::check if buffer is sufficient to hold new data of specified size
  if (m_bufferState.size >= size)
  {
    //tss_psflib::update used size
    m_size = size;
  }
  else //tss_psflib::buffer is too small -> reallocate it
  {
    // NOTE: using realloc() to allocate memory from heap
    m_bufferState.buffer = reinterpret_cast<char*>(::realloc(m_bufferState.buffer, size * sizeof(char)));
    if (m_bufferState.buffer != nullptr)
    {
      m_bufferState.size = m_size = size;
    }
  }

  return m_bufferState.buffer;
}
