#ifndef MsgGnssControl_h__
#define MsgGnssControl_h__

#include "../IPDBMsgObject.h"

/// <summary>
/// MsgGnssControl data type.\n
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.bnmmvy2qfqbx
/// </summary>
class MsgGnssControl : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time at which data harvest operation started, nanosecond resolution
    timestamp_t timestamp;
    //! TRUE: GNSS engine running. FALSE: GNSS engine not running
    boolean_t bRunning;
    //! TRUE: GNSS engine duty cycle override. FALSE: GNSS engine duty cycle non-override. Ie. normal duty cycle schedule
    boolean_t bOverride;
    //! TRUE: Select external GNSS antenna. FALSE: Select internal GNSS antenna
    boolean_t bExtAntenna;
    //! Unused data for alignment; set to 0
    uint8_t SPARE1[1];
    //! Volume reference index: contains a sequence number reference into all known volumes (excluding this volume) synchronised to this event
    PDB_sVolumeRefIndex_t index;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

public:
  //! MsgGnssControl constructor
  MsgGnssControl();

  //! MsgGnssControl destructor
  virtual ~MsgGnssControl() = default;

  /**
   * Initializes MsgGnssControl object
   * @param header  data header
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);

  /**
   * Header getter
   * @return  MsgGnssControl header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }
};

#endif //MsgGnssControl_h__
