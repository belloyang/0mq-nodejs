#ifndef MsgOpaqueData_h__
#define MsgOpaqueData_h__

#include "../IPDBMsgObject.h"

#define PDB_OPAQUE_DATA_SIZE 16384

/// <summary>
/// MsgOpaqueData data type.\n
/// https://docs.google.com/document/d/14MP9wyTEQR713j-rs5dvP_3eoQgxDgeEWVewhYXv7Rg/edit#heading=h.m6523wybgkt8
/// </summary>
class MsgOpaqueData : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time at which data harvest operation started, nanosecond resolution
    timestamp_t timestamp;
     //! Size, in bytes, of data held within opaque_data; 0-PDB_OPAQUE_DATA_SIZE(16384)
    uint32_t opaque_size;
    //! Storage area for opaque data
    union OpaqueData {
      uint8_t buffer[PDB_OPAQUE_DATA_SIZE];
      struct
      {
        //! Version id of this structure. Keep as 2 bytes to keep things word aligned internally.
        // Current version : 0x4F44 (ascii �OD�)
        // If a consumer comes across a different version, they cannot parse it(ie if harvester has not been updated
        uint16_t version;
        //! Compression type of the body.
        enum eCompression : uint8_t
        {
          COMPRESSION_NONE = 0x0, /*!< None compression */
          COMPRESSION_GZIP = 0x1, /*!< gzip compression */
        } compression;
        //! MIME type and character encoding (if applicable) of the body, after compression
        enum eContentType : uint8_t
        {
          MTYPE_PLAIN_TEXT            = 0x0, /*!< plain text */
          MTYPE_APPLICATION_JSON_UTF8 = 0x1, /*!< application/json; charset=utf-8 */
        } m_content_type;
        uint8_t body[PDB_OPAQUE_DATA_SIZE - 4]; //4 bytes are reserved for the header (version, compression, content type) that precedes data by itself
      } content;
    } opaque_data;

    //! Volume reference index: contains a sequence number reference into all known volumes (excluding this volume) synchronised to this event.
    PDB_sVolumeRefIndex_t index;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

public:
  //! MsgOpaqueData constructor
  MsgOpaqueData();

  //! MsgOpaqueData destructor
  virtual ~MsgOpaqueData() = default;

  /**
   * Initializes MsgOpaqueData object
   * @param header  header data
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);

  /**
   * Header getter
   * @return  MsgOpaqueData header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<const Header*>(m_bufferState.buffer); }
};

#endif //MsgOpaqueData_h__
