#ifndef MsgSmartSensor_h__
#define MsgSmartSensor_h__

#include "../IPDBMsgObject.h"

/// <summary>
/// MsgSmartSensor data type.\n
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.vz7n2k2rbsud
/// </summary>
class MsgSmartSensor : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time at which data harvest operation started, nanosecond resolution
    timestamp_t timestamp;
    //! Flag: Nanometrics smart sensor connected
    boolean_t bConnected;
    //! Flag: Mass recenter operation in progress
    boolean_t bRecenter;
    //! Unused data for alignment; set to 0
    uint8_t SPARE1[2];
    //! BIN number of Nanometrics smart sensor; text string up to 32 characters long, null-padded at end (max length => NOT null-terminated)
    char bin[32];
    //! Serial number of Nanometrics smart sensor
    uint32_t serial;
    //! Firmware version of Nanometrics smart sensor
    uint32_t firmware;
    //! Sensor period selection
    enum eSensorPeriod : uint16_t
    {
      SENSOR_PERIOD_NA    = 0x0000, /*!< Sensor period selection not applicable */
      SENSOR_PERIOD_SHORT = 0x0001, /*!< Sensor short period */
      SENSOR_PERIOD_LONG  = 0x0002, /*!< Sensor long period */
    } period;
    //! Sensor reference frame selection
    enum eSensorFrame : uint16_t
    {
      SENSOR_FRAME_NA  = 0x0000, /*!< Sensor reference frame selection not applicable */
      SENSOR_FRAME_UVW = 0x0001, /*!< UVW sensor reference frame */
      SENSOR_FRAME_XYZ = 0x0002, /*!< XYZ sensor reference frame */
    } frame;
    //! Volume reference index: contains a sequence number reference into all known volumes (excluding this volume) synchronised to this event
    PDB_sVolumeRefIndex_t index;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

public:
  //! MsgSmartSensor constructor
  MsgSmartSensor();

  //! MsgSmartSensor destructor
  virtual ~MsgSmartSensor() = default;

  /**
   * Initializes MsgSmartSensor object
   * @param header  header data
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);

  /**
   * Header getter
   * @return  MsgSmartSensor header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }
};

#endif //MsgSmartSensor_h__
