#ifndef MsgDigitizerStart_h__
#define MsgDigitizerStart_h__

#include "../IPDBMsgObject.h"

/// <summary>
/// MsgDigitizerStart data type.\n
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.r5ibgkx71cd5
/// </summary>
class MsgDigitizerStart : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time at which digitizer started, nanosecond resolution
    timestamp_t timestamp;
    //! Reason for digitizer restart
    enum eStartReason : uint16_t
    {
      START_REASON_POWER_ON       = 0x0000, /*!< Digitizer (re)started following power on */
      START_REASON_HARVEST        = 0x0001, /*!< Digitizer soft restart following end of data harvest operation.
      Ie. a soft restart is used to reinstate recording to PDB */
      START_REASON_FIRMWARE       = 0x0002, /*!< Digitizer restarted following firmware update */
      START_REASON_ERROR_RECOVER  = 0x0003, /*!< Digitizer restarted in order to attempt to recover from an error.
      For example, loss of synchronization with the acquisition */
      START_REASON_CONFIG_UPDATE  = 0x0004, /*!< Digitizer restarted due to configuration update. For example, configuration update triggered by the Pegasus Mobile App. */
      START_REASON_JAMSET         = 0x0005, /*!< Digitizer restarted data recording following successful completion of clock jamset operation. */
      START_REASONS_COUNT /*!< just the value for count */
    } reason;
    //! Digitizer serial number; text string exactly 6 characters long. Eg. 001234  (note 1)
    char serial[6];
    //! Digitizer BIN number; text string up to 32 characters long. Null-padded at end if length is less than maximum.
    char bin[32];
    //! Digitizer firmware version; text string up to 16 characters long. Null-padded at end if length is less than maximum.
    //! The expected version string format is as follows: <major>.<minor>.<build>[-RC]
    char firmware[16];
    //! FPGA firmware version; text string up to 8 characters long. Null-padded at end if length is less than maximum.
    //! The expected version string format is as follows: <major_hex>_<minor_hex>
    char fpga[8];
    //! Network name; text string up to 2 characters long. Null-padded at end if length is less than maximum
    char network[2];
    //! Station name; text string up to 5 characters long. Null-padded at end if length is less than maximum.
    char station[5];
    //! Number of channels defined in channels member; 0-4.
    uint8_t n_channels;
    //! Separate channel description for up to 4x channels, where only the first n_channels are valid
    struct sChannel
    {
      //! Channel name; text string up to 3 characters long. Null-padded at end if length is less than maximum.
      char name[3];
      //! Location code of channel; text string up to 2 characters long. Null-padded at end if length is less than maximum.
      char location[2];
    } channels[4];
    //! Estimate of digitizer offline period; seconds. Set to -1 if unknown
    int32_t offline;
    //! Hardware state at digitizer start
    struct sHardwareState
    {
      //! Hardware identifier, used as a key to interpret state.
      enum HardwareID : uint32_t
      {
        HARDWARE_ID_UNKNOWN = 0x00000000u,
        HARDWARE_ID_STM32H7 = 0x00000001u,
      } id;
      union HardwareState_VARIANT
      {
        //! Storage for union of different hardware state structures. See HardwareStateXXX structures below.  (note 1)
        uint32_t state[16];
        struct sHardwareState_STM32H7
        {
          //! silicon revision ID
          uint32_t revision_id;
          //! Reset Status Register (RSR). Contains reset reason information bits
          uint32_t reset_status_register;
        } stm32h7;
      } state;
    } hardware_state;
    //! Volume reference index: contains a sequence number reference into all known volumes (excluding this volume) synchronised to this event
    PDB_sVolumeRefIndex_t index;
  } Header;
  #pragma pack(pop)

public:
  //! MsgDigitizerStart constructor
  MsgDigitizerStart();

  //! MsgDigitizerStart destructor
  virtual ~MsgDigitizerStart() = default;

  /**
   * Initializes MsgDigitizerStart object
   * @param header  header data
   * @return  true on success; false - otherwise
   */
  bool init(const Header& header);

  /**
   * Header getter
   * @return  MsgDigitizerStart header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }
};

#endif //MsgDigitizerStart_h__
