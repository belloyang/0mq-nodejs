#ifndef MsgSohData_h__
#define MsgSohData_h__

#include "../IPDBMsgObject.h"

static const PDB_sSampleRate_t MSG_SOH_DATA_INPUT_SAMPLE_RATE_DEFAULT = PDB_sSampleRate_t{ {-10, 1} };

/// <summary>
/// SOH time series data message
/// https://docs.google.com/document/d/1cYA0qCKbdYmDP_8RyxkztuvZNCNWDK7DPzsD3jCoT1k/edit#heading=h.eu5dixgb6dvv
/// </summary>
class MsgSohData : public IPDBMsgObject
{
public:
  enum ChannelID : uint32_t
  {
    ATU = BIT(0),
    VAN = BIT(1),
    VCE = BIT(2),
    VCO = BIT(3),
    VCQ = BIT(4),
    VDP = BIT(5),
    VDT = BIT(6),
    VE1 = BIT(7),
    VE2 = BIT(8),
    VEI = BIT(9),
    VEL = BIT(10),
    VGL = BIT(11),
    VGT = BIT(12),
    VLA = BIT(13),
    VLO = BIT(14),
    VM1 = BIT(15),
    VM2 = BIT(16),
    VM3 = BIT(17),
    VM4 = BIT(18),
    VPH = BIT(19),
    VPL = BIT(20),
    VPO = BIT(21),
    VPP = BIT(22),
    VPT = BIT(23),
    VPV = BIT(24),
    VNS = BIT(25),
    VST = BIT(26),

    ALL_CHANNELS                    = 0xFFFFFFFF,
    NO_PUBLIC_AVAILABILITY_CHANNELS = VGL | VPT, // no public availability channels
    PUBLIC_CHANNELS_OBS             = ALL_CHANNELS & ~(NO_PUBLIC_AVAILABILITY_CHANNELS),      // public availability channel (OBS)
    PUBLIC_CHANNELS_LAND            = ALL_CHANNELS & ~(NO_PUBLIC_AVAILABILITY_CHANNELS | VPO) // public availability channels (LAND)
  };
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  struct Header
  {
    //! POSIX time of first sample in the packet, nanosecond resolution
    timestamp_t timestamp;
    //! sample rate (factor, multiplier)
    PDB_sSampleRate_t sample_rate;
    //! Number of samples in the message; 1-4
    uint8_t n_samples;
    //! spare data (for memory alignment)
    uint8_t SPARE1[5];
    //! Sample array of SOH channels. Element # represents sample number with respect to time and according to sample_rate.
    struct SohDataV0
    {
      struct HealthInputsV0
      {
        HealthInputsV0& operator +=(const HealthInputsV0& op)
        {
          this->sensor_soh[0] += op.sensor_soh[0];
          this->sensor_soh[1] += op.sensor_soh[1];
          this->sensor_soh[2] += op.sensor_soh[2];
          this->sensor_soh[3] += op.sensor_soh[3];
          this->system_voltage += op.system_voltage;
          this->system_current += op.system_current;
          this->system_temperature += op.system_temperature;
          this->system_pressure += op.system_pressure;
          this->sensor_current += op.sensor_current;
          return (*this);
        }

        HealthInputsV0 operator * (const float multiplier) const
        {
          HealthInputsV0 ret = (*this);
          ret.sensor_soh[0] *= multiplier;
          ret.sensor_soh[1] *= multiplier;
          ret.sensor_soh[2] *= multiplier;
          ret.sensor_soh[3] *= multiplier;
          ret.system_voltage *= multiplier;
          ret.system_current *= multiplier;
          ret.system_temperature *= multiplier;
          ret.system_pressure *= multiplier;
          ret.sensor_current *= multiplier;
          return ret;
        }

        //! Sensor SOH signals 1-4; Volt.
        float sensor_soh[4] = {0.f, 0.f, 0.f, 0.f};
        //! System input voltage; Volt.
        float system_voltage = 0.f;
        //! System input current; Ampere.
        float system_current = 0.f;
        //! System internal temperature; degrees Celsius
        float system_temperature = 0.f;
        //! System internal pressure; Pascal.
        float system_pressure = 0.f;
        //! Sensor current; Ampere.
        float sensor_current = 0.f;
        //! unused, set to 0 (reserved for future use)
        uint8_t UNUSED[4];
      } health_inputs;
      struct ClockStatusV0
      {
        //! Latitude reported by GNSS engine; arc degrees [ -90° , +90° ]; -ve => south, +ve => north
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        double gnss_latitude;
        //! Longitude reported by GNSS engine; arc degrees [ -180° , +180° ); -ve => west, +ve => east
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        double gnss_longitude;
        //! Elevation above mean sea level reported by GNSS engine; metres.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        float gnss_elevation;

        //! Position (3D) dilution of precision; > 0.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        float gnss_pdop;
        //! Horizontal dilution of precision; > 0.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        float gnss_hdop;
        //! Vertical dilution of precision; > 0.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        float gnss_vdop;

        //! GNSS PPS time relative to Seascan PPS time; nanoseconds [ 0 , +999,999,999 ].
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        uint32_t seascan_pps_phase;
        //! Time taken for the GNSS engine to achieve position fix and output PPS with corresponding GNSS time. Lock time is dependent on several factors, including GNSS antenna orientation and operating environment (particularly any obstructions to satellite view); seconds ≥ 0.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        uint32_t gnss_lock_time;
        //! GNSS time expressed as a POSIX time value. I.e. seconds since midnight Jan 1st 1970.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        int32_t gnss_time;
        //! Predicted system time error magnitude when the GNSS engine is disabled.
        // Linear clock drift of 100 µs per hour assumed; microseconds ≥ 0. Maximum of 1 second
        uint32_t time_uncertainty;
        //! Measured system time error relative to GNSS time. Measurement is taken at each GNSS PPS interrupt; microseconds.
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        int32_t system_clock_error;

        //! Control setpoint of VCXO device (which sets the frequency offset). Unit is DAC counts.
        // Pegasus uses a 16-bit DAC for the VCXO control setpoint. Therefore, this value ranges from 0 to 65,535 inclusive.
        uint32_t vcxo_control;
        //! Time taken for VCXO PLL to converge since PLL was last enabled; seconds ≥ 0.
        uint32_t vcxo_pll_converge;
        //! Status of PLL used to synchronise the digitizer’s VCXO to reference time.
        enum PLLStatus : uint8_t
        {
          PLL_STATUS_NO_LOCK     = 0x00, /*!< PLL is running but VCXO is not locked to the time reference. I.e. Magnitude of residual (VCXO relative to time reference) > 100 µs. */
          PLL_STATUS_COARSE_LOCK = 0x01, /*!< PLL is running and VCXO is coarse-locked to the time reference. I.e. 1 µs < |residual| ≤ 100 µs. */
          PLL_STATUS_FINE_LOCK   = 0x02, /*!< PLL is running and VCXO is fine-locked to the time reference. I.e. |residual| ≤ 1 µs. */
          PLL_STATUS_FREE_RUN    = 0x03, /*!< PLL is not running such that the VCXO is free running. */
        } vcxo_pll_status;

        //! GNSS position fix status.
        enum FixStatus : uint8_t
        {
          FIX_STATUS_NONE          = 0,      /*!< GNSS engine is disabled, so all flags are cleared */
          FIX_STATUS_2D            = BIT(0), /*!< flag - position fix information is limited to a 2D (horizontal) solution. */
          FIX_STATUS_3D            = BIT(1), /*!< flag - position fix information is a full 3D (horizontal & vertical) solution. */
          FIX_STATUS_TIME          = BIT(2), /*!< flag - time fix information is available. */
          FIX_STATUS_GNSS_ENABLED  = BIT(3), /*!< flag - GNSS engine is enabled. */
        };
        uint8_t gnss_fix_status;
        //! GNSS antenna status.
        enum AntennaStatus : uint8_t
        {
          ANTENNA_STATUS_OK    = 0x00, /*!< GNSS antenna status is reported as being ok. */
          ANTENNA_STATUS_OPEN  = 0x01, /*!< GNSS antenna status is reported as being open circuit (disconnected). */
          ANTENNA_STATUS_SHORT = 0x02, /*!< GNSS antenna status is reported as being short circuit. */
          ANTENNA_STATUS_OFF   = 0xFF, /*!< GNSS antenna is not powered, which means that additional status information is not available. */
        } gnss_antenna_status;
        //! Number of GNSS satellites used for position fix (all selected constellations).
        // The last value is preserved when the GNSS engine is disabled. See also gnss_fix_status.
        uint8_t gnss_satellite_count;

        //! Heuristic time quality  value expressed as percentage and defined as follows:
        // When GNSS engine is enabled:
        //    100%: System time is fine locked; see vcxo_pll_status.
        //    90%: System time is coarse locked; see vcxo_pll_status.
        //    70%: 100 µs < system clock error ≤ 200 µs; see system_clock_error.
        //    < 70%:  System clock error > 200 µs. Decreases by 1% for each 100 µs additional system clock error beyond 200 µs; see system_clock_error.
        // When GNSS engine is disabled:
        //    70%: estimated system time uncertainty ≤ 200 µs; see time_uncertainty.
        //    < 70%:  System time uncertainty > 200 µs. Decreases by 1% for each 100 µs additional system time uncertainty beyond 200 µs; see time_uncertainty.
        uint8_t clock_quality;
        //! Unused data for future use; set to 0.
        uint8_t UNUSED[15];
      } clock_status;
    } soh_data[4];
  };
  #pragma pack(pop) // #pragma pack(push, 1)

  //! Header getter
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }

public:
  /**
   * MsgSohData constructor
   */
  MsgSohData();

  /**
   * MsgSohData destructor
   */
  virtual ~MsgSohData() = default;

  /**
   * Initializes MsgSohData object
   * @param header  header data
   * @return        true on success; false - otherwise
   */
  bool init(const Header& header);
};

#endif // MsgSohData_h__
