#ifndef MsgClockStatus_h__
#define MsgClockStatus_h__

#include "../IPDBMsgObject.h"

static const PDB_sSampleRate_t MSG_CLOCK_STATUS_RESAMPLING_RATE = PDB_sSampleRate_t{ {1, -60} }; //1 sample per 1 minute

/// <summary>
/// MsgClockStatus data type.
/// https://docs.google.com/document/d/1MmqKtqdSDSwQqB5bv-6PxX23_eUgODdgNfh0yyGyZy4/edit#heading=h.2yl4ofo5hgzm
/// </summary>
class MsgClockStatus : public IPDBMsgObject
{
public:
  //! Header structure
  #pragma pack(push, 1) // compact byte packing
  typedef struct
  {
    //! POSIX time when GNSS engine turned on; nanosecond resolution.
    timestamp_t timestamp;

    //! Flags to elaborate the data contained in this message.
    typedef enum : uint8_t
    {
      FLAG_CLEAR                          = 0,      /*!< Unset (0) flag */
      FLAG_EXTERNAL_GNSS_ANTENNA_SELECTED = 1 << 0, /*!< External GNSS antenna selected flag. True => external antenna selected. False => internal antenna selected */
    } eFlags;
    uint8_t flags; //!< eFlags combination

    //! GNSS duty cycle mode
    enum eDutyCycle : uint8_t
    {
      DUTY_CYCLE_AUTOMATIC = 0x00, //!< GNSS engine is duty cycled automatically according to a prescribed schedule.
      DUTY_CYCLE_ALWAYS_ON = 0x01, //!< GNSS engine is on at all times and automatic duty cycling is disabled. Continuous clock synchronisation is possible so long as GNSS satellite coverage is available.
      DUTY_CYCLE_FREE_RUN  = 0x02, //!< GNSS engine is off at all times and automatic duty cycling is disabled. Clock synchronisation is not possible.
    } duty_cycle;

    //! GNSS antenna status
    enum eAntennaStatus : uint8_t
    {
      ANTENNA_STATUS_OK    = 0x00, //!< GNSS antenna status is reported as being ok.
      ANTENNA_STATUS_OPEN  = 0x01, //!< GNSS antenna status is reported as being open circuit (disconnected).
      ANTENNA_STATUS_SHORT = 0x02, //!< GNSS antenna status is reported as being short circuit.
      ANTENNA_STATUS_OFF   = 0xFF, //!< GNSS antenna is not powered, which means that additional status information is not available.
    } antenna_status;

    //! GNSS position fix status
    enum eFixStatus : uint8_t
    {
      FIX_STATUS_NONE = 0x00, //!< No position fix information is available.
      FIX_STATUS_2D   = 0x01, //!< Position fix information is limited to a 2D (horizontal) solution.
      FIX_STATUS_3D   = 0x02, //!< Position fix information is a full 3D (horizontal & vertical) solution.
    } fix_status;

    //! Master clock discipline status
    enum eClockStatus : uint8_t
    {
      CLOCK_STATUS_NO_LOCK      = 0x00, //!< Master clock has not been synchronised to GPS time since power-on of the digitizer. The control voltage setpoint to the VCXO device remains at default (typically mid-way).
      CLOCK_STATUS_FREE_RUN     = 0x01, //!< Master clock is in a free running state and may not be synchronised to GPS time. This state differs from CLOCK_STATUS_NO_LOCK in that one or more attempts (successful or otherwise) were previously made to synchronise the master clock to GPS time.
      CLOCK_STATUS_PARTIAL_LOCK = 0x02, //!< Master clock is partially synchronised to GPS time. This occurs when the clock discipline function fails to converge within a prescribed time.
      CLOCK_STATUS_FULL_LOCK    = 0x03, //!< Master clock is fully synchronised to GPS time. This occurs when the clock discipline function runs to completion and convergence was achieved.
      CLOCK_STATUS_ALWAYS_ON    = 0x04, //!< GNSS engine is always on and clock discipline function is running continuously.
    } clock_status;

    //! Flags to indicate which GNSS constellations were selected at the time of this position fix (combination of PDB_eConstellations_t)
    uint8_t constellations;

    //==========================================================================
    // NOTE:
    // The following enum (with exception of UNKNOWN) should map to 'GPS Quality
    // Indicator' from NMEA 0183 v4.10.
    //==========================================================================
    //! GNSS mode indicator for this fix, aggregated for all constellations employed. */
    enum eGNSSMode : uint8_t
    {
      GNSS_MODE_NO_FIX  = 0x00, /*!< No fix : Satellite system not used in position fix, or fix not valid. */
      GNSS_MODE_AUTO    = 0x01, /*!< Autonomous : Satellite system used in non-differential mode in position fix. */
      GNSS_MODE_DIFF    = 0x02, /*!< Differential : Satellite system used in differential mode in position fix. Corrections from ground stations or Satellite Based Augmentation System (SBAS). */
      GNSS_MODE_PRECISE = 0x03, /*!< Precise : Satellite system used in precision mode. Precision mode is defined as: no deliberate degradation (such as selective availability) and higher resolution (P-code) use used to compute position fix. Also used for satellite system used in multi-frequency, or Precise Point Positioning Service (PPP) mode. */
      GNSS_MODE_RTK     = 0x04, /*!< Real Time Kinematic (RTK) : Satellite system used in RTK mode with fixed integers. */
      GNSS_MODE_FLOAT   = 0x05, /*!< Float RTK : Satellite system used in RTK mode with floating integers. */
      GNSS_MODE_EST     = 0x06, /*!< Estimated (dead reckoning) Mode. */
      GNSS_MODE_MANUAL  = 0x07, /*!< Manual Input Mode. */
      GNSS_MODE_SIM     = 0x08, /*!< Simulator Mode. */
      GNSS_MODE_UNKNOWN = 0xFF, /*!< GNSS mode is unknown. */
    } gnss_mode;

    //! Unused data for alignment; set to 0
    uint8_t SPARE1;

    //! Accumulated clock free-run duration since master clock was last synchronized; seconds >= 0.
    uint32_t acc_freerun;

    //! Time taken for master clock discipline function to converge since GNSS engine was turned on (if applicable); seconds >= 0.
    uint16_t converge_time;

    //! Number of satellites used for position fix (all selected constellations)
    uint16_t n_satellites;

    //! Latitude reported by GNSS engine, arc degrees, [ -90deg , +90deg ], Positive is North
    double latitude;
    //! Longitude reported by GNSS engine, arc degrees, [ -180deg , +180deg ), Positive is East
    double longitude;
    //! Altitude above mean sea level reported by GNSS engine, metres
    float altitude;

    //! Horizontal dilution of precision, > 0 (https://en.wikipedia.org/wiki/Dilution_of_precision_(navigation))
    dop_t hdop;
    //! Vertical dilution of precision, > 0 (https://en.wikipedia.org/wiki/Dilution_of_precision_(navigation))
    dop_t vdop;
    //! Position (3D) dilution of precision, > 0 (https://en.wikipedia.org/wiki/Dilution_of_precision_(navigation))
    dop_t pdop;

    //! Pre-discipline master clock measured residual relative to GPS time; seconds
    float residual_meas;
    //! Master clock drift rate estimate; nanoseconds per hour. For this estimate the drift is assumed to be linear over the clock free run time interval (GNSS engine offline duration)
    int32_t drift_est;

    //! Post-discipline status of master clock. This member provides low-level and platform dependent information, which may assist forensic analysis
    struct
    {
      //! Temperature of VCXO device, degrees Celsius
      float temperature;
      //! Control setpoint of VCXO device (which sets the frequency offset), DAC counts
      uint32_t control;
      //! Model of VCXO device
      PDB_eVcxoModel_t model;
    } vcxo;
  } Header;
  #pragma pack(pop) // #pragma pack(push, 1)

  /**
   * Header getter
   * @return  MsgClockStatus header
   */
  FORCE_INLINE const Header* getHeader() const { return reinterpret_cast<Header*>(m_bufferState.buffer); }

public:
  /**
   * MsgClockStatus constructor
   */
  MsgClockStatus();

  /**
   * MsgClockStatus destructor
   */
  virtual ~MsgClockStatus() = default;

  /**
   * Initializes MsgClockStatus object
   * @param header  header data
   * @return        true on success; false - otherwise
   */
  bool init(const Header& header);
  
  static int32_t getClockQuality_Automatic(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t);
  static int32_t getClockQuality_AlwaysOn(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t);
  static int32_t getClockQuality_FreeRun(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t);

  //NOTE: Time uncertainty can be + / -, so retain the sign of drift in these three methods.
  static int32_t getTimeUncertainty_Automatic(const MsgClockStatus::Header& latest, const timestamp_t t);
  static int32_t getTimeUncertainty_AlwaysOn(const MsgClockStatus::Header& latest, const timestamp_t t);
  static int32_t getTimeUncertainty_FreeRun(const MsgClockStatus::Header& latest, const timestamp_t t);
};

#endif //MsgClockStatus_h__
