#include "MsgClockStatus.h"
#include <algorithm> // min, max

MsgClockStatus::MsgClockStatus()
:  IPDBMsgObject(PDB_eMessageType_t::MSG_CLOCK_STATUS_V0)
{
  __DEV_CALLSTACK_FUNC__;
}

bool MsgClockStatus::init(const Header& header)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_pdb::calculate total data size
  const size_t totalSize = sizeof(Header);
  char* pBuffer = this->_alloc_buffer(totalSize);
  if (pBuffer != nullptr)
  {
    Header* const headerPtr = reinterpret_cast<Header*>(pBuffer);
    ::memcpy(headerPtr, &header, sizeof(Header));
    return true;
  }

  return false;
}

/*static*/ int32_t MsgClockStatus::getClockQuality_Automatic(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t)
{
  __DEV_CALLSTACK_FUNC__;
  const double OUTPUT_PERIOD_sec = 1.0 / pdb_utils::decode_sample_rate(sampleRate);
  const timediff_t OUTPUT_PERIOD_ns = pdb_utils::seconds_to_nanoseconds(OUTPUT_PERIOD_sec); // seconds -> nanoseconds
  const timestamp_t LAST_CONVERGE_TIME_ns = latest.timestamp + pdb_utils::seconds_to_nanoseconds(latest.converge_time); //nanoseconds
  timediff_t FREE_RUN_DURATION_ns = pdb_utils::seconds_to_nanoseconds(latest.acc_freerun); // nanoseconds
  //handle clock discipline function converged
  if (latest.clock_status != MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_NO_LOCK && 
      latest.clock_status != MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_FREE_RUN) 
  {
    // handle recently completed
    if (t >= LAST_CONVERGE_TIME_ns)
    {
      if (t - LAST_CONVERGE_TIME_ns < OUTPUT_PERIOD_ns)
      {
        if (latest.clock_status == MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_FULL_LOCK)
          return 100;
        else if (latest.clock_status == MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_PARTIAL_LOCK)
          return 90;
      }
      // modify free-run duration
      FREE_RUN_DURATION_ns = t - LAST_CONVERGE_TIME_ns;
    }
  }
  //handle tolerable uncertainty
  const double FREE_RUN_DURATION_hours = pdb_utils::nanoseconds_to_hours(FREE_RUN_DURATION_ns);
  const timestamp_t EST_ERROR_ns = static_cast<timestamp_t>(FREE_RUN_DURATION_hours * std::abs(latest.drift_est)); //nanoseconds
  if (EST_ERROR_ns < 100000) //100 microseconds (100000 nanoseconds)
    return 70;
  // compute graded quality below 70%
  return std::max<int32_t>(0, 70 - static_cast<int32_t>(FREE_RUN_DURATION_hours));
}

/*static*/ int32_t MsgClockStatus::getClockQuality_AlwaysOn(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t)
{
  __DEV_CALLSTACK_FUNC__;
  // handle continuous running of clock discipline function
  if (latest.clock_status == MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_ALWAYS_ON) {
    // as good as it gets
    return 100;
  }
  // fallback to free running logic
  return MsgClockStatus::getClockQuality_FreeRun(latest, sampleRate, t);
}

/*static*/ int32_t MsgClockStatus::getClockQuality_FreeRun(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*t*/)
{
  __DEV_CALLSTACK_FUNC__;
  // handle tolerable uncertainty
  const double FREE_RUN_hours = (double)latest.acc_freerun / 3600.0; //seconds -> hours
  const timestamp_t EST_ERROR_ns = static_cast<timestamp_t>(FREE_RUN_hours * std::abs(latest.drift_est)); // nanoseconds
  if (EST_ERROR_ns < 100000) //100 microseconds (100000 nanoseconds)
    return 70;
  // compute graded quality below 70%
  return std::max<int32_t>(0, 70 - static_cast<int32_t>(FREE_RUN_hours));
}

/*static*/ int32_t MsgClockStatus::getTimeUncertainty_Automatic(const MsgClockStatus::Header& latest, const timestamp_t t)
{
  __DEV_CALLSTACK_FUNC__;
  const timestamp_t LAST_CONVERGE_TIME_ns = latest.timestamp + pdb_utils::seconds_to_nanoseconds(latest.converge_time);
  timestamp_t FREE_RUN_DURATION_ns = pdb_utils::seconds_to_nanoseconds(latest.acc_freerun); //nanoseconds

  // handle clock discipline function converged
  if (latest.clock_status != MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_NO_LOCK && 
      latest.clock_status != MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_FREE_RUN) 
  {
    // handle recently completed
    if (t >= LAST_CONVERGE_TIME_ns) 
    {
      // modify free-run duration
      FREE_RUN_DURATION_ns = t - LAST_CONVERGE_TIME_ns; // nanoseconds
    }
  }
  // compute timing uncertainty
  const double FREE_RUN_hours = (double)FREE_RUN_DURATION_ns / (double)pdb_utils::hours_to_nanoseconds(1);
  return static_cast<int32_t>(pdb_utils::nanoseconds_to_microseconds(static_cast<timestamp_t>(FREE_RUN_hours * latest.drift_est))); // nanoseconds -> microseconds
}

/*static*/ int32_t MsgClockStatus::getTimeUncertainty_AlwaysOn(const MsgClockStatus::Header& latest, const timestamp_t t)
{
  __DEV_CALLSTACK_FUNC__;
  // handle continuous running of clock discipline function
  if (latest.clock_status == MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_ALWAYS_ON) // as good as it gets
    return 0;
  // fallback to free running logic
  return MsgClockStatus::getTimeUncertainty_FreeRun(latest, t);
}

//NOTE: Time uncertainty can be + / -, so retain the sign of drift in these three methods.
/*static*/ int32_t MsgClockStatus::getTimeUncertainty_FreeRun(const MsgClockStatus::Header& latest, const timestamp_t /*t*/)
{
  __DEV_CALLSTACK_FUNC__;
  // compute timing uncertainty
  const timestamp_t timeUncertaintyNs = static_cast<timestamp_t>((double)latest.acc_freerun / 3600.0 * latest.drift_est);
  return static_cast<int32_t>(pdb_utils::nanoseconds_to_microseconds(timeUncertaintyNs)); //nanoseconds -> microseconds
}
