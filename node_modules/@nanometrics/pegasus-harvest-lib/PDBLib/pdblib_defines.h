#ifndef pdblib_defines_h__
#define pdblib_defines_h__

#include "../shared_defines.h"
#include "../version.h"

#include <psflib_defines.h>

#if defined(DEV_PLATFORM_STM32)
  #include "platform/pdblib_stm32_defines.h"
#elif defined(DEV_PLATFORM_WIN32)
  #include "platform/pdblib_win32_defines.h"
#elif defined(DEV_PLATFORM_LINUX)
  #include "platform/pdblib_linux_defines.h"
#elif defined(DEV_PLATFORM_MACOS)
  #include "platform/pdblib_macos_defines.h"
#endif

// enforce compact byte packing for all subsequent unions and structures in this file
#pragma pack(push, 1)

//------------------Macro definitions
//! Maximum number of PSF volumes permissible for the PDB == 32
#define  VOLUMES_MAXIMUM_NUMBER 0x00000020
//! SEED frames count (63 is chosen)
#define PDB_SENSOR_INPUT_FRAMES_COUNT 63
//! Maximum channels count
#define PDB_MAXIMUM_CHANNELS_COUNT 4

//------------------Common typedefs
//! channel number typedef
typedef int8_t channel_t;
//! thread id typedef
typedef uint32_t threadid_t;
//! dilution of precision typedef (https://en.wikipedia.org/wiki/Dilution_of_precision_(navigation))
typedef float dop_t;
//! 1-byte-long boolean typedef
typedef enum : uint8_t { FALSE = 0, TRUE = 1 } boolean_t;

//---------------------PDB Message definitions
//! PDB Volume IDs enumeration
typedef enum : uint32_t
{
  VOLUME_NONE               = 0x00000000, /*!< PSF Volume Identifier not defined */
  VOLUME_SENSOR_TIME_SERIES = 0x00000001, /*!< Time series data captured from Pegasus digitizer sensor inputs */
  VOLUME_HEALTH_TIME_SERIES = 0x00000002, /*!< Time series data captured from Pegasus digitizer health inputs */
  VOLUME_CLOCK_STATUS       = 0x00000003, /*!< Pegasus digitizer clock subsystem status sampled aperiodically according to variable GNSS duty cycle schedule */
  VOLUME_HEALTH_DIGEST      = 0x00000004, /*!< Pegasus digitizer internal health metrics history in digest form */
  VOLUME_OPERATION_LOG      = 0x00000005, /*!< History of adjustments to Pegasus digitizer operation */
  VOLUME_HARVEST_LOG        = 0x00000006, /*!< History of Pegasus digitizer data harvest operations */
  VOLUME_FORENSIC_LOG       = 0x00000007, /*!< General purpose forensic log */
  
  VOLUME_HEALTH_STATE = 0x00000008,  /*!< (reserved for future use) */
  VOLUME_HEALTH_PDF   = 0x00000009,  /*!< (reserved for future use) */
  VOLUME_SEISMIC_PDF  = 0x0000000A,  /*!< (reserved for future use) */

  VOLUMES_COUNT, /*!< just the volumes count */
} PDB_eVolumeID;

//! PDB message ID
typedef enum : uint16_t
{
  MSG_NONE              = 0x0000, /*!< PSF Message Type not defined. For convenience, implementations also uses version == 0 */
  MSG_SENSOR_INPUT      = 0x0001, /*!< Sensor input time series data message */
  MSG_HEALTH_INPUT      = 0x0002, /*!< Health input time series data message */
  MSG_CLOCK_STATUS      = 0x0003, /*!< Clock subsystem status message */
  MSG_HEALTH_DIGEST     = 0x0004, /*!< Health digest message */
  MSG_DIGITIZER_START   = 0x0005, /*!< Digitizer start message */
  MSG_SMART_SENSOR      = 0x0006, /*!< Sensor control message */
  MSG_GNSS_CONTROL      = 0x0007, /*!< GNSS engine control message */
  MSG_BLE_CONTROL       = 0x0008, /*!< BLE engine control message */
  MSG_OPAQUE_DATA       = 0x0009, /*!< Opaque data */
  MSG_HARVEST_LOG       = 0x000A, /*!< Data harvest operation log message */
  MSG_FORENSIC_LOG      = 0x000B, /*!< Forensic log message */
  MSG_OBS_SYNC          = 0x000C, /*!< OBS Sync message */
  MSG_SOH_DATA          = 0x000D, /*!< New Live SOH message (SOH + clock status) */

  MSG_IDS_COUNT,           /*!< Just message IDs count */
} PDB_eMessageID_t;

//! PDB message types (packed messageID and versionID)
#define MAKE_PDB_MSG_TYPE(messageID, versionId) (((uint32_t)messageID << 16) | ((uint32_t)versionId))
typedef enum : uint32_t
{
  MSG_SENSOR_INPUT_V0    = MAKE_PDB_MSG_TYPE(MSG_SENSOR_INPUT, 0x0000), /*!< MSG_SENSOR_INPUT version 0 */
  MSG_HEALTH_INPUT_V0    = MAKE_PDB_MSG_TYPE(MSG_HEALTH_INPUT, 0x0000), /*!< MSG_HEALTH_INPUT version 0 */
  MSG_CLOCK_STATUS_V0    = MAKE_PDB_MSG_TYPE(MSG_CLOCK_STATUS, 0x0000), /*!< MSG_CLOCK_STATUS version 0*/
  MSG_HEALTH_DIGEST_V0   = MAKE_PDB_MSG_TYPE(MSG_HEALTH_DIGEST, 0x0000), /*!< MSG_HEALTH_DIGEST version 0*/
  MSG_DIGITIZER_START_V0 = MAKE_PDB_MSG_TYPE(MSG_DIGITIZER_START, 0x0000), /*!< MSG_DIGITIZER_START version 0*/
  MSG_SMART_SENSOR_V0    = MAKE_PDB_MSG_TYPE(MSG_SMART_SENSOR, 0x0000), /*!< MSG_SENSOR_CONTROL version 0*/
  MSG_GNSS_CONTROL_V0    = MAKE_PDB_MSG_TYPE(MSG_GNSS_CONTROL, 0x0000), /*!< MSG_GNSS_CONTROL version 0*/
  MSG_BLE_CONTROL_V0     = MAKE_PDB_MSG_TYPE(MSG_BLE_CONTROL, 0x0000), /*!< MSG_BLE_CONTROL version 0*/
  MSG_OPAQUE_DATA_V0     = MAKE_PDB_MSG_TYPE(MSG_OPAQUE_DATA, 0x0000), /*!< MSG_OPAQUE_DATA version 0*/
  MSG_HARVEST_LOG_V0     = MAKE_PDB_MSG_TYPE(MSG_HARVEST_LOG, 0x0000), /*!< MSG_HARVEST_LOG version 0*/
  MSG_FORENSIC_LOG_V0    = MAKE_PDB_MSG_TYPE(MSG_FORENSIC_LOG, 0x0000), /*!< MSG_FORENSIC_LOG version 0*/
  MSG_OBS_SYNC_V0        = MAKE_PDB_MSG_TYPE(MSG_OBS_SYNC, 0x0000), /*!< MSG_OBS_SYNC version 0*/
  MSG_SOH_DATA_V0        = MAKE_PDB_MSG_TYPE(MSG_SOH_DATA, 0x0000), /*!< MSG_SOH_DATA version 0*/

  MSG_TYPE_ID_MASK  = MAKE_PDB_MSG_TYPE(0xFFFF, 0x0000), /*!< Just the bit-mask to fetch messageID from messageType */
  MSG_VERSION_ID_MASK  = MAKE_PDB_MSG_TYPE(0x0000, 0xFFFF), /*!< Just the bit-mask to extract versionId from messageType */
} PDB_eMessageType_t;

//! Media type
typedef enum : uint16_t
{
  MEDIA_UNCOMPRESSED = 0, /*!< Uncompressed data */
  MEDIA_STEIM1 = 1,    /*!< Steim1 compression */
  MEDIA_STEIM2 = 2,    /*!< Steim2 compression */

  MEDIA_TYPES_COUNT,    /*!< supported media types count constant */
} PDB_eMediaType_t;

//! Sample Rate union
typedef union
{
  //! Sample rate struct representation (factor, multiplier)
  struct
  {
    //! base sample rate
    int8_t factor;
    //! sample rate multiplier (>0 - multiplier; <0 - divisor (abs value taken), 0 = not used
    int8_t multiplier;
  } details;
  //! Sample rate 16-bits packed representation
  uint16_t value;
} PDB_sSampleRate_t;

//! Steim Frame typedef. 64-byte SEED data frame (refer to SEED manual)
typedef uint32_t SteimFrame_t[16];

//PDB Health input types enumeration
typedef enum : uint8_t
{
  HEALTH_SYSTEM_VOLTAGE     = 0, /*!< system voltage, real world unit = Volt. */
  HEALTH_SYSTEM_CURRENT     = 1, /*!< system current, real world unit = Amp. */
  HEALTH_SYSTEM_TEMPERATURE = 2, /*!< system temperature, real world unit = degrees Celsius. */
  HEALTH_SYSTEM_PRESSURE    = 3, /*!< system internal pressure, Pascal. */
  HEALTH_SENSOR_CURRENT     = 4, /*!< sensor current, real world unit = Amp. */
  HEALTH_SENSOR_1_SOH       = 5, /*!< sensor 1 SOH signal, real world unit = Volt. */
  HEALTH_SENSOR_2_SOH       = 6, /*!< sensor 2 SOH signal, real world unit = Volt. */
  HEALTH_SENSOR_3_SOH       = 7, /*!< sensor 3 SOH signal, real world unit = Volt. */
  HEALTH_SENSOR_4_SOH       = 8, /*!< sensor 4 SOH signal, real world unit = Volt. */

  HEALTH_INPUTS_COUNT  /*!< Health Input types count constant */
} PDB_eHealthInput_t;

//! Health sample typedef
typedef float PDB_HealthSample_t[HEALTH_INPUTS_COUNT]; //Array of raw input values for one sample of all health inputs. Array index maps to physical health input using HealthInput enumeration.


//! The HarvestBlock structure definition
typedef struct
{
  //! Identifier of PSF volume for which lower and upper apply
  PDB_eVolumeID volume_id;
  //! Lower bound sequence number of a range of contiguous PSF data elements from the PSF volume specified by volume
  uint32_t lower;
  //! Upper bound sequence number of a range of contiguous PSF data elements from the PSF volume specified by volume
  uint32_t upper;
} PDB_sHarvestBlock_t;

//! Volume Ref typedef
typedef struct
{
  uint32_t volume_id; /*!< Identifier of PSF volume for which sequence applies */
  uint32_t sequence; /*!< Sequence number reference into volume, indicating the data element at or immediately after an associated event */
} PDB_sVolumeRef_t;

//! Volume reference index: contains a sequence number reference into all known volumes (excluding this volume) synchronised to this event
typedef struct
{
  //! Number of elements in m_refs member
  uint32_t   n_refs;
  //! Table of volume references, where n_refs elements are defined
  PDB_sVolumeRef_t refs[VOLUMES_MAXIMUM_NUMBER];
} PDB_sVolumeRefIndex_t;

//! VcxoModel enumeration
typedef enum : uint16_t
{
  VCXO_MODEL_UNKNOWN     = 0x0000, /*!< VCXO model is unknown */
  VCXO_MODEL_ASVTX09     = 0x0001, /*!< Abracon ASVTX-09 VCTCXO, 19.2 MHz nominal */
  VCXO_MODEL_KT2520K     = 0x0002, /*!< Kyocera KT2520K VCTCXO, 19.2 MHz nominal */
  // NOTE:
  // The Pegasus Digitizer removed support for the Kyocera KT2520K VCTCXO in FW version 2.3.5.
  VCXO_MODEL_CTS52010083 = 0x0003, /*!< CTS Corporation 52010083 Clipped Sine Wave TCXO, 19.2 MHz nominal */
} PDB_eVcxoModel_t;

//! GNSS satellite constellations enumeration
typedef enum : uint8_t
{
  GPS_USA        = 1 << 0, /*!< GPS, United States */
  GLONASS_RUSSIA = 1 << 1, /*!< GLONASS, Russia */
  GALILEO_EU     = 1 << 2, /*!< Galileo, European Union */
  BEIDOU_CHINA   = 1 << 3, /*!< BeiDou, China */
  QZSS_JAPAN     = 1 << 4, /*!< QZSS, Japan */
  NAVIC_INDIA    = 1 << 5, /*!< FUTURE USE - NAVIC, India */
} PDB_eConstellations_t;

#pragma pack(pop) // #pragma pack(push, 1)

#endif //pdblib_defines_h__
