#include "pdb_utils.h"

#include <cmath>

namespace pdb_utils
{
  //! Pegasus Data Buffer: default PSF library format configuration
  // Ref. https://docs.google.com/spreadsheets/d/1lVrwxymfjoZaA2F8F-PIAkqP7udd5JNGkLemSjvJV0A/edit#gid=1676536313
  const sPSFFormatConfig_t PSF_FORMAT_CONFIGURATION_DEFAULT =
  {
    64u, // FAT32 size in MiB
    "PEGASUS", // FAT32 label
    {
      // NOTE: Proportional volume sizes (percentages) based on calculations in
      // https://docs.google.com/spreadsheets/d/1bVmBw6rZP8Q2rXnrhMJ7Q7UFBJC72YKSOL-_cmzTD_k/edit?usp=sharing
      sPSFVolumeConfig_t{"SensorTimeSeries", PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES, 96.819018},
      sPSFVolumeConfig_t{"HealthTimeSeries", PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES,  1.902090},
      // sPSFVolumeConfig_t{"ClockStatus",      PDB_eVolumeID::VOLUME_CLOCK_STATUS,        0.042942}, (not being used anymore; merged with HealthTimeSeries)
      sPSFVolumeConfig_t{"HealthDigest",     PDB_eVolumeID::VOLUME_HEALTH_DIGEST,       0.000704},
      sPSFVolumeConfig_t{"OperationLog",     PDB_eVolumeID::VOLUME_OPERATION_LOG,       0.008366},
      sPSFVolumeConfig_t{"HarvestLog",       PDB_eVolumeID::VOLUME_HARVEST_LOG,         0.001761},
      sPSFVolumeConfig_t{"ForensicLog",      PDB_eVolumeID::VOLUME_FORENSIC_LOG,        1.268060},
    }
  };

  double decode_sample_rate(const PDB_sSampleRate_t& sampleRate)
  {
    __DEV_CALLSTACK_FUNC__;
    return decode_sample_rate(sampleRate.details.factor, sampleRate.details.multiplier);
  }

  double decode_sample_rate(int8_t factor, int8_t multiplier)
  {
    __DEV_CALLSTACK_FUNC__;
    const double _factor = (factor >= 0) ? (double)factor : 1.0 / (double)(-factor); //>=0 -> samples/second, <0 -> seconds/sample
    const double _multiplier = (multiplier >= 0) ? (double)multiplier : 1.0 / (double)(-multiplier); //>=0 -> multiplier, <0 -> divisor
    return _factor * _multiplier;
  }

  double decode_sample_rate(uint16_t encoded_value)
  {
    __DEV_CALLSTACK_FUNC__;
    const int8_t factor = (int8_t)(encoded_value & 0x00ff);
    const int8_t multiplier = (encoded_value & 0xff00) >> 8;
    return pdb_utils::decode_sample_rate(factor, multiplier);
  }

  uint16_t encode_sample_rate(uint8_t factor, uint8_t multiplier)
  {
    __DEV_CALLSTACK_FUNC__;
    const uint16_t factor1 = (uint16_t)factor;
    const uint16_t multiplier1 = (uint16_t)multiplier << 8;
    uint16_t ret = factor1 | multiplier1;
    return ret;
  }

  bool is_big_endian()
  {
    __DEV_CALLSTACK_FUNC__;
    volatile unsigned char bytes[2] = { 0x00, 0x01 };
    volatile uint16_t val = *(uint16_t*)bytes;
    return (val == 0x0001);
  }

  bool is_little_endian()
  {
    __DEV_CALLSTACK_FUNC__;
    volatile unsigned char bytes[2] = { 0x00, 0x01 };
    volatile uint16_t val = *(uint16_t*)bytes;
    return (val == 0x0100);
  }

  int32_t dop_to_fixed_point(const dop_t value)
  {
    __DEV_CALLSTACK_FUNC__;
    return static_cast<int32_t>(std::round(value * 1000.f));
  }

  timediff_t get_packet_duration_nanoseconds(const uint32_t nSamples, const PDB_sSampleRate_t& sampleRate)
  {
    __DEV_CALLSTACK_FUNC__;
    const double _sampleRate = pdb_utils::decode_sample_rate(sampleRate);
    const timediff_t packetDurationNs = pdb_utils::seconds_to_nanoseconds((double)nSamples / _sampleRate);
    return packetDurationNs;
  }
}
