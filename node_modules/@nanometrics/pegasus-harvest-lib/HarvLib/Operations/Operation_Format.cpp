#include "Operation_Format.h"

#include "../external/rapidjson-1.1.0/rapidjson.h"
#include "../external/rapidjson-1.1.0/document.h"

#include <Library/PSFLibrary.h>
#include <Utils/fat32_utils.h>
#include <Utils/pdb_utils.h>

#include <IOContext/io_contexts.h>
#include <Meters/Timers/TimerNs.h>
#include <PlatformUtils/PlatformUtils.h>

#include <cstring>

Operation_Format::Operation_Format(const std::string& libPath, const bool bCreatePSF,
  const std::string& configFile, const std::shared_ptr<IDelegate>& delegate)
: IOperation("format")
, m_libPath(libPath)
, m_bCreatePSF(bCreatePSF)
, m_configFile(configFile)
, m_configuration(pdb_utils::PSF_FORMAT_CONFIGURATION_DEFAULT)
, m_delegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
}

bool Operation_Format::_executeImpl(const std::shared_ptr<IHasher>& hasher, 
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_delegate->onStageChanged(this, IDelegate::eStage::STAGE_PARSING_CONFIG);
  //tss_harv::check if config file isn't specified -> use default schema
  if (m_configFile.empty())
  {
    logger->info(m_name.c_str(), "Using default volumes schema...");
  }
  else //try to use schema from config
  {
    if (this->_parseJSON(m_configFile, m_configuration, logger))
    {
      logger->info(m_name.c_str(), "Using volumes schema from '%s'...", m_configFile.c_str());
    }
    else
    {
      logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
        "Failed to parse '%s'. Default schema will be used!", m_configFile.c_str());
    }
  }
  
  //tss_harv::fix device path
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  //tss_Harv::get logical drive and physical drive paths
  const std::string physicalPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(physicalPath);

#if defined(DEV_PLATFORM_WIN32)
  //tss_harv::create logical drive context to lock and dismount current drive to allow writing to underlying physical drive
  std::shared_ptr<FileIOContext_Windows> logicalContext = std::make_shared<FileIOContext_Windows>(libPath,
    GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING,
    logger);
  //tss_harv::lock and dismount drive (required to destroy FS on it)
  logicalContext->lock();
  logicalContext->dismount();
#endif

#if defined(DEV_PLATFORM_WIN32)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_Windows>(physicalPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING, logger);
#elif defined(DEV_PLATFORM_LINUX)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(physicalPath, O_RDWR | O_LARGEFILE, logger);
#elif defined(DEV_PLATFORM_MACOS)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(physicalPath, O_RDWR, logger);
#endif
  //create FAT32 partition on raw device
  {
    m_delegate->onStageChanged(this, IDelegate::eStage::STAGE_CREATING_FAT32);
    //tss_harv::create 32 partition
    if (!fat32_utils::write_FAT32_Partition(deviceContext, m_configuration.fatVolumeLabel, m_configuration.fatSizeMiB, logger))
    {
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
        "Failed to create FAT32 partition on %s",
        libPath.c_str());
      m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
      return false;
    }
    logger->info(__THIS_FUNC__, "FAT32 partition created!");
  }

  //tss_harv::create PSF structure if requested
  if (m_bCreatePSF)
  {
    m_delegate->onStageChanged(this, IDelegate::eStage::STAGE_CREATING_PSF);
    if (!this->_createPSF(physicalPath, hasher, logger))
    {
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
        "Failed to create PSF library on '%s'",
        libPath.c_str());
      m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
      return false;
    }
    logger->info(__THIS_FUNC__, "PSF library created");
  }

  m_delegate->onStageChanged(this, IDelegate::eStage::STAGE_COMPLETED);
  m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_COMPLETED);
  return true;
}

bool Operation_Format::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false; //operation cannot be stopped
}

bool Operation_Format::_createPSF(const std::string& physicalPath,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  std::unique_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(physicalPath, hasher, logger, false));
  if (pLibrary != nullptr)
  {
    //tss_harv::do format
    logger->info(__THIS_FUNC__, "Formatting library with %u volumes", (uint32_t)m_configuration.volumes.size());
    //tss_harv::format disk to PSF structure
    if (!pLibrary->format(m_configuration.volumes, std::make_shared<TimerNs>()))
    {
      logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
        "Failed to create PSF v%u", PSF_VERSION);
      return false;
    }
  }
  else
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Failed to open '%s' for creating PSF library", physicalPath.c_str());
    return false;
  }

  return true;
}

bool Operation_Format::_parseJSON(const std::string& jsonPath, sPSFFormatConfig_t& config, const std::shared_ptr<ILogger>& logger) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_WIN32)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_Windows>(jsonPath, GENERIC_READ, 0, OPEN_EXISTING, logger);
#else
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(jsonPath, O_RDONLY, logger);
#endif
  //tss_harv::check if file was opened correctly
  const uint64_t fileSize = fileContext->getSize();
  if (fileSize <= 0)
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is empty or the path is invalid", jsonPath.c_str());
    return false;
  }

  //tss_harv::read data into buffer
  char* buffer = reinterpret_cast<char*>(::malloc(fileSize));
  const size_t readBytes = fileContext->readBlock(0, fileSize, buffer);
  if (readBytes != fileSize)
  {
    ::free(buffer);
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Failed to read data from '%s'", jsonPath.c_str());
    return false;
  }
  
  //tss_harv::parse read data
  rapidjson::Document doc;
  doc.Parse(buffer, readBytes);
  ::free(buffer);

  //tss_harv::validate JSON
  if (doc.HasParseError())
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Invalid '%s' - parsing failed", jsonPath.c_str());
    return false;
  }
  if (!doc.HasMember("volumes"))
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Invalid '%s' - has no 'volumes' array entity", jsonPath.c_str());
    return false;
  }
  rapidjson::Value& volumesJSON = doc["volumes"];
  if (!volumesJSON.IsArray() || volumesJSON.Size() <= 0)
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Invalid '%s' - 'volumes' should be not empty array", jsonPath.c_str());
    return false;
  }
  if (!doc.HasMember("fat_volume_label") || ! doc["fat_volume_label"].IsString())
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Invalid '%s' - has no 'fat_volume_label' string entity", jsonPath.c_str());
    return false;
  }
  if (!doc.HasMember("fat_size_mib") || !doc["fat_size_mib"].IsUint())
  {
    logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "Invalid '%s' - has no 'fat_size_mib' (FAT32 size in MiB) uint32_t entity", jsonPath.c_str());
    return false;
  }

  //tss_harv::parse FAT32 volume's label
  const std::string fatVolumeLabel = doc["fat_volume_label"].GetString();
  if (fatVolumeLabel.empty())
  {
    logger->warning(m_name.c_str(), "'fat_volume_label' set empty in '%s', Default will be used", jsonPath.c_str());
  }
  else
  {
    config.fatVolumeLabel = fatVolumeLabel;
  }
  //tss_harv::parse FAT32 partition size
  config.fatSizeMiB = doc["fat_size_mib"].GetUint();

  //tss_harv::parse volumes schema
  config.volumes.clear();
  config.volumes.reserve(volumesJSON.Size());
  for (rapidjson::Value::ConstValueIterator it = volumesJSON.Begin(); it != volumesJSON.End(); ++it)
  {
    const rapidjson::Value& volumeEntity = (*it);
    //tss_harv::check required fields
    if (!volumeEntity.HasMember("id") || !volumeEntity["id"].IsInt())
    {
      logger->warning(m_name.c_str(), "Volume entity should have 'id' specified (integer) - will be skipped!");
      continue;
    }
    if (!volumeEntity.HasMember("percent") || !volumeEntity["percent"].IsDouble())
    {
      logger->warning(m_name.c_str(), "Volume entity should have 'percent' specified (double) - will be skipped");
      continue;
    }

    sPSFVolumeConfig_t volumeConfig; ::memset(&volumeConfig, 0, sizeof(sPSFVolumeConfig_t));
    //tss_harv::set parsed values
    volumeConfig.sizePercent = volumeEntity["percent"].GetDouble();
    volumeConfig.id = volumeEntity["id"].GetUint();
    if (volumeEntity.HasMember("label"))
    {
      ::strncpy(volumeConfig.label, volumeEntity["label"].GetString(), sizeof(VolumeLabel_t));
    }
    //tss_harv::push volume to the output
    config.volumes.emplace_back(volumeConfig);
  }

  //tss_Harv::notify warning If no valid volumes parsed (no volumes might be an intention for some reasons -> warning)
  if (config.volumes.empty())
  {
    logger->warning(m_name.c_str(), "'%s' has no valid volumes specified!! No volumes will be created!!!", jsonPath.c_str());
  }

  return true;
}
