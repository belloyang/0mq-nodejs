#include "Operation_EraseVolume.h"

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>

#include <algorithm>

Operation_EraseVolume::Operation_EraseVolume(const std::string& libPath, const uint32_t volumeId,
  const std::shared_ptr<IDelegate>& delegate)
: IOperation("erase-volume")
, m_libPath(libPath)
, m_volumeId(volumeId)
, m_delegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
}

bool Operation_EraseVolume::_executeImpl(const std::shared_ptr<IHasher>& hasher,
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  std::unique_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, hasher, logger, true));
  //tss_harv::restoring library
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is not a PSF library or doesn't exist. Use 'format' command to create it or 'list' to see all PSF devices available",
      libPath.c_str());
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  //tss_harv::fetch volume
  std::unique_ptr<PSFVolume> const pVolume(pLibrary->findVolumeByID(m_volumeId));
  if (pVolume == nullptr)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND, 
      "Failed to find id=%u volume in PSF library", (uint32_t)m_volumeId);
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  const bool bSuccess = pVolume->erase();
  //tss_harvlib::notify delegate that operation is completed
  m_delegate->onCompleted(this, bSuccess ? eOperationStatus::OP_STATUS_COMPLETED : eOperationStatus::OP_STATUS_FAILED);
  return true;
}

bool Operation_EraseVolume::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false; //operation cannot be stopped
}
