#include "Operation_ReadVolume.h"

#include <PlatformUtils/PlatformUtils.h>

Operation_ReadVolume::Operation_ReadVolume(const std::string& libPath,
  const uint32_t volumeId,
  const std::shared_ptr<IProcessorDelegate>& processorDelegate)
: IOperation("read-volume")
, m_libPath(libPath)
, m_volumeId(volumeId)
, m_processorDelegate(processorDelegate)
, m_headFilter(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

bool Operation_ReadVolume::_executeImpl(const std::shared_ptr<IHasher>& hasher,
  const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  // prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  // create PSF library
  const std::shared_ptr<PSFLibrary> pLibrary(PSFLibrary::create(libPath, hasher, logger, true));
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is not a PSF library or doesn't exist. Use 'format' command to create it or 'list' to see all PSF devices available",
      libPath.c_str());
    return false;
  }

  // build chain to process all the data on specific volume
  GraphBuilder graphBuilder(logger);
  m_headFilter = graphBuilder.buildDataProcessingChain(this, pLibrary, m_volumeId, 1u, m_processorDelegate);
  if (m_headFilter != nullptr)
  {
    m_headFilter->run(nullptr);
    return true;
  }

  return false;
}

bool Operation_ReadVolume::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_headFilter != nullptr)
  {
    m_headFilter->requestStop();
  }
  return true;
}
