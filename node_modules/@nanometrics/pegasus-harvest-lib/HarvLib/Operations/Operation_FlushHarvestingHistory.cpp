#include "Operation_FlushHarvestingHistory.h"

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>
#include <Library/PSFStream.h>

Operation_FlushHarvestingHistory::Operation_FlushHarvestingHistory(const std::string& libPath,
  const std::vector<MsgHarvestLog::Header>& history,
  const std::shared_ptr<IDelegate>& delegate)
: IOperation("flush-harvesting-history")
, m_libPath(libPath)
, m_history(history)
, m_delegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_delegate != nullptr && "delegate cannot be nullptr here!");
}

bool Operation_FlushHarvestingHistory::_executeImpl(const std::shared_ptr<IHasher>& hasher,
  const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harvlib::create PSF library
  std::shared_ptr<PSFLibrary> pLibrary(PSFLibrary::create(libPath, hasher, logger, true));
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is not a PSF library or doesn't exist. Use 'format' command to create it or 'list' to see all PSF devices available",
      libPath.c_str());
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }
  //tss_harv::fetch HarvestLog volume
  std::unique_ptr<PSFVolume> pHarvestLogVolume(pLibrary->findVolumeByID(PDB_eVolumeID::VOLUME_HARVEST_LOG));
  if (pHarvestLogVolume == nullptr)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND,
      "Failed to find VOLUME_HARVEST_LOG(id=%u) volume in library", (uint32_t)PDB_eVolumeID::VOLUME_HARVEST_LOG);
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  PSFStream stream(pHarvestLogVolume.get(), logger);
  MsgHarvestLog harvestLog;
  for (const auto& header: m_history)
  {
    if (header.length > 0 && harvestLog.init(header))
    {
      void* pBuffer = nullptr;
      size_t bufferSize = 0;
      harvestLog.lockBuffer(&pBuffer, &bufferSize);
      const size_t bytesWritten = stream.write(harvestLog.getType(), pBuffer, bufferSize);
      if (bytesWritten > 0)
      {
        m_delegate->onHistoryWritten(this, header);
      }
      else
      {
        logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_FINALIZE_FAILED,
            "Failed to write data element");
      }
    }
  }
  // persist data to PSF volume
  stream.flush();
  m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_COMPLETED);
  return true;
}

bool Operation_FlushHarvestingHistory::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false;
}
