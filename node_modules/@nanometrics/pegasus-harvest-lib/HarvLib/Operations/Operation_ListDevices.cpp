#include "Operation_ListDevices.h"

#include <Library/PSFLibrary.h>
#if defined(DEV_PLATFORM_LINUX)
  #include <PSFDetector/linux/PSFDetector_Linux.h>
#elif defined(DEV_PLATFORM_MACOS)
  #include <PSFDetector/macOS/PSFDetector_MacOS.h>
#elif defined(DEV_PLATFORM_WIN32)
  #include <PSFDetector/win32/PSFDetector_Windows.h>
#endif

#include <PlatformUtils/PlatformUtils.h>

Operation_ListDevices::Operation_ListDevices(const std::shared_ptr<IDelegate>& delegate)
: IOperation("list-devices")
, m_delegate(delegate)
{
  __ASSERT__(m_delegate != nullptr && "delegate cannot be nullptr here!");
  __DEV_CALLSTACK_FUNC__;
}

bool Operation_ListDevices::_executeImpl(const std::shared_ptr<IHasher>& hasher, 
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::create detector instance
#if defined(DEV_PLATFORM_LINUX)
  std::unique_ptr<IPSFDetector> detector(new PSFDetector_Linux(logger));
#elif defined(DEV_PLATFORM_MACOS)
  std::unique_ptr<IPSFDetector> detector(new PSFDetector_MacOS(logger));
#elif defined(DEV_PLATFORM_WIN32)
  std::unique_ptr<IPSFDetector> detector(new PSFDetector_Windows(logger));
#endif

  //tss_harv::list devices using detector
  const std::vector<sPSFDeviceInfo_t> blockDevices = detector->listDevices();
  for (auto blockIt = blockDevices.begin(); blockIt != blockDevices.end(); ++blockIt)
  {
    //tss_harv::unmount all associated drives
    const std::string devicePath(blockIt->devicePath);
    PlatformUtils::getInstance()->unmountAll(devicePath);
    //tss_harv::fetch physical path from logical
    const std::string& physicalPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(devicePath);
    //tss_harv::create library
    std::unique_ptr<PSFLibrary> pLib(PSFLibrary::create(physicalPath, hasher, logger, true));
    //tss_harv::try to restore PSF structure and notify delegate
    if (pLib != nullptr && pLib->restore())
    {
        m_delegate->onDeviceFound(this, *blockIt);
    }
  }

  //tss_harvlib::notify delegate about operation completed
  m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_COMPLETED);

  return true;
}

bool Operation_ListDevices::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false; //operation cannot be stopped
}
