#include "Operation_GetVolumeInfo.h"

#include "../TimeRangeFetchers/TimeRangeFetcher_SensorInput.h"
#include "../TimeRangeFetchers/TimeRangeFetcher_ForensicLog.h"
#include "../TimeRangeFetchers/TimeRangeFetcher_SohData.h"
#include "../TimeRangeFetchers/TimeRangeFetcher_ClockStatus.h"

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>
#include <Library/PSFStream.h>

#include <algorithm>
#include <cinttypes>

Operation_GetVolumeInfo::Operation_GetVolumeInfo(const std::string& libPath, const uint32_t volumeId, const uint32_t nSectionsToLoad,
  const std::shared_ptr<IDelegate>& delegate)
: IOperation("get-volume-info")
, m_libPath(libPath)
, m_volumeId(volumeId)
, m_nSectionsToLoad(nSectionsToLoad)
, m_delegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
}

bool Operation_GetVolumeInfo::_executeImpl(const std::shared_ptr<IHasher>& hasher, 
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  std::unique_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, hasher, logger, true));
  //tss_harv::restoring library
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is not a PSF library or doesn't exist. Use 'format' command to create it or 'list' to see all PSF devices available",
      libPath.c_str());
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  //tss_harv::fetch volume
  std::unique_ptr<PSFVolume> const pVolume(pLibrary->findVolumeByID(m_volumeId));
  if (pVolume == nullptr)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND, 
      "Failed to find id=%u volume in PSF library", (uint32_t)m_volumeId);
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  //tss_harv::fetch header and push this information to output
  const sPSFVolumeHeader_t* const pHeader = pVolume->getHeader();
  if (pHeader != nullptr)
  {
    sVolumeInfo info;
    ::memset(&info, 0, sizeof(sVolumeInfo));
    ::memcpy(info.label, pHeader->label, sizeof(VolumeLabel_t));
    info.sizeInChapters = pHeader->sizeInChapters;
    info.uniqueId = pHeader->uniqueId;
    info.bTimeValid = false;

    //tss_harvlib::fetch timestamps if applicable
    std::shared_ptr<ITimeRangeFetcher> fetcher = nullptr;
    if (pHeader->uniqueId == PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES)
      fetcher = std::make_shared<TimeRangeFetcher_SensorInput>(logger);
    else if (pHeader->uniqueId == PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES)
      fetcher = std::make_shared<TimeRangeFetcher_SohData>(logger);
    else if (pHeader->uniqueId == PDB_eVolumeID::VOLUME_CLOCK_STATUS)
      fetcher = std::make_shared<TimeRangeFetcher_ClockStatus>(logger);
    else if (pHeader->uniqueId == PDB_eVolumeID::VOLUME_FORENSIC_LOG)
      fetcher = std::make_shared<TimeRangeFetcher_ForensicLog>(logger);

    if (fetcher != nullptr)
    {
      PSFStream stream(pVolume.get(), logger);
      PSFDataElement firstElement(hasher, logger);
      PSFDataElement lastElement(hasher, logger);
      //tss_harvlib::read first element
      if (stream.readNext(firstElement) > 0)
        info.bTimeValid = fetcher->getLowerTime(firstElement, &info.lowerTime);

      //tss_harvlib::read last element
      stream.rseek_end();
      if (stream.readPrev(lastElement) > 0)
        info.bTimeValid = fetcher->getUpperTime(lastElement, &info.upperTime);
    }
    //tss_harvlib::notify delegate that info is loaded
    m_delegate->onInfoLoaded(this, info);

    //tss_harvlib::if sections info should be loaded -> load it
    if (m_nSectionsToLoad > 0)
    {
      PSFSection section(pVolume.get());
      //tss_harvlib::iterate through all the data sections (0, to n-2 - as one section is reserved for volume's header)
      const uint32_t nSectionsToLoad = std::min<uint32_t>(m_nSectionsToLoad, pVolume->getHeader()->sizeInChapters - 1);
      for (uint32_t sectionIdx = 0; sectionIdx < nSectionsToLoad; sectionIdx++)
      {
        const bool bLoaded = pVolume->loadSection(sectionIdx, section);
        if (bLoaded)
          m_delegate->onSectionLoaded(this, sectionIdx, &section);
        else
          m_delegate->onSectionLoaded(this, sectionIdx, nullptr);
      }
    }

    //tss_harvlib::notify delegate that operation is completed
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_COMPLETED);
    return true;
  }

  m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
  logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
    "Failed to retrieve volume's header (id=%" PRIu32 ")", m_volumeId);
  return false;
}

bool Operation_GetVolumeInfo::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false; //operation cannot be stopped
}
