#include "Operation_GetDigitizerInfo.h"

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>
#include <Library/PSFStream.h>

#include <PlatformUtils/PlatformUtils.h>

Operation_GetDigitizerInfo::Operation_GetDigitizerInfo(const std::string& libPath, const std::shared_ptr<IDelegate>& delegate)
: IOperation("get-digitizer-info")
, m_libPath(libPath)
, m_delegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_delegate != nullptr && "delegate cannot be nullptr here!");
}

bool Operation_GetDigitizerInfo::_executeImpl(const std::shared_ptr<IHasher>& hasher,
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::prepare device for reading info
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harv::created library (no Async reader on Windows due to backward reading)
  std::unique_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, hasher, logger, false));
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
      "'%s' is a not PSF library or doesn't exist. Use 'format' command to create it or 'list' to see all PSF devices available",
      libPath.c_str());
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  // get header and list volumes
  const sPSFLibraryHeader_t* const pLibHeader = pLibrary->getHeader();
  std::vector<sVolumeInfo> volumes; pLibrary->listVolumes(volumes);
  m_delegate->onPSFInfoLoaded(this, *pLibHeader, volumes);

  //tss_harv::fetch OperationLog volume
  std::unique_ptr<PSFVolume> const pOpLogVolume(pLibrary->findVolumeByID(PDB_eVolumeID::VOLUME_OPERATION_LOG));
  if (pOpLogVolume == nullptr)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND,
      "Failed to find VOLUME_OPERATION_LOG(id=%u) volume in library", (uint32_t)PDB_eVolumeID::VOLUME_OPERATION_LOG);
    m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
    return false;
  }

  //tss_harv::open volume stream
  PSFStream stream(pOpLogVolume.get(), logger);
  std::unique_ptr<MsgDigitizerStart> const pStart(new MsgDigitizerStart());
  PSFDataElement dataElement(hasher, logger);
  //tss_harv::goto volume's end to start backward reading
  stream.rseek_end();
  while (!stream.is_bof())
  {
    //tss_harv::read data element (backward)
    const size_t readBytes = stream.readPrev(dataElement);
    if (readBytes > 0)
    {
      //tss_harv::check if data element read is MsgDigitizerStart object
      if (dataElement.isInstanceOf(PDB_eMessageType_t::MSG_DIGITIZER_START_V0))
      {
        //tsss_Harv::restore PDB object from PSF data
        if (pStart->restore(&dataElement))
        {
          m_delegate->onInfoLoaded(this, pStart.get());
          //tss_harvlib::notify delegate about completion
          m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_COMPLETED);
          return true;
        }
        else
        {
          logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED, 
            "Failed to restore data for 'MSG_DIGITIZER_START' object");
        }
      }
    }
  }

  m_delegate->onCompleted(this, eOperationStatus::OP_STATUS_FAILED);
  return false;
}

bool Operation_GetDigitizerInfo::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  return false; //operation cannot be stopped
}
