#include "JSONSerializer.h"

#include <DataTypes/ForensicLog/MsgForensicLog.h>
#include <DataTypes/DigitizerOperationLog/MsgDigitizerStart.h>
#include <DataTypes/DigitizerOperationLog/MsgObsSync.h>
#include <DataTypes/DigitizerOperationLog/MsgOpaqueData.h>
#include <DataTypes/DigitizerOperationLog/MsgBleControl.h>
#include <DataTypes/DigitizerOperationLog/MsgGnssControl.h>
#include <DataTypes/HarvestLog/MsgHarvestLog.h>

JSONSerializer::JSONSerializer(const std::shared_ptr<IJSONTransformer>& transformer)
: m_transformer(transformer)
, m_handlers({
    { PDB_eMessageType_t::MSG_FORENSIC_LOG_V0,    Handler(&JSONSerializer::MsgForensicLogV0_Handler, this) },
    { PDB_eMessageType_t::MSG_DIGITIZER_START_V0, Handler(&JSONSerializer::MsgDigitizerStartV0_Handler, this) },
    { PDB_eMessageType_t::MSG_OBS_SYNC_V0,        Handler(&JSONSerializer::MsgObsSyncV0_Handler, this) },
    { PDB_eMessageType_t::MSG_HARVEST_LOG_V0,     Handler(&JSONSerializer::MsgHarvestLogV0_Handler, this) },
    { PDB_eMessageType_t::MSG_OPAQUE_DATA_V0,     Handler(&JSONSerializer::MsgOpaqueDataV0_Handler, this) },
    { PDB_eMessageType_t::MSG_BLE_CONTROL_V0,     Handler(&JSONSerializer::MsgBleControlV0_Handler, this) },
    { PDB_eMessageType_t::MSG_GNSS_CONTROL_V0,    Handler(&JSONSerializer::MsgGnssControlV0_Handler, this) }
  })
{
  __DEV_CALLSTACK_FUNC__;
}

rapidjson::Value JSONSerializer::serialize(const PSFDataElement* pDataElement)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::Value ret(rapidjson::kObjectType);
  const sPSFDataElementHeader_t* const pHeader = pDataElement->getHeader();
  // data commences right after the header
  const uint32_t messageType = static_cast<uint32_t>(pHeader->messageType);
  // lock/get data
  const void* data = nullptr; pDataElement->getData(&data);
  ret.AddMember("pdb_message_type", messageType, m_allocator);
  ret.AddMember("sequence_number", pHeader->sequenceNumber, m_allocator);
  // serialize the rest
  rapidjson::Value message(rapidjson::kObjectType);
  const auto& foundIt = m_handlers.find(messageType);
  if (foundIt != m_handlers.end())
  {
    foundIt->second(data, message);
  }
  else
  {
    // serialize raw JSON data
    const uint32_t nBytes = PSF_PAGES_to_BYTES(pHeader->sizeInPages);
    message.AddMember("data", json_utils::str_ref(reinterpret_cast<const char*>(data), nBytes), m_allocator);
  }
  ret.AddMember("message", message, m_allocator);
  return ret;
}

rapidjson::Value JSONSerializer::serialize(const IPDBMsgObject* object, const sequence_number_t sequenceNumber)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::Value ret(rapidjson::kObjectType);
  const uint32_t messageType = object->getType();
  ret.AddMember("pdb_message_type", messageType, m_allocator);
  ret.AddMember("sequence_number", sequenceNumber, m_allocator);
  // lock buffer
  void* pData = nullptr; size_t dataSize = 0;
  object->lockBuffer(&pData, &dataSize);
  // serialize the rest
  rapidjson::Value message(rapidjson::kObjectType);
  const auto& foundIt = m_handlers.find(messageType);
  if (foundIt != m_handlers.end())
  {
    // serialize using handler
    foundIt->second(pData, message);
  }
  else
  {
    // handler not found -> serialize raw data
    const std::string& encodedData = json_utils::base64_encode(reinterpret_cast<const char*>(pData), dataSize);
    message.AddMember("data",json_utils::str(encodedData, m_allocator), m_allocator);
  }
  ret.AddMember("message", message, m_allocator);
  return ret;
}

rapidjson::Value JSONSerializer::_serializeIndex(const PDB_sVolumeRefIndex_t& index)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::Value ret(rapidjson::kObjectType);
  ret.AddMember("n_refs", index.n_refs, m_allocator);
  // add references
  {
    rapidjson::Value refsArr(rapidjson::Type::kArrayType);
    for (uint32_t i = 0; i < index.n_refs; ++i)
    {
      rapidjson::Value refObj(rapidjson::Type::kObjectType);
      refObj.AddMember("sequence", index.refs[i].sequence, m_allocator);
      refObj.AddMember("volume_id", index.refs[i].volume_id, m_allocator);
      refsArr.PushBack(refObj, m_allocator);
    }
    ret.AddMember("refs", refsArr, m_allocator);
  }
  return ret;
}

bool JSONSerializer::MsgForensicLogV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgForensicLog::Header* const header = reinterpret_cast<const MsgForensicLog::Header*>(data);
  output.AddMember("timestamp", m_transformer->timestamp(header->timestamp), m_allocator);
  output.AddMember("length", header->length, m_allocator);
  output.AddMember("text", json_utils::str_ref(header->text, header->length), m_allocator);
  return true;
}

bool JSONSerializer::MsgDigitizerStartV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgDigitizerStart::Header* const header = reinterpret_cast<const MsgDigitizerStart::Header*>(data);
  output.AddMember("timestamp", m_transformer->timestamp(header->timestamp), m_allocator);
  output.AddMember("reason", header->reason, m_allocator);
  output.AddMember("serial", json_utils::str_s(header->serial, NUM_ELEMENTS(header->serial), m_allocator), m_allocator);
  output.AddMember("bin", json_utils::str_s(header->bin, NUM_ELEMENTS(header->bin), m_allocator), m_allocator);
  output.AddMember("firmware", json_utils::str_s(header->firmware, NUM_ELEMENTS(header->firmware), m_allocator), m_allocator);
  output.AddMember("fpga", json_utils::str_s(header->fpga, NUM_ELEMENTS(header->fpga), m_allocator), m_allocator);
  output.AddMember("network", json_utils::str_s(header->network, NUM_ELEMENTS(header->network), m_allocator), m_allocator);
  output.AddMember("station", json_utils::str_s(header->station, NUM_ELEMENTS(header->station), m_allocator), m_allocator);
  output.AddMember("n_channels", header->n_channels, m_allocator);
  //adding channels info
  rapidjson::Value channels(rapidjson::Type::kArrayType);
  {
    for (uint32_t i = 0; i < header->n_channels; ++i)
    {
      const MsgDigitizerStart::Header::sChannel& channel = header->channels[i];
      rapidjson::Value channelObj(rapidjson::Type::kObjectType);
      channelObj.AddMember("name", json_utils::str_s(channel.name, NUM_ELEMENTS(channel.name), m_allocator), m_allocator);
      channelObj.AddMember("location", json_utils::str_s(channel.location, NUM_ELEMENTS(channel.location), m_allocator), m_allocator);
      channels.PushBack(channelObj, m_allocator);
    }
  }
  output.AddMember("channels", channels, m_allocator);
  output.AddMember("offline", header->offline, m_allocator);
  // adding hardware state info
  rapidjson::Value hardwareState(rapidjson::kObjectType);
  {
    const MsgDigitizerStart::Header::sHardwareState& state = header->hardware_state;
    hardwareState.AddMember("id", state.id, m_allocator);
    hardwareState.AddMember("state", json_utils::str_ref_s(reinterpret_cast<const char*>(state.state.state), NUM_ELEMENTS(state.state.state)), m_allocator);
  }
  output.AddMember("hardware_state", hardwareState, m_allocator);
  output.AddMember("index", this->_serializeIndex(header->index), m_allocator);
  return true;
}

bool JSONSerializer::MsgObsSyncV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgObsSync::Header* const header = reinterpret_cast<const MsgObsSync::Header*>(data);
  output.AddMember("preSyncTimeGnss",    m_transformer->timestamp(header->preSyncTimeGnss),    m_allocator);
  output.AddMember("preSyncTimeSystem",  m_transformer->timestamp(header->preSyncTimeSystem),  m_allocator);
  output.AddMember("postSyncTimeGnss",   m_transformer->timestamp(header->postSyncTimeGnss),   m_allocator);
  output.AddMember("postSyncTimeSystem", m_transformer->timestamp(header->postSyncTimeSystem), m_allocator);  
  output.AddMember("index", this->_serializeIndex(header->index), m_allocator);  
  return true;
}

bool JSONSerializer::MsgHarvestLogV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgHarvestLog::Header* const header = reinterpret_cast<const MsgHarvestLog::Header*>(data);
  output.AddMember("start", m_transformer->timestamp(header->start), m_allocator);
  output.AddMember("duration", header->duration, m_allocator); //duration is already in milliseconds
  output.AddMember("length", header->length, m_allocator);
  output.AddMember("volume_id", header->volume_id, m_allocator);
  output.AddMember("lower", header->lower, m_allocator);
  output.AddMember("upper", header->upper, m_allocator);
  rapidjson::Value timespanTarget(rapidjson::Type::kObjectType);
  {
    timespanTarget.AddMember("valid", header->timespan_target.valid, m_allocator);
    timespanTarget.AddMember("time_lower", m_transformer->timestamp(header->timespan_target.time_lower), m_allocator);
    timespanTarget.AddMember("time_upper", m_transformer->timestamp(header->timespan_target.time_upper), m_allocator);
  }
  output.AddMember("timespan_target", timespanTarget, m_allocator);
  rapidjson::Value timespanActual(rapidjson::Type::kObjectType);
  {
    timespanActual.AddMember("valid", header->timespan_actual.valid, m_allocator);
    timespanActual.AddMember("time_lower", m_transformer->timestamp(header->timespan_actual.time_lower), m_allocator);
    timespanActual.AddMember("time_upper", m_transformer->timestamp(header->timespan_actual.time_upper), m_allocator);
  }
  output.AddMember("timespan_actual", timespanActual, m_allocator);
  rapidjson::Value platformDesc(rapidjson::Type::kObjectType);
  {
    const MsgHarvestLog::Header::sPlatformDesc_t& desc = header->platform_desc;
    platformDesc.AddMember("harvester", json_utils::str_s(desc.harvester, NUM_ELEMENTS(desc.harvester), m_allocator), m_allocator);
    platformDesc.AddMember("os", json_utils::str_s(desc.os, NUM_ELEMENTS(desc.os), m_allocator), m_allocator);
    platformDesc.AddMember("kernel", json_utils::str_s(desc.kernel, NUM_ELEMENTS(desc.kernel), m_allocator), m_allocator);
    platformDesc.AddMember("platform", json_utils::str_s(desc.platform, NUM_ELEMENTS(desc.platform), m_allocator), m_allocator);
    platformDesc.AddMember("bios", json_utils::str_s(desc.bios, NUM_ELEMENTS(desc.bios), m_allocator), m_allocator);
    platformDesc.AddMember("cpu", json_utils::str_s(desc.cpu, NUM_ELEMENTS(desc.cpu), m_allocator), m_allocator);
    platformDesc.AddMember("ram", json_utils::str_s(desc.ram, NUM_ELEMENTS(desc.ram), m_allocator), m_allocator);
    platformDesc.AddMember("disk", json_utils::str_s(desc.disk, NUM_ELEMENTS(desc.disk), m_allocator), m_allocator);
  }
  output.AddMember("platform_desc", platformDesc, m_allocator);
  return true;
}

bool JSONSerializer::MsgOpaqueDataV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgOpaqueData::Header* const header = reinterpret_cast<const MsgOpaqueData::Header*>(data);
  output.AddMember("timestamp", m_transformer->timestamp(header->timestamp), m_allocator);
  //adding opaque data
  {
    output.AddMember("opaque_size", header->opaque_size, m_allocator);
    const std::string& encodedData = (header->opaque_size > 0) ? 
      json_utils::base64_encode(reinterpret_cast<const char*>(header->opaque_data.buffer), header->opaque_size) : 
      "";
    output.AddMember("opaque_data", json_utils::str(encodedData, m_allocator), m_allocator);
  }
  //adding index
  output.AddMember("index", this->_serializeIndex(header->index), m_allocator);
  return true;
}

bool JSONSerializer::MsgBleControlV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgBleControl::Header* const header = reinterpret_cast<const MsgBleControl::Header*>(data);
  output.AddMember("timestamp", m_transformer->timestamp(header->timestamp), m_allocator);
  output.AddMember("bConnected", (header->bConnected == boolean_t::TRUE), m_allocator);
  output.AddMember("mac_addr", json_utils::str_s(reinterpret_cast<const char*>(header->mac_addr), NUM_ELEMENTS(header->mac_addr), m_allocator), m_allocator);
  output.AddMember("index", this->_serializeIndex(header->index), m_allocator);
  return true;
}

bool JSONSerializer::MsgGnssControlV0_Handler(const void* data, rapidjson::Value& output)
{
  __DEV_CALLSTACK_FUNC__;
  const MsgGnssControl::Header* const header = reinterpret_cast<const MsgGnssControl::Header*>(data);
  output.AddMember("timestamp", m_transformer->timestamp(header->timestamp), m_allocator);
  output.AddMember("bRunning", (header->bRunning == boolean_t::TRUE), m_allocator);
  output.AddMember("bOverride", (header->bOverride == boolean_t::TRUE), m_allocator);
  output.AddMember("bExtAntenna", (header->bExtAntenna == boolean_t::TRUE), m_allocator);
  output.AddMember("index", this->_serializeIndex(header->index), m_allocator);
  return true;
}
