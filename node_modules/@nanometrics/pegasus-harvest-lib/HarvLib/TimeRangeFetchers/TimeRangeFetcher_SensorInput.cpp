#include "TimeRangeFetcher_SensorInput.h"

#include <DataTypes/SensorTimeSeries/MsgSensorInput.h>

#include <Utils/pdb_utils.h>

TimeRangeFetcher_SensorInput::TimeRangeFetcher_SensorInput(const std::shared_ptr<ILogger>& logger)
  : ITimeRangeFetcher(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

bool TimeRangeFetcher_SensorInput::_getLowerTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!dataElement.isInstanceOf(PDB_eMessageType_t::MSG_SENSOR_INPUT_V0))
  {
    const message_type_t messageType = dataElement.getHeader()->messageType;
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
      "Invalid message type (0x%08x) fed to fetcher. Should be MSG_SENSOR_INPUT_V0 (0x%08x)",
      (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_SENSOR_INPUT_V0);
    return false;
  }

  const void* pData = nullptr;
  dataElement.getData(&pData);
  const MsgSensorInput::Header* const pMsgHeader = reinterpret_cast<const MsgSensorInput::Header*>(pData);
  *result = pMsgHeader->timestamp;
  return true;
}

bool TimeRangeFetcher_SensorInput::_getUpperTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!dataElement.isInstanceOf(PDB_eMessageType_t::MSG_SENSOR_INPUT_V0))
  {
    const message_type_t messageType = dataElement.getHeader()->messageType;
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
      "Invalid message type (0x%08x) fed to fetcher. Should be MSG_SENSOR_INPUT_V0 (0x%08x)",
      (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_SENSOR_INPUT_V0);
    return false;
  }

  const void* pData = nullptr;
  dataElement.getData(&pData);
  const MsgSensorInput::Header* const pMsgHeader = reinterpret_cast<const MsgSensorInput::Header*>(pData);
  //tss_psflib::end timestamp of the section = timestamp of the very last sample in it
  const timediff_t packetDurationNs = pdb_utils::get_packet_duration_nanoseconds(pMsgHeader->n_samples, pMsgHeader->sample_rate);
  *result = pMsgHeader->timestamp + packetDurationNs;
  return true;
}
