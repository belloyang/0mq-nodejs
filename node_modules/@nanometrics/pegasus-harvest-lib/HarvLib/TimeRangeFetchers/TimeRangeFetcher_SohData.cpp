#include "TimeRangeFetcher_SohData.h"

#include <DataTypes/HealthTimeSeries/MsgHealthInput.h>
#include <DataTypes/HealthTimeSeries/MsgSohData.h>

#include <Utils/pdb_utils.h>

TimeRangeFetcher_SohData::TimeRangeFetcher_SohData(const std::shared_ptr<ILogger>& logger)
  : ITimeRangeFetcher(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

bool TimeRangeFetcher_SohData::_getLowerTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (dataElement.isInstanceOf(PDB_eMessageType_t::MSG_SOH_DATA_V0))
  {
    const void* pData = nullptr; dataElement.getData(&pData);
    const MsgSohData::Header* const pMsgHeader = reinterpret_cast<const MsgSohData::Header*>(pData);
    *result = pMsgHeader->timestamp;
    return true;
  }
  // legacy MsgHealthInput message
  else if (dataElement.isInstanceOf(PDB_eMessageType_t::MSG_HEALTH_INPUT_V0))
  {
    const void* pData = nullptr; dataElement.getData(&pData);
    const MsgHealthInput::Header* const pMsgHeader = reinterpret_cast<const MsgHealthInput::Header*>(pData);
    *result = pMsgHeader->timestamp;
    return true;
  }

  // unsupported message type
  const message_type_t messageType = dataElement.getHeader()->messageType;
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
    "Invalid message type (0x%08x) fed to fetcher. Should be MSG_HEALTH_INPUT_V0 (0x%08x)",
    (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_HEALTH_INPUT_V0);
  return false;
}

bool TimeRangeFetcher_SohData::_getUpperTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (dataElement.isInstanceOf(PDB_eMessageType_t::MSG_SOH_DATA_V0))
  {
    const void* pData = nullptr; dataElement.getData(&pData);
    const MsgSohData::Header* const pMsgHeader = reinterpret_cast<const MsgSohData::Header*>(pData);
    //tss_psflib::end timestamp of the section = timestamp of the very last sample in it
    const timediff_t packetDurationNs = pdb_utils::get_packet_duration_nanoseconds(pMsgHeader->n_samples, pMsgHeader->sample_rate);
    *result = pMsgHeader->timestamp + packetDurationNs;
    return true;
  }
  // legacy MsgHealthInput message
  else if (dataElement.isInstanceOf(PDB_eMessageType_t::MSG_HEALTH_INPUT_V0))
  {
    const void* pData = nullptr; dataElement.getData(&pData);
    const MsgHealthInput::Header* const pMsgHeader = reinterpret_cast<const MsgHealthInput::Header*>(pData);
    //tss_psflib::end timestamp of the section = timestamp of the very last sample in it
    const timediff_t packetDurationNs = pdb_utils::get_packet_duration_nanoseconds(pMsgHeader->n_samples, pMsgHeader->sample_rate);
    *result = pMsgHeader->timestamp + packetDurationNs;
    return true;
  }

  // unsupported message type
  const message_type_t messageType = dataElement.getHeader()->messageType;
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
    "Invalid message type (0x%08x) fed to fetcher. Should be MSG_HEALTH_INPUT_V0 (0x%08x)",
    (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_HEALTH_INPUT_V0);
  return false;
}
