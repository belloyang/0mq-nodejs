#include "TimeRangeFetcher_ClockStatus.h"

#include <DataTypes/ClockStatus/MsgClockStatus.h>

TimeRangeFetcher_ClockStatus::TimeRangeFetcher_ClockStatus(const std::shared_ptr<ILogger>& logger)
  : ITimeRangeFetcher(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

bool TimeRangeFetcher_ClockStatus::_getLowerTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!dataElement.isInstanceOf(PDB_eMessageType_t::MSG_CLOCK_STATUS_V0))
  {
    const message_type_t messageType = dataElement.getHeader()->messageType;
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
      "Invalid message type (0x%08x) fed to fetcher. Should be MSG_CLOCK_STATUS_V0 (0x%08x)", 
      (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_CLOCK_STATUS_V0);
    return false;
  }

  const void* pData = nullptr;
  dataElement.getData(&pData);
  const MsgClockStatus::Header* const pMsgHeader = reinterpret_cast<const MsgClockStatus::Header*>(pData);
  *result = pMsgHeader->timestamp;
  return true;
}

bool TimeRangeFetcher_ClockStatus::_getUpperTimeImpl(const PSFDataElement& dataElement, timestamp_t* result) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!dataElement.isInstanceOf(PDB_eMessageType_t::MSG_CLOCK_STATUS_V0))
  {
    const message_type_t messageType = dataElement.getHeader()->messageType;
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_MESSAGE_TYPE,
      "Invalid message type (0x%08x) fed to fetcher. Should be MSG_CLOCK_STATUS_V0 (0x%08x)",
      (uint32_t)messageType, (uint32_t)PDB_eMessageType_t::MSG_CLOCK_STATUS_V0);
    return false;
  }

  const void* pData = nullptr;
  dataElement.getData(&pData);
  const MsgClockStatus::Header* const pMsgHeader = reinterpret_cast<const MsgClockStatus::Header*>(pData);
  *result = pMsgHeader->timestamp;
  return true;
}
