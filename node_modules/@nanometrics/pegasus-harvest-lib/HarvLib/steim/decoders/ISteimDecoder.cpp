#include "ISteimDecoder.h"

ISteimDecoder::ISteimDecoder(const std::shared_ptr<ILogger>& logger)
:  m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

uint32_t ISteimDecoder::decodeRecord(const SteimFrame_t* frames, const uint32_t nFrames, const bool isBigEndian, sample_t** pOutput) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check and allocate memory for output if null passed
  if (*pOutput == nullptr)
    this->_allocateBufferImpl(nFrames, pOutput);

  const sample_t X0 = isBigEndian ? endianness_utils::swap((frames[0])[1]) : (frames[0])[1];
  const sample_t Xn = isBigEndian ? endianness_utils::swap((frames[0])[2]) : (frames[0])[2];
  uint32_t sampleIdx = 0;
  for (uint32_t frameIdx = 0; frameIdx < nFrames; frameIdx++)
  {
    const SteimFrame_t* const framePtr = &(frames[frameIdx]);
    const uint32_t compressionDataset = isBigEndian ? endianness_utils::swap((*framePtr)[0]) : (*framePtr)[0];
    for (uint32_t datasetIdx = 1; datasetIdx < steim::DATASETS_PER_FRAME; datasetIdx++)
    {
      // get dataset compression nibble (2 bits)
      const uint32_t nibbleOffset = (steim::DATASETS_PER_FRAME - 1 - datasetIdx) * 2;
      const uint32_t compression = (compressionDataset >> nibbleOffset) & 0x3u/*0b11*/;
      if (compression == 0)
      {
        continue;
      }
      const uint32_t dataset = (*framePtr)[datasetIdx];
      // decompress diffs
      const uint8_t nDiffs = this->_decompressDiffsImpl(compression, dataset, &m_packet, isBigEndian);
      // restore samples from diffs
      for (uint8_t diffIdx = 0; diffIdx < nDiffs; diffIdx++)
      {
        // ignore the very first difference for the very first sample and just reuse sample X0, apply difference for all the following samples)
        (*pOutput)[sampleIdx] = (sampleIdx == 0) ? X0 : (*pOutput)[sampleIdx- 1] + m_packet.differences[diffIdx];
        sampleIdx++;
      }
    }
  }

  //tss_harv::integrity check
  if (sampleIdx > 0)
  {
    if ((*pOutput)[sampleIdx - 1] != Xn)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_STEIM_DECOMPRESSION,
        "Integrity check failed: last sample is %i, expected %i",
        (int32_t)(*pOutput)[sampleIdx - 1],
        (int32_t)Xn);
      __ASSERT__((*pOutput)[sampleIdx - 1] == Xn && "Integrity check failed - invalid last sample");
    }
  }

  //tss_harv::sampleIdx has been increased to 1 after last sample decoded -> it stands for samples count
  return sampleIdx;
}
