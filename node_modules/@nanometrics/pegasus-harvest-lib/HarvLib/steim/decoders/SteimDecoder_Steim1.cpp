#include "SteimDecoder_Steim1.h"

#include "../steim1.h"

SteimDecoder_Steim1::SteimDecoder_Steim1(const std::shared_ptr<ILogger>& logger)
: ISteimDecoder(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

uint32_t SteimDecoder_Steim1::_allocateBufferImpl(const uint32_t nFrames, sample_t** pOutput) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::calculate maximum data sets that 1 steim record can contain (each frame has 15 datasets but the very first on - only 13)
  const uint32_t nSamplesDatasets = (nFrames - 1) * (steim::DATASETS_PER_FRAME - 1) + (steim::DATASETS_PER_FRAME - 3);
  //tss_harv::allocate samples buffer considering the best compression ratio (4 - for 8xbits differences)
  const uint32_t bufferSize = 4 * nSamplesDatasets * sizeof(sample_t);
  *pOutput = reinterpret_cast<sample_t*>(::malloc(bufferSize));
  return bufferSize;
}

uint8_t SteimDecoder_Steim1::_decompressDiffsImpl(const uint32_t compression, const uint32_t dataset, steim::PacketInfo* packet,
    const bool isBigEndian) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(compression != 0 && "compression shouldn't be 0 here");
  if (compression == steim1::_4x8_BITS) return steim1::decompressDataset_4x8(dataset, packet);
  if (compression == steim1::_2x16_BITS)
  {
    uint32_t leDataset = dataset;
    if (isBigEndian)
    {
      steim::dword* word = reinterpret_cast<steim::dword*>(&leDataset);
      word->d16[0] = endianness_utils::swap<uint16_t>(word->d16[0]);
      word->d16[1] = endianness_utils::swap<uint16_t>(word->d16[1]);
    }
    return steim1::decompressDataset_2x16(leDataset, packet);
  }
  if (compression == steim1::_1x32_BITS)
  {
    const uint32_t leDataset = isBigEndian ? endianness_utils::swap(dataset) : dataset;
    return steim1::decompressDataset_1x32(leDataset, packet);
  }
  __ASSERT__(false && "Invalid compression");
  return 0;
}
