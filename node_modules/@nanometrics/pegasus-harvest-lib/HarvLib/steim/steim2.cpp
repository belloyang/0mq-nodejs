#include "steim2.h"

#define EXTRACTBITRANGE(VALUE, STARTBIT, LENGTH) ((VALUE >> STARTBIT) & ((1U << LENGTH) - 1))

namespace steim2
{
  uint8_t getDifferenceType(int32_t value)
  {
    if (value >= steim::BITS_4_MIN && value <= steim::BITS_4_MAX)
      return 4;
    if (value >= steim::BITS_5_MIN && value <= steim::BITS_5_MAX)
      return 5;
    if (value >= steim::BITS_6_MIN && value <= steim::BITS_6_MAX)
      return 6;
    if (value >= steim::BITS_8_MIN && value <= steim::BITS_8_MAX)
      return 8;
    if (value >= steim::BITS_10_MIN && value <= steim::BITS_10_MAX)
      return 10;
    if (value >= steim::BITS_15_MIN && value <= steim::BITS_15_MAX)
      return 15;
    if (value >= steim::BITS_30_MIN && value <= steim::BITS_30_MAX)
      return 30;
    return 32;
  }

  uint8_t normalizePacket(struct steim::PacketInfo* packet)
  {
    const uint8_t n_diffs = packet->state_steim.count;
    uint8_t bitness = packet->state_steim.bitness;

    //tss_steim2::empty packet should be skipped
    if (n_diffs == 0)
      return 0;

    //tss_steim2::if at least 28 bits are occupied -> bitness is good
    if (bitness * n_diffs >= 28)
      return bitness;

    //tss_steim2::differences cannot store 32 bits, because in would be 4x8bits differences and package was correct -> differences have to span 30 bits
    //tss_steim2::n_diffs can be in [1;6] range -> bits to pack = 30 / n_diffs
    //30 / 1 diff  = 30 bits
    //30 / 2 diffs = 15 bits
    //30 / 3 diffs = 10 bits
    //32 / 4 diffs = 8 bits
    //30 / 5 diffs = 6 bits
    //30 / 6 diffs = 5 bits
    bitness = (n_diffs == 4) ? 8 : 30 / n_diffs;

    //tss_steim2::set normalized bitness
    packet->state_steim.bitness = bitness;
    return bitness;
  }

  uint32_t compressPacket_1x30(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    dataset = ((uint32_t)packet->differences[0] & steim::BITS_30_MASK);
    /* 2-bit decode nibble is 0b01 (0x1) */
    dataset |= 0x1u << 30;
    return dataset;
  }
  uint32_t compressPacket_2x15(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    /* Mask the values, shift to proper location and set in word */
    dataset  = ((uint32_t)packet->differences[1] & steim::BITS_15_MASK);
    dataset |= ((uint32_t)packet->differences[0] & steim::BITS_15_MASK) << 15;
    /* 2-bit decode nibble is 0b10 (0x2) */
    dataset |= 0x2u << 30;
    return dataset;
  }
  uint32_t compressPacket_3x10(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    /* Mask the values, shift to proper location and set in word */
    dataset  = ((uint32_t)packet->differences[2] & steim::BITS_10_MASK);
    dataset |= ((uint32_t)packet->differences[1] & steim::BITS_10_MASK) << 10;
    dataset |= ((uint32_t)packet->differences[0] & steim::BITS_10_MASK) << 20;
    /* 2-bit decode nibble is 0b11 (0x3) */
    dataset |= 0x3u << 30;
    return dataset;
  }
  uint32_t compressPacket_4x8(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    union steim::dword *word = reinterpret_cast<union steim::dword*>(&dataset);
    word->d8[0] = packet->differences[0];
    word->d8[1] = packet->differences[1];
    word->d8[2] = packet->differences[2];
    word->d8[3] = packet->differences[3];
    return dataset;
  }
  uint32_t compressPacket_5x6(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    /* Mask the values, shift to proper location and set in word */
    dataset  = ((uint32_t)packet->differences[4] & steim::BITS_6_MASK);
    dataset |= ((uint32_t)packet->differences[3] & steim::BITS_6_MASK) << 6;
    dataset |= ((uint32_t)packet->differences[2] & steim::BITS_6_MASK) << 12;
    dataset |= ((uint32_t)packet->differences[1] & steim::BITS_6_MASK) << 18;
    dataset |= ((uint32_t)packet->differences[0] & steim::BITS_6_MASK) << 24;
    /* 2-bit decode nibble is 0b00, nothing to set */
    return dataset;
  }
  uint32_t compressPacket_6x5(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    dataset  = ((uint32_t)packet->differences[5] & steim::BITS_5_MASK);
    dataset |= ((uint32_t)packet->differences[4] & steim::BITS_5_MASK) << 5;
    dataset |= ((uint32_t)packet->differences[3] & steim::BITS_5_MASK) << 10;
    dataset |= ((uint32_t)packet->differences[2] & steim::BITS_5_MASK) << 15;
    dataset |= ((uint32_t)packet->differences[1] & steim::BITS_5_MASK) << 20;
    dataset |= ((uint32_t)packet->differences[0] & steim::BITS_5_MASK) << 25;
    /* 2-bit decode nibble is 0b01 (0x1) */
    dataset |= 0x1u << 30;
    return dataset;
  }
  uint32_t compressPacket_7x4(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    dataset  = ((uint32_t)packet->differences[6] & steim::BITS_4_MASK);
    dataset |= ((uint32_t)packet->differences[5] & steim::BITS_4_MASK) << 4;
    dataset |= ((uint32_t)packet->differences[4] & steim::BITS_4_MASK) << 8;
    dataset |= ((uint32_t)packet->differences[3] & steim::BITS_4_MASK) << 12;
    dataset |= ((uint32_t)packet->differences[2] & steim::BITS_4_MASK) << 16;
    dataset |= ((uint32_t)packet->differences[1] & steim::BITS_4_MASK) << 20;
    dataset |= ((uint32_t)packet->differences[0] & steim::BITS_4_MASK) << 24;
    /* 2-bit decode nibble is 0b10 (0x2) */
    dataset |= 0x2u << 30;
    return dataset;
  }

  uint32_t decompressDataset_1x30(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    const uint32_t semask = 1 << (30 - 1); /* Sign extension from bit 30 */
    sample_diff_t diff0 = EXTRACTBITRANGE(dataset, 0, 30);
    diff0 = (diff0 ^ semask) - semask;
    //01|diff0
    packet->differences[0] = diff0;
    return 1;
  }
  uint32_t decompressDataset_2x15(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //10|diff0|diff1
    const uint32_t semask = 1 << (15 - 1); /* Sign extension from bit 15 */
    for (uint8_t diffIdx = 0; diffIdx < 2; diffIdx++)
    {
      packet->differences[diffIdx] = EXTRACTBITRANGE(dataset, (15 - diffIdx * 15), 15);
      packet->differences[diffIdx] = (packet->differences[diffIdx] ^ semask) - semask;
    }
    return 2;
  }
  uint32_t decompressDataset_3x10(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //11|diff0|diff1|diff2
    const uint32_t semask = 1 << (10 - 1); /* Sign extension from bit 10 */
    for (uint8_t diffIdx = 0; diffIdx < 3; diffIdx++)
    {
      packet->differences[diffIdx] = EXTRACTBITRANGE(dataset, (20 - diffIdx * 10), 10);
      packet->differences[diffIdx] = (packet->differences[diffIdx] ^ semask) - semask;
    }
    return 3;
  }
  uint32_t decompressDataset_4x8(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //diff0|diff1|diff2|diff3
    const union steim::dword *word = reinterpret_cast<const union steim::dword*>(&dataset);
    packet->differences[0] = word->d8[0];
    packet->differences[1] = word->d8[1];
    packet->differences[2] = word->d8[2];
    packet->differences[3] = word->d8[3];
    return 4;
  }
  uint32_t decompressDataset_5x6(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //00|diff0|diff1|diff2|diff3|diff4
    const uint32_t semask = 1 << (6 - 1); /* Sign extension from bit 6 */
    for (uint8_t diffIdx = 0; diffIdx < 5; diffIdx++)
    {
      packet->differences[diffIdx] = EXTRACTBITRANGE(dataset, (24 - diffIdx * 6), 6);
      packet->differences[diffIdx] = (packet->differences[diffIdx] ^ semask) - semask;
    }
    return 5;
  }
  uint32_t decompressDataset_6x5(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //01|diff0|diff1|diff2|diff3|diff4|diff5
    const uint32_t semask = 1 << (5 - 1); /* Sign extension from bit 5 */
    for (uint8_t diffIdx = 0; diffIdx < 6; diffIdx++)
    {
      packet->differences[diffIdx] = EXTRACTBITRANGE(dataset, (25 - diffIdx * 5), 5);
      packet->differences[diffIdx] = (packet->differences[diffIdx] ^ semask) - semask;
    }
    return 6;
  }
  uint32_t decompressDataset_7x4(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //1000|diff0|diff1|diff2|diff3|diff4|diff5|diff6
    const uint32_t semask = 1 << (4 - 1); /* Sign extension from bit 4 */
    for (uint8_t diffIdx = 0; diffIdx < 7; diffIdx++)
    {
      packet->differences[diffIdx] = EXTRACTBITRANGE(dataset, (24 - diffIdx * 4), 4);
      packet->differences[diffIdx] = (packet->differences[diffIdx] ^ semask) - semask;
    }
    return 7;
  }

  bool canPacketAcceptDifference(const struct steim::PacketInfo* packet, uint8_t diff_bitness)
  {
    //tss_steim2::new bitness = max(current bitness, this diff bitness)
    const uint8_t new_bitness = (diff_bitness >= packet->state_steim.bitness) ?
      diff_bitness : packet->state_steim.bitness;
    const uint32_t new_size = new_bitness * (packet->state_steim.count + 1);

    if (new_size > 32)
      return false;

    //8 bits compression (4 x 8 bits) should fit the differences within 32 bits
    if (new_bitness == 8)
      return true; // was "return (new_size <= 32);" but always true due to earlier test

    //tss_steim2::all other compressions should fit the differences within 30 bits
    return (new_size <= 30);
  }

  void toBigEndian(const SteimFrame_t* input, const uint32_t nFrames, SteimFrame_t* output)
  {
    __DEV_CALLSTACK_FUNC__;
    // swap frames
    for (uint32_t frameIdx = 0; frameIdx < nFrames; frameIdx++)
    {
      const uint32_t compressionDataset = input[frameIdx][0];
      // swap datasets with respect to compression nibble
      for (uint32_t datasetIdx = 0; datasetIdx < steim::DATASETS_PER_FRAME; datasetIdx++)
      {
        const uint32_t nibbleOffset = (steim::DATASETS_PER_FRAME - 1 - datasetIdx) * 2;
        const uint32_t compression = (compressionDataset >> nibbleOffset) & 0x3u/*0b11*/;
        const uint32_t dataset = input[frameIdx][datasetIdx];
        // in Steim-2 any case other than 4x8 diffs (0x1 nibble) should be swapped
        // This includes 'special' cases as well (0x0 nibble): x0, xN, compression
        output[frameIdx][datasetIdx] = (compression != _4x8_BITS) ?
            endianness_utils::swap(dataset) :
            dataset;
      }
    }
  }
}
