#include "MiniSEEDRecordsSynthesizer_NoCompression.h"

#include <Utils/endianness_utils.h>

MiniSEEDRecordsSynthesizer_NoCompression::MiniSEEDRecordsSynthesizer_NoCompression(const std::shared_ptr<buffer_base<SteimFrame_t>>& framesBuffer,
  const std::shared_ptr<IMiniSEEDRecordsSynthesizerDelegate>& delegate,
  const bool useBigEndian,
  const std::shared_ptr<ILogger>& logger)
: IMiniSEEDRecordsSynthesizer(framesBuffer, delegate, useBigEndian, logger)
{
  __DEV_CALLSTACK_FUNC__;
}

sample_t MiniSEEDRecordsSynthesizer_NoCompression::_normalizeSampleImpl(const sample_t sample) const
{
  __DEV_CALLSTACK_FUNC__;
  return sample;
}

void MiniSEEDRecordsSynthesizer_NoCompression::_processSampleImpl(const sample_t sample)
{
  __DEV_CALLSTACK_FUNC__;
  // check if sample can fit in the current frame
  constexpr uint32_t nSamplesPerFrameMax = sizeof(SteimFrame_t) / sizeof(sample_t);
  if (m_recordState.nSamplesInFrame >= nSamplesPerFrameMax)
  {
    // commit filled frame (it advances to the next frame: increments frame index and discards sample index inside the new frame)
    this->_commitFrame();
    // check if frame index has been advanced out of records boundary -> commit record
    if (m_recordState.frameIndex >= m_framesBuffer->count())
    {
      // commit the record (it discards all iterators)
      this->_commitRecordImpl();
    }
  }

  // append sample to the working frame
  m_recordState.frame[m_recordState.nSamplesInFrame++] = m_bUseBigEndian ? endianness_utils::swap(sample) : sample;
  m_recordState.nSamplesTotal++;
}

void MiniSEEDRecordsSynthesizer_NoCompression::_commitFrame()
{
  __DEV_CALLSTACK_FUNC__;
  // copy frame to output buffer
  SteimFrame_t& output = m_framesBuffer->at(m_recordState.frameIndex);
  ::memcpy(output, m_recordState.frame, sizeof(m_recordState.frame));
  // reset working frame
  ::memset(m_recordState.frame, 0, sizeof(m_recordState.frame));
  // go to the next frame
  m_recordState.frameIndex++;
  m_recordState.nSamplesInFrame = 0u;
}

void MiniSEEDRecordsSynthesizer_NoCompression::_commitRecordImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_delegate != nullptr)
  {
    MiniSEEDRecordData recordData;
    {
      recordData.mediaType = PDB_eMediaType_t::MEDIA_UNCOMPRESSED;
      recordData.nFrames = 0u;
      recordData.nSamples = m_recordState.nSamplesTotal;
      recordData.data = m_framesBuffer->ptr<const char>();
      recordData.dataSizeInBytes = recordData.nSamples * sizeof(sample_t);
      recordData.isBigEndian = m_bUseBigEndian;
    }
    m_delegate->onRecordReady(recordData);
  }
  // discard records state
  m_recordState.frameIndex = 0u;
  m_recordState.nSamplesInFrame = m_recordState.nSamplesTotal = 0u;
}

void MiniSEEDRecordsSynthesizer_NoCompression::_flushImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_recordState.nSamplesTotal > 0)
  {
    // check if working frame is not empty -> commit it
    if (m_recordState.nSamplesInFrame > 0u)
    {
      this->_commitFrame();
    }
    this->_commitRecordImpl();
  }
}
