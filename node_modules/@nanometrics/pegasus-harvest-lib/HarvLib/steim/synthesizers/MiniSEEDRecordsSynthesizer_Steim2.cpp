#include "MiniSEEDRecordsSynthesizer_Steim2.h"

#include "../../Utils/harvester_utils.h"

#include <libmseed.h>

#include <cstring>
#include <algorithm>

MiniSEEDRecordsSynthesizer_Steim2::MiniSEEDRecordsSynthesizer_Steim2(const std::shared_ptr<buffer_base<SteimFrame_t>>& framesBuffer,
  const std::shared_ptr<IMiniSEEDRecordsSynthesizerDelegate>& delegate,
  const bool useBigEndian,
  const std::shared_ptr<ILogger>& logger)
: IMiniSEEDRecordsSynthesizer(framesBuffer, delegate, useBigEndian, logger)
{
  __DEV_CALLSTACK_FUNC__;
}

sample_t MiniSEEDRecordsSynthesizer_Steim2::_normalizeSampleImpl(const sample_t sample) const
{
  __DEV_CALLSTACK_FUNC__;
  const sample_t normalizedSample = harvester_utils::clamp<sample_t>(sample, steim::BITS_29_MIN, steim::BITS_29_MAX);
  return normalizedSample;
}

void MiniSEEDRecordsSynthesizer_Steim2::_processSampleImpl(const sample_t sample)
{
  __DEV_CALLSTACK_FUNC__;
  // calculate new difference
  const int32_t currentIndex = m_packet.currentSampleIndex;
  const sample_t previousSample = m_packet.samples[currentIndex];
  const sample_diff_t difference = (sample_diff_t)(sample - previousSample);
  // add new sample to the samples buffer and advance sample index
  {
    const int32_t newIndex = (currentIndex + 1) % NUM_ELEMENTS(m_packet.samples);
    m_packet.samples[newIndex] = sample;
    m_packet.currentSampleIndex = newIndex;
  }
  // process this new difference
  const uint8_t diff_bitness = steim2::getDifferenceType(difference);
  //tss_steim2::if packet cannot accept this new difference -> finish the packet
  if (!steim2::canPacketAcceptDifference(&m_packet, diff_bitness))
  {
    //tss_steim2::compress packet (no force record finishing, 1 sample remains out of the packet)
    this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 1, false);
  }

  //tss_steim2::add the difference to the packet and update bitness
  {
    m_packet.differences[m_packet.state_steim.count++] = difference;
    //tss_steim2::update diffs bitness
    m_packet.state_steim.bitness = std::max<uint8_t>(diff_bitness, m_packet.state_steim.bitness);
  }
}

void MiniSEEDRecordsSynthesizer_Steim2::_commitRecordImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_delegate != nullptr)
  {
    MiniSEEDRecordData recordData;
    {
      recordData.mediaType = PDB_eMediaType_t::MEDIA_STEIM2;
      recordData.nFrames = m_record.currentFrame + 1;
      recordData.nSamples = m_record.nSamples;
      recordData.data = m_framesBuffer->ptr<const char>();
      recordData.dataSizeInBytes = recordData.nFrames * sizeof(SteimFrame_t);
      recordData.isBigEndian = m_bUseBigEndian;
    }
    m_delegate->onRecordReady(recordData);
  }
}

void MiniSEEDRecordsSynthesizer_Steim2::_flushImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_packet.state_steim.count > 0)
  {
    const uint32_t currentFrameIdx = m_record.currentFrame;
    SteimFrame_t& output = m_framesBuffer->ptr()[currentFrameIdx];
    //tss_harvlib::record finishing enforced
    this->_compressPacket(output, 0, true);
  }
}

void MiniSEEDRecordsSynthesizer_Steim2::_compressPacket(SteimFrame_t& output, const uint32_t samplesRemain, const bool bForceRecordFinish)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t dataset = 0;
  const uint8_t bitness = steim2::normalizePacket(&m_packet);
  if (bitness == 30) //1 x 30 bits
  {
    dataset = steim2::compressPacket_1x30(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_1x30_BITS, 1, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 15) //2 x 15 bits
  {
    dataset = steim2::compressPacket_2x15(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_2x15_BITS, 2, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 10) // 3 x 10bits
  {
    dataset = steim2::compressPacket_3x10(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_3x10_BITS, 3, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 8) //4 x 8bits
  {
    dataset = steim2::compressPacket_4x8(&m_packet);
    this->_finishDataset(steim2::_4x8_BITS, 4, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 6) //5 x 6bits
  {
    dataset = steim2::compressPacket_5x6(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_5x6_BITS, 5, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 5) //6 x 5bits
  {
    dataset = steim2::compressPacket_6x5(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_6x5_BITS, 6, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 4) //7 x 4bits
  {
    dataset = steim2::compressPacket_7x4(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim2::_7x4_BITS, 7, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else
  {
    __ASSERT__(false && "unsupported bitness");
  }
}
