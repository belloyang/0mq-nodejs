#include "MiniSEEDRecordsSynthesizer_Steim1.h"

#include "../../Utils/harvester_utils.h"

#include <libmseed.h>

#include <cstring>
#include <algorithm>

MiniSEEDRecordsSynthesizer_Steim1::MiniSEEDRecordsSynthesizer_Steim1(const std::shared_ptr<buffer_base<SteimFrame_t>>& framesBuffer,
  const std::shared_ptr<IMiniSEEDRecordsSynthesizerDelegate>& delegate,
  const bool useBigEndian,
  const std::shared_ptr<ILogger>& logger)
: IMiniSEEDRecordsSynthesizer(framesBuffer, delegate, useBigEndian, logger)
{
  __DEV_CALLSTACK_FUNC__;
}

sample_t MiniSEEDRecordsSynthesizer_Steim1::_normalizeSampleImpl(const sample_t sample) const
{
  __DEV_CALLSTACK_FUNC__;
  //32-bits samples are acceptable for Steim1
  return sample;
}

void MiniSEEDRecordsSynthesizer_Steim1::_processSampleImpl(const sample_t sample)
{
  __DEV_CALLSTACK_FUNC__;
  // calculate new difference
  const int32_t currentIndex = m_packet.currentSampleIndex;
  const sample_t previousSample = m_packet.samples[currentIndex];
  const sample_diff_t difference = (sample_diff_t)(sample - previousSample);
  // add new sample to the samples buffer and advance sample index
  {
    const int32_t newIndex = (currentIndex + 1) % NUM_ELEMENTS(m_packet.samples);
    m_packet.samples[newIndex] = sample;
    m_packet.currentSampleIndex = newIndex;
  }

  // process this new difference
  const uint8_t diff_bitness = steim1::getDifferenceType(difference);
  // if packet cannot accept this new difference -> finish the packet
  if (!steim1::canPacketAcceptDifference(&m_packet, diff_bitness))
  {
    if (m_packet.state_steim.count == 3)
    {
      // compress 2 diffs (2 samples remain)
      m_packet.state_steim.count = 2;
      this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 2, false);

      // reset packet with the 3rd sample
      m_packet.state_steim.count = 1;
      m_packet.state_steim.bitness = steim1::getDifferenceType(m_packet.differences[2]);
      m_packet.differences[0] = m_packet.differences[2];
      // check if the next difference can fit into new packet with 1 difference
      if (!steim1::canPacketAcceptDifference(&m_packet, diff_bitness))
      {
        // compress packet (no force record finishing, 1 sample remains out of the packet)
        this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 1, false);
      }
    }
    else
    {
      // compress packet (no force record finishing, 1 sample remains out of the packet)
      this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 1, false);
    }
  }

  // add the difference to the packet and update bitness
  {
    m_packet.differences[m_packet.state_steim.count++] = difference;
    // update diffs bitness
    m_packet.state_steim.bitness = std::max<uint8_t>(diff_bitness, m_packet.state_steim.bitness);
  }
}

void MiniSEEDRecordsSynthesizer_Steim1::_commitRecordImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_delegate != nullptr)
  {
    MiniSEEDRecordData recordData;
    {
      recordData.mediaType = PDB_eMediaType_t::MEDIA_STEIM1;
      recordData.nFrames = m_record.currentFrame + 1;
      recordData.nSamples = m_record.nSamples;
      recordData.data = m_framesBuffer->ptr<const char>();
      recordData.dataSizeInBytes = recordData.nFrames * sizeof(SteimFrame_t);
      recordData.isBigEndian = m_bUseBigEndian;
    }
    m_delegate->onRecordReady(recordData);
  }
}

void MiniSEEDRecordsSynthesizer_Steim1::_flushImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_packet.state_steim.count > 0)
  {
    //tss_harvlib::record finishing enforced
    //3 differences cannot be stored within single dataset in Steim1 -> should be split into 2
    if (m_packet.state_steim.count == 3)
    {
      //tss_harvlib::compress first 2 differences
      m_packet.state_steim.count = 2;
      this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 1, false); //compress 2 differences
      
      //tss_harvlib::shift differences to set 3rd one initial (1st) and compress it
      m_packet.differences[0] = m_packet.differences[2];
      m_packet.state_steim.count = 1;
      m_packet.state_steim.bitness = steim1::getDifferenceType(m_packet.differences[0]);
      this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 0, true);
    }
    else //(1, 2, 4 differences can be stored within single dataset in Steim1)
    {
      this->_compressPacket(m_framesBuffer->at(m_record.currentFrame), 0, true);
    }
  }
}

void MiniSEEDRecordsSynthesizer_Steim1::_compressPacket(SteimFrame_t& output, const uint32_t samplesRemain, const bool bForceRecordFinish)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t dataset = 0;
  const uint8_t bitness = steim1::normalizePacket(&m_packet);
  if (bitness == 32) //1 x 32 bits
  {
    dataset = steim1::compressPacket_1x32(&m_packet);
    if (m_bUseBigEndian)
    {
      dataset = endianness_utils::swap(dataset);
    }
    this->_finishDataset(steim1::_1x32_BITS, 1, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 16) // 2 x 16 bits
  {
    dataset = steim1::compressPacket_2x16(&m_packet);
    if (m_bUseBigEndian)
    {
      steim::dword* word = reinterpret_cast<steim::dword*>(&dataset);
      word->d16[0] = endianness_utils::swap<uint16_t>(word->d16[0]);
      word->d16[1] = endianness_utils::swap<uint16_t>(word->d16[1]);
    }
    this->_finishDataset(steim1::_2x16_BITS, 2, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else if (bitness == 8) //4 x 8bits
  {
    dataset = steim1::compressPacket_4x8(&m_packet);
    this->_finishDataset(steim1::_4x8_BITS, 4, dataset, samplesRemain, output, bForceRecordFinish);
  }
  else
  {
    __ASSERT__(false && "unsupported bitness");
  }
}
