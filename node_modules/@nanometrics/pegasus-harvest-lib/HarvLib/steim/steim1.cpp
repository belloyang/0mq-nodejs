#include "steim1.h"

namespace steim1
{
  uint8_t getDifferenceType(int32_t value)
  {
    if (value >= steim::BITS_8_MIN && value <= steim::BITS_8_MAX)
      return 8;
    if (value >= steim::BITS_16_MIN && value <= steim::BITS_16_MAX)
      return 16;
    return 32;
  }

  uint8_t normalizePacket(struct steim::PacketInfo* packet)
  {
    const uint8_t n_diffs = packet->state_steim.count;
    uint8_t bitness = packet->state_steim.bitness;

    //tss_steim1::empty packet should be skipped
    if (n_diffs == 0)
      return 0;

    //tss_steim1::if exactly 32 bits are occupied -> bitness is good
    if (bitness * n_diffs == 32)
      return bitness;

    __ASSERT__(n_diffs <= 4 && n_diffs != 3 && "Differences count acceptable for packet normalization ins Steim1 is 1, 2, 4");
    bitness = 32 / n_diffs;

    //tss_steim1::set normalized bitness
    packet->state_steim.bitness = bitness;
    return bitness;
  }

  uint32_t compressPacket_1x32(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    dataset = (uint32_t)packet->differences[0];
    return dataset;
  }
  uint32_t compressPacket_2x16(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    union steim::dword *word = reinterpret_cast<union steim::dword*>(&dataset);
    word->d16[0] = packet->differences[0];
    word->d16[1] = packet->differences[1];
    return dataset;
  }
  uint32_t compressPacket_4x8(struct steim::PacketInfo* packet)
  {
    uint32_t dataset;
    union steim::dword *word = reinterpret_cast<union steim::dword*>(&dataset);
    word->d8[0] = packet->differences[0];
    word->d8[1] = packet->differences[1];
    word->d8[2] = packet->differences[2];
    word->d8[3] = packet->differences[3];
    return dataset;
  }

  uint32_t decompressDataset_1x32(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    packet->differences[0] = (sample_diff_t)dataset;
    return 1;
  }
  uint32_t decompressDataset_2x16(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    const union steim::dword *word = reinterpret_cast<const union steim::dword*>(&dataset);
    packet->differences[0] = word->d16[0];
    packet->differences[1] = word->d16[1];
    return 2;
  }
  uint32_t decompressDataset_4x8(const uint32_t dataset, struct steim::PacketInfo* packet)
  {
    //diff0|diff1|diff2|diff3
    const union steim::dword *word = reinterpret_cast<const union steim::dword*>(&dataset);
    packet->differences[0] = word->d8[0];
    packet->differences[1] = word->d8[1];
    packet->differences[2] = word->d8[2];
    packet->differences[3] = word->d8[3];
    return 4;
  }

  bool canPacketAcceptDifference(const struct steim::PacketInfo* packet, uint8_t diff_bitness)
  {
    //tss_steim2::new bitness = max(current bitness, this diff bitness)
    const uint8_t new_bitness = (diff_bitness >= packet->state_steim.bitness) ?
      diff_bitness : packet->state_steim.bitness;
    //tss_steim1::calculate new dataset size accounting this difference
    const uint32_t new_size = new_bitness * (packet->state_steim.count + 1);
    return (new_size <= 32);
  }

  void toBigEndian(const SteimFrame_t* input, const uint32_t nFrames, SteimFrame_t* output)
  {
    __DEV_CALLSTACK_FUNC__;
    // swap frames
    for (uint32_t frameIdx = 0; frameIdx < nFrames; frameIdx++)
    {
      const uint32_t compressionDataset = input[frameIdx][0];
      // swap datasets with respect to compression nibble
      for (uint32_t datasetIdx = 0; datasetIdx < steim::DATASETS_PER_FRAME; datasetIdx++)
      {
        const uint32_t nibbleOffset = (steim::DATASETS_PER_FRAME - 1 - datasetIdx) * 2;
        const uint32_t compression = (compressionDataset >> nibbleOffset) & 0x3u/*0b11*/;
        uint32_t dataset = input[frameIdx][datasetIdx];
        // 2x16 diffs -> swap each 2-bytes diff
        if (compression == _2x16_BITS)
        {
          steim::dword* word = reinterpret_cast<steim::dword*>(&dataset);
          word->d16[0] = endianness_utils::swap<uint16_t>(word->d16[0]);
          word->d16[1] = endianness_utils::swap<uint16_t>(word->d16[1]);
        }
        // 1x32 diff or 'special' case (x0, xN, compression) -> swap the entire dataset
        else if ((compression == _1x32_BITS) || (compression == _SPECIAL))
        {
          dataset = endianness_utils::swap(dataset);
        }
        output[frameIdx][datasetIdx] = dataset;
      }
    }
  }
}
