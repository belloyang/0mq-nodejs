#include "ProgressFilter.h"
#include "../Data/ProgressDataDesc.h"
#include "../../Utils/harvester_utils.h"
#include <Utils/psf_utils.h>

#include <algorithm>

// 20181129:
// For this module, something in the #include tree is defining min() and max() macros,
// which is playing havoc with std::numeric_limits.
#ifdef min
  #undef min
#endif
#ifdef max
  #undef max
#endif
#include <limits> // std::numeric_limits

ProgressFilter::ProgressFilter(const IOperation* operation, const std::shared_ptr<IClient>& client,
  const std::shared_ptr<IProgressDelegate>& delegate,
  const std::shared_ptr<ILogger>& logger)
:  IBaseFilter("ProgressFilter", logger)
,  m_operation(operation)
,  m_client(client)
,  m_progressDelegate(delegate)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerDataHandler(IDataDesc::DATA_TYPE_ERROR, HandlerFunc(&ProgressFilter::_processErrorData, this));
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PROGRESS, HandlerFunc(&ProgressFilter::_processProgressData, this));

  // initialize header
  {
    ::memset(&m_header, 0, sizeof(m_header));
    // init platform description info
    {
      MsgHarvestLog::Header::sPlatformDesc_t& desc = m_header.platform_desc;
      ::memcpy(desc.harvester, m_client->getName().c_str(), std::min<size_t>(sizeof(desc.harvester), m_client->getName().length()));
      ::memcpy(desc.os, m_client->getOS().c_str(), std::min<size_t>(sizeof(desc.os), m_client->getOS().length()));
      ::memcpy(desc.kernel, m_client->getKernel().c_str(), std::min<size_t>(sizeof(desc.kernel), m_client->getKernel().length()));
      ::memcpy(desc.platform, m_client->getPlatform().c_str(), std::min<size_t>(sizeof(desc.platform), m_client->getPlatform().length()));
      ::memcpy(desc.bios, m_client->getBIOS().c_str(), std::min<size_t>(sizeof(desc.bios), m_client->getBIOS().length()));
      ::memcpy(desc.cpu, m_client->getCPU().c_str(), std::min<size_t>(sizeof(desc.cpu), m_client->getCPU().length()));
      ::memcpy(desc.ram, m_client->getRAM().c_str(), std::min<size_t>(sizeof(desc.ram), m_client->getRAM().length()));
      ::memcpy(desc.disk, m_client->getDisk().c_str(), std::min<size_t>(sizeof(desc.disk), m_client->getDisk().length()));
    }
  }

}

ErrorDataDesc* ProgressFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  m_header.lower = pConfig->sequenceRange.lower;
  m_header.upper = pConfig->sequenceRange.upper;
  m_header.start = pConfig->startTime;
  m_header.volume_id = pConfig->volumeID;
  m_header.timespan_target.valid = (boolean_t)pConfig->timeRange.valid;
  m_header.timespan_target.time_lower = pConfig->timeRange.lower;
  m_header.timespan_target.time_upper = pConfig->timeRange.upper;
  return IBaseFilter::run(pConfig);
}

DataDescPtr ProgressFilter::_processErrorData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data cannot be NULL here!");
  ErrorDataDesc* const pErrorData = static_cast<ErrorDataDesc*>(data);
  //tss_harv::get error info
  const IBaseFilter* pFailedFilter = pErrorData->getFilter();
  const std::string& filterName = pFailedFilter->getName();
  //tss_harv::increase filter errors counter
  if (m_failuresCounter.find(filterName) != m_failuresCounter.end())
    m_failuresCounter[filterName]++;
  else
    m_failuresCounter.insert(std::make_pair(filterName, 1));

  //tss_harv::notify delegate with error appeared
  if (m_progressDelegate != nullptr) {
    sHarvestError errorData;
    errorData.code = (uint32_t)pErrorData->getErrorCode();
    errorData.reporter = pErrorData->getFilter()->getName();
    m_progressDelegate->onError(m_operation, errorData);
  }

  //tss_harv::pass untransformed data further
  return data;
}

DataDescPtr ProgressFilter::_processProgressData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data cannot be NULL here!");
  //tss_harv::notify delegate with progress
  ProgressDataDesc* const pProgressData = static_cast<ProgressDataDesc*>(data);
  const sHarvestProgress& progressInfo = pProgressData->getProgressInfo();
  // update the history header with progress info
  {
    m_header.duration = progressInfo.durationMs;
    m_header.length = progressInfo.nBytesProcessed;
    m_header.timespan_actual.valid = (boolean_t)progressInfo.timeRange.valid;
    m_header.timespan_actual.time_lower = progressInfo.timeRange.lower;
    m_header.timespan_actual.time_upper = progressInfo.timeRange.upper;
  }
  //tss_harv::notify delegate with progress
  if (m_progressDelegate != nullptr)
  {
    m_progressDelegate->onProgress(m_operation, progressInfo);
  }
  return data;
}

ErrorDataDesc* ProgressFilter::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_progressDelegate != nullptr && pReport != nullptr)
  {
    m_progressDelegate->onOpReport(m_operation, *pReport, m_header);
  }
  return IBaseFilter::finalize(pReport);
}
