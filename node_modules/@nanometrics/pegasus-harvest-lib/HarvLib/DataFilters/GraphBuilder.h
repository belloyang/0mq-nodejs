#ifndef GraphBuilder_h__
#define GraphBuilder_h__

//tss_harv::this class is responsible for various filters chain creation to perform specific tasks

#include "IBaseFilter.h"

#include "IProgressDelegate.h"
#include "Processors/IProcessorDelegate.h"

#include "../Client/IClient.h"

#include "Generators/gap_generators/IGapGenerator.h"

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>

#include <memory>
#include <string>

/**
 * Graph builder. Provides an easy way to build filters chain for different operations
 */
class GraphBuilder
{
public:
  /**
   * GraphBuilder constructor
   * @param logger      logger instance
   */
  GraphBuilder(const std::shared_ptr<ILogger>& logger);
  /**
   * GraphBuilder destructor
   */
  ~GraphBuilder() = default;

  /**
   * Build filters chain to generate logs
   * @param library           PSF library to write logs to
   * @param startTimestamp    lower timestamp to start logs generation at
   * @param nLogs             amount of logs to generate
   * @return                  root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildLogsGenerationChain(const std::shared_ptr<PSFLibrary>& library,
    const timestamp_t startTimestamp, const uint32_t nLogs) const;
  /**
   * Builds filters chain to harvest logs (output files are stored in working directory)
   * @param operation         operation
   * @param library           PSF library to harvest logs from
   * @param params            harvesting parameters
   * @param maxQueueSize      amount of elements that can be put in reading queue before being processed
   * @param client            client information interface
   * @param progressDelegate  progress delegate
   * @return                  root filter to be run to perform the operation                
   */
  std::shared_ptr<IBaseFilter> buildLogsHaverstingChain(const IOperation* operation, const std::shared_ptr<PSFLibrary>& library,
    const sHarvestParams& params,
    const uint32_t maxQueueSize,
    const std::shared_ptr<IClient>& client,
    const std::shared_ptr<IProgressDelegate>& progressDelegate) const;

  /**
   * Builds filters chain to generate sensor input data (packets)
   * @param library             PSF library to write generated packets to
   * @param startTimestamp      lower timestamp to start data generation at
   * @param channelsMask        8-bits channels mask (0b0000|Ch3|Ch2|Ch1|Ch0, where Ch# is channel enabled bit (0 - disabled, 1 - enabled)
   * @param nPackets            amount of packets to generate
   * @param mediaType           media type to be used for generated data
   * @param useBigEndian        produces Steim frames in big-endian
   * @param gapGenerator        gaps generator (generate time gaps after elements)
   * @param signalLevel         signal peak level (in fractional counts)
   * @param noiseLevel          noise RMS level (in fractional counts)
   * @return                    root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildSensorInputGenerationChain(const std::shared_ptr<PSFLibrary>& library,
    const timestamp_t startTimestamp, const uint8_t channelsMask, const uint32_t nPackets,
    const PDB_eMediaType_t mediaType, const bool useBigEndian,
    const std::shared_ptr<IGapGenerator>& gapGenerator,
    const double signalLevel, const double noiseLevel) const;
  /**
   * Builds filters chain to harvest sensor input data
   * @param operation         operation
   * @param library           PSF library to read sensor input data from
   * @param params            harvesting parameters
   * @param maxQueueSize      amount of elements that can be put in reading queue before being processed
   * @param client            client information interface
   * @param progressDelegate  progress delegate instance
   * @return                  root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildSensorInputHaverstingChain(const IOperation* operation,
    const std::shared_ptr<PSFLibrary>& library,
    const sHarvestParams& params,
    const uint32_t maxQueueSize,
    const std::shared_ptr<IClient>& client,
    const std::shared_ptr<IProgressDelegate>& progressDelegate) const;

  /**
   * Builds filters chain to generate SOH input data (packets)
   * @param library             PSF library to write generated packets to
   * @param startTimestamp      lower timestamp to start data generation at
   * @param nPackets            amount of packets to generate
   * @param gapGenerator        gaps generator (generate time gaps after elements)
   * @param signalLevel         signal peak level (in fractional counts)
   * @param noiseLevel          noise RMS level (in fractional counts)
   * @return                    root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildHealthInputGenerationChain(const std::shared_ptr<PSFLibrary>& library,
    const timestamp_t startTimestamp, const uint32_t nPackets, 
    const std::shared_ptr<IGapGenerator>& gapGenerator,
    const double signalLevel, const double noiseLevel) const;
  /**
   * Builds filters chain to harvest SOH data
   * @param operation         operation
   * @param library           PSF library to read sensor input data from
   * @param params            harvesting params
   * @param channelsMask      channels mask to harvest
   * @param maxQueueSize      amount of elements that can be put in reading queue before being processed
   * @param client            client information interface
   * @param progressDelegate  progress delegate instance
   * @return                  root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildSohDataHaverstingChain(const IOperation* operation,
    const std::shared_ptr<PSFLibrary>& library,
    const sHarvestParams& params,
    const uint32_t channelsMask,
    const uint32_t maxQueueSize,
    const std::shared_ptr<IClient>& client,
    const std::shared_ptr<IProgressDelegate>& progressDelegate) const;

  /**
   * Builds filters chain to generate timing SOH (ClockStatus) input data (packets)
   * @param library             PSF library to write generated packets to
   * @param startTimestamp      lower timestamp to start data generation at
   * @param nPackets            amount of packets to generate
   * @param gapGenerator        gaps generator (generate time gaps after elements)
   * @return                    root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildClockStatusGenerationChain(const std::shared_ptr<PSFLibrary>& library,
    const timestamp_t startTimestamp, const uint32_t nPackets,
    const std::shared_ptr<IGapGenerator>& gapGenerator) const;

  /**
   * Builds filters chain to harvest Timing SOH (ClockStatus) data
   * @param operation         operation
   * @param library           PSF library to read sensor input data from
   * @param params            harvesting parameters
   * @param maxQueueSize      amount of elements that can be put in reading queue before being processed
   * @param client            client information interface
   * @param progressDelegate  progress delegate instance
   * @return                  root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildClockStatusHaverstingChain(const IOperation* operation,
    const std::shared_ptr<PSFLibrary>& library,
    const sHarvestParams& params,
    const uint32_t maxQueueSize,
    const std::shared_ptr<IClient>& client,
    const std::shared_ptr<IProgressDelegate>& progressDelegate) const;

  /**
   * Builds the chain of filters to read the entire volume data
   * @param operation         operation
   * @param library           PSF library to read data from
   * @param volumeId          PDB volume ID to read from
   * @param maxQueueSize      amount of elements that can be put in reading queue before being processed
   * @param processorDelegate data processor delegate
   * @return                  root filter to be run to perform the operation
   */
  std::shared_ptr<IBaseFilter> buildDataProcessingChain(const IOperation* operation,
    const std::shared_ptr<PSFLibrary>& library,
	const uint32_t volumeId,
    const uint32_t maxQueueSize,
    const std::shared_ptr<IProcessorDelegate>& processorDelegate) const;

private:
  //method to build filter chains. Parameters - !!!null-terminated!!! va_list of IBaseFilter*. Returns first filter (filter0)
  IBaseFilter* _makeChain(IBaseFilter* filter0, ...) const;
  IBaseFilter* _makeChain(const std::vector<IBaseFilter*>& filters) const;

  bool _makePath(const std::string& path) const;

private:
  const std::shared_ptr<ILogger> m_logger;
};

#endif //GraphBuilder_h__
