#include "IBaseFilter.h"

#include "Data/ErrorDataDesc.h"

IBaseFilter::IBaseFilter(const std::string& name, const std::shared_ptr<ILogger>& logger)
:  m_dataHandlersMap(IDataDesc::DATA_TYPE_COUNT, HandlerFunc(&IBaseFilter::NullHandler, this)) // 'NullHandler' is default handler
,  m_name(name)
,  m_logger(logger)
,  m_successor(nullptr)
,  m_bStopRequested(false)
,  m_errorsPool(new mem_pool_allocator_new_init<ErrorDataDesc(const IBaseFilter*, const eErrorCategory, const uint32_t)>(), logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_errorsPool.allocate(100, nullptr, eErrorCategory::ERROR_CATEGORY_UNKNOWN, 0);
}

void IBaseFilter::_registerDataHandler(const IDataDesc::eType type, const HandlerFunc& handler)
{
  __DEV_CALLSTACK_FUNC__;
  if (type >= 0 && type < IDataDesc::DATA_TYPE_COUNT) {
    //tss_harv::add handler to handlers's map
    m_dataHandlersMap[type] = handler;
  }
  else {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_INVALID_DATA_TYPE,
      "Invalid type %i supplied", type);
  }
}

ErrorDataDesc* IBaseFilter::_makeError(const char* scope, const eErrorCategory category, const uint32_t errorCode,
  const char* format, ...)
{
  __DEV_CALLSTACK_FUNC__;
  va_list args;
  va_start(args, format);
  m_logger->error_v(scope, category, errorCode, format, args);
  va_end(args);
  return m_errorsPool.new_object(this, category, errorCode);
}

void IBaseFilter::processData(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::skip null data (do nothing to it)
  if (data == nullptr)
    return;

  //tss_harv::process non-null data
  const DataDescPtr processedData = this->_processDataImpl(data, userData);
  //tss_harv::pass data through the chain (to successor)
  if (m_successor != nullptr)
  {
    m_successor->processData(processedData, userData);
  }
}

 DataDescPtr IBaseFilter::_processDataImpl(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::return processed data
  return m_dataHandlersMap[data->getType()](data, userData);
}

 ErrorDataDesc* IBaseFilter::update()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_successor != nullptr)
    return m_successor->update();
  
  return nullptr;
}

 ErrorDataDesc* IBaseFilter::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_successor != nullptr)
    return m_successor->finalize(pReport);

  return nullptr;
}

 ErrorDataDesc* IBaseFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_successor != nullptr)
    return m_successor->run(pConfig);

  return nullptr;
}
