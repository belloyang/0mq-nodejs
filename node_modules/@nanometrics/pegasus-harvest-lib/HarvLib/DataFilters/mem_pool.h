#ifndef mem_pool_h__
#define mem_pool_h__

#include "../harvlib_defines.h"

#include <mutex>
#include <condition_variable>
#include <vector>

#include <Logger/ILogger.h>
#include <memory>

//basic mem_pool_allocator interface
template <typename> class mem_pool_allocator;
template <typename T, typename...Args>
class mem_pool_allocator<T(Args...)>
{
public:
  virtual ~mem_pool_allocator() {}
  virtual T* alloc(Args... args) = 0;
  virtual void reInit(T* obj, Args... args) = 0;
  virtual void dealloc(T* obj) = 0;
};

//"new" allocator interface
template <typename> class mem_pool_allocator_new;
template <typename T, typename...Args>
class mem_pool_allocator_new<T(Args...)> : public mem_pool_allocator<T(Args...)>
{
public:
  virtual ~mem_pool_allocator_new() {}
  virtual T* alloc(Args... args) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { return new T(args...); }
  virtual void reInit(T* /*obj*/, Args... /*args*/) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { /* do nothing here*/ }
  virtual void dealloc(T* obj) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { delete obj; }
};

//"new" allocator interface with "init" method (the same parameters as constructor)
template <typename> class mem_pool_allocator_new_init;
template <typename T, typename...Args>
class mem_pool_allocator_new_init<T(Args...)> : public mem_pool_allocator<T(Args...)>
{
public:
  virtual ~mem_pool_allocator_new_init() {}
  virtual T* alloc(Args... args) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { return new T(args...); }
  virtual void reInit(T* obj, Args... args) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { obj->init(args...); }
  virtual void dealloc(T* obj) __OVERRIDES__(mem_pool_allocator<T(Args...)>) { delete obj; }
};

template <typename> class mem_pool;
template <typename T, typename... Args>
class mem_pool<T(Args...)>
{
public:
//  typedef typename mem_pool_allocator<T(Args...)> allocator_type;
  typedef mem_pool_allocator<T(Args...)> allocator_type; // CygWin compilation fails if 'typename' keyword used

  mem_pool(allocator_type* allocator, const std::shared_ptr<ILogger>& logger)
    : m_allocator(allocator)
    , m_nextIndex(0)
    , m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_allocator != nullptr && "allocator cannot be nullptr here");
  }

  ~mem_pool()
  {
    __DEV_CALLSTACK_FUNC__;
    for (const auto& obj : m_objects)
      m_allocator->dealloc(obj);
    m_objects.clear();
  }

  bool allocate(const uint32_t nObjects, Args... args)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(nObjects > 0 && "nObjects should be > 0");
    if (nObjects <= 0)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_MEMORY_ALLOCATION_FAILED,
        "nObjects should be > 0");
      return false;
    }

    //tss_harv::reserve space in vector and initialize it
    m_objects.reserve(nObjects);
    for (uint32_t i = 0; i < nObjects; i++)
    {
      //tss_harv::allocate new object
      T* newObj = m_allocator->alloc(args...);
      //tss_harv::push it into m_objects
      m_objects.push_back(newObj);
    }
    return true;
  }

  FORCE_INLINE T* new_object(Args... args)
  {
    __DEV_CALLSTACK_FUNC__;
    const uint32_t nObjects = (uint32_t)m_objects.size();
    if (nObjects == 0)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_MEMORY_ALLOCATION_FAILED,
        "Failed to allocate new object - no memory preallocated for buffer");
      return nullptr;
    }
    //tss_harv::fetch object from the queue
    T* const pRet = m_objects.at(m_nextIndex);
    //tss_harv::preform reinit
    m_allocator->reInit(pRet, args...);
    m_nextIndex = (m_nextIndex + 1) % nObjects;
    return pRet;
  }

protected:
  std::vector<T*> m_objects;
  allocator_type* m_allocator;
  uint32_t m_nextIndex;
  const std::shared_ptr<ILogger> m_logger;
};

#endif //mem_pool_h__
