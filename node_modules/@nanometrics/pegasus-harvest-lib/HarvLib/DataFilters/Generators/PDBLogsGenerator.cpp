#include "PDBLogsGenerator.h"

#include <Utils/pdb_utils.h>

#include <cstdio>
#include <cinttypes>

PDBLogsGenerator::PDBLogsGenerator(const timestamp_t startTimestamp, const size_t nLogs, 
    const float updateStep,
    const std::shared_ptr<ILogger>& logger)
:  IPDBDataGenerator("TxtLogWritterFilter", nLogs, updateStep, logger)
,  m_startTimestamp(startTimestamp)
,  m_messageBuffer(nullptr)
,  m_logsMemPool(new mem_pool_allocator_new<MsgForensicLog(void)>(), logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_messageBuffer = (char*)::malloc(MAX_FORENSIC_LOG_MESSAGE_LEN * sizeof(char));
  m_logsMemPool.allocate(1); //1 object pool is enough for single-threaded generation
}

PDBLogsGenerator::~PDBLogsGenerator()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_messageBuffer != nullptr)
    ::free(m_messageBuffer);
}

IPDBMsgObject* PDBLogsGenerator::_generateObject(const uint32_t iteration)
{
  __DEV_CALLSTACK_FUNC__;
  const timestamp_t timestamp = m_startTimestamp + pdb_utils::seconds_to_nanoseconds(iteration); //each log has 1 second offset from the previous
  const int messageLen = ::snprintf(m_messageBuffer, MAX_FORENSIC_LOG_MESSAGE_LEN - 1, "message-%u-%" PRId64 "\n", iteration, timestamp);
  //tss_harv::create PDB message
  MsgForensicLog::Header header;
  {
    header.timestamp = timestamp;
    ::memcpy(header.text, m_messageBuffer, messageLen);
    header.length = messageLen;
  }
  MsgForensicLog* const pLog = m_logsMemPool.new_object();
  if (pLog && pLog->init(header))
    return pLog;
  
  return nullptr;
}
