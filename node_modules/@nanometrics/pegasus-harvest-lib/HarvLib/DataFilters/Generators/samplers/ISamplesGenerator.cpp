#include "ISamplesGenerator.h"

#include "../../../Utils/harvester_utils.h"

// begin: anonymous namespace
namespace
{
  // sample word size limits for typical seismic data compression algorithms
  const uint64_t SAMPLE_WORD_SZ_BITS_STEIM1 = 31ull; // max 31-bit samples and 32-bit differences
  const uint64_t SAMPLE_WORD_SZ_BITS_STEIM2 = 29ull; // max 29-bit samples and 30-bit differences

  // sample size limits for Steim1 compression algorithm
  const double STEIM1_SAMPLE_SZ_LOWER = static_cast<double>( (1ull << (SAMPLE_WORD_SZ_BITS_STEIM1 - 1ull)) - 0ull ) * -1.0;
  const double STEIM1_SAMPLE_SZ_UPPER = static_cast<double>( (1ull << (SAMPLE_WORD_SZ_BITS_STEIM1 - 1ull)) - 1ull ) * +1.0;

  // sample size limits for Steim2 compression algorithm
  const double STEIM2_SAMPLE_SZ_LOWER = static_cast<double>( (1ull << (SAMPLE_WORD_SZ_BITS_STEIM2 - 1ull)) - 0ull ) * -1.0;
  const double STEIM2_SAMPLE_SZ_UPPER = static_cast<double>( (1ull << (SAMPLE_WORD_SZ_BITS_STEIM2 - 1ull)) - 1ull ) * +1.0;
}
// end: anonymous namespace

ISamplesGenerator::ISamplesGenerator()
: m_clipLower(STEIM2_SAMPLE_SZ_LOWER) // default to Steim2 sample limits
, m_clipUpper(STEIM2_SAMPLE_SZ_UPPER)
{
  __DEV_CALLSTACK_FUNC__;
}

sample_t ISamplesGenerator::generateClipped(const uint64_t sampleIndex)
{
  __DEV_CALLSTACK_FUNC__;
  // generate raw sample (unclipped)
  double raw = generateRaw(sampleIndex);
  // round away from zero in preparation for conversion to fixed point
  raw += (raw >= 0.0 ? +0.5 : -0.5);
  // return as fixed point
  return static_cast<sample_t>(harvester_utils::clamp<double, double>(
    raw,
    m_clipLower,   // apply current clip limits
    m_clipUpper));
}

double ISamplesGenerator::generateRaw(const uint64_t sampleIndex)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_generateRawImpl(sampleIndex);
}

void ISamplesGenerator::setClipLimits(uint32_t szBits)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(szBits > 0 && "sz_bits must be > 0");
  __ASSERT__(szBits <= 53 && "sz_bits must not exceed significand precision of double precision floating point (53 bits)");
  m_clipLower = static_cast<double>( (1ull << (szBits - 1ull)) - 0ull ) * -1.0;
  m_clipUpper = static_cast<double>( (1ull << (szBits - 1ull)) - 1ull ) * +1.0;
}

void ISamplesGenerator::setClipLimits(double lower, double upper)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(upper >= lower && "upper must be >= lower");
  m_clipLower = lower;
  m_clipUpper = upper;
}

void ISamplesGenerator::setClipLimits_Steim1()
{
  __DEV_CALLSTACK_FUNC__;
  m_clipLower = STEIM1_SAMPLE_SZ_LOWER;
  m_clipUpper = STEIM1_SAMPLE_SZ_UPPER;
}

void ISamplesGenerator::setClipLimits_Steim2()
{
  __DEV_CALLSTACK_FUNC__;
  m_clipLower = STEIM2_SAMPLE_SZ_LOWER;
  m_clipUpper = STEIM2_SAMPLE_SZ_UPPER;
}
