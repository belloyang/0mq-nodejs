#include "ClockStatusGenerator.h"

#include <Utils/pdb_utils.h>

#define _USE_MATH_DEFINES
#include <math.h>

ClockStatusGenerator::ClockStatusGenerator(const timestamp_t startTimestamp, const uint32_t nPackets,
  const std::shared_ptr<IGapGenerator>& gapGenerator,
  const float updateStep, const std::shared_ptr<ILogger>& logger)
:  IPDBDataGenerator("ClockStatusGenerator", nPackets, updateStep, logger)
,  m_recordTimestamp(startTimestamp)
,  m_sampleRate(MSG_CLOCK_STATUS_RESAMPLING_RATE)
,  m_gapGenerator(gapGenerator)
,  m_clockStatusMemPool(new mem_pool_allocator_new<MsgClockStatus(void)>(), logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_clockStatusMemPool.allocate(1);

  //init generators
  {
    m_generators[eGeneratorID::DUTY_CYCLE] = std::make_shared<SamplesGenerator_RandomUniform>(
      MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_AUTOMATIC, 
      MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_FREE_RUN);

    m_generators[eGeneratorID::ANTENNA_STATUS] = std::make_shared<SamplesGenerator_RandomUniform>(
      MsgClockStatus::Header::eAntennaStatus::ANTENNA_STATUS_OK,
      MsgClockStatus::Header::eAntennaStatus::ANTENNA_STATUS_SHORT);

    m_generators[eGeneratorID::FIX_STATUS] = std::make_shared<SamplesGenerator_RandomUniform>(
      MsgClockStatus::Header::eFixStatus::FIX_STATUS_NONE,
      MsgClockStatus::Header::eFixStatus::FIX_STATUS_3D);
    
    m_generators[eGeneratorID::CLOCK_STATUS] = std::make_shared<SamplesGenerator_RandomUniform>(
      MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_NO_LOCK,
      MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_ALWAYS_ON);

    m_generators[eGeneratorID::ACC_FREERUN] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<uint32_t>::min(),
      std::numeric_limits<uint32_t>::max());

    m_generators[eGeneratorID::CONVERGE_TIME] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<uint16_t>::min(),
      std::numeric_limits<uint16_t>::max());

    m_generators[eGeneratorID::NUM_SATELLITES] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<uint8_t>::min(),
      std::numeric_limits<uint8_t>::max());

    m_generators[eGeneratorID::LATITUDE] = std::make_shared<SamplesGenerator_Sine>(
      0.0, 
      M_PI_4, 
      static_cast<double>(std::numeric_limits<int32_t>::max()));
    m_generators[eGeneratorID::LONGITUDE] = std::make_shared<SamplesGenerator_Sine>(
      1.0 * M_PI_4,
      M_PI_4,
      static_cast<double>(std::numeric_limits<int32_t>::max()));
    m_generators[eGeneratorID::ALTITUDE] = std::make_shared<SamplesGenerator_Sine>(
      2.0 * M_PI_4,
      M_PI_4,
      static_cast<double>(std::numeric_limits<int32_t>::max()));

    m_generators[eGeneratorID::HDOP] = std::make_shared<SamplesGenerator_RandomUniform>(1, 100);
    m_generators[eGeneratorID::PDOP] = std::make_shared<SamplesGenerator_RandomUniform>(1, 100);
    m_generators[eGeneratorID::VDOP] = std::make_shared<SamplesGenerator_RandomUniform>(1, 100);

    m_generators[eGeneratorID::RESIDUAL_MEAS] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<int32_t>::min(),
      std::numeric_limits<int32_t>::max()); //System clock error. MsgClockStatusV0::m_residual_meas (seconds)

    m_generators[eGeneratorID::DRIFT_EST] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<int32_t>::min(),
      std::numeric_limits<int32_t>::max());
    
    m_generators[eGeneratorID::VCXO_CONTROL] = std::make_shared<SamplesGenerator_RandomUniform>(
      std::numeric_limits<uint16_t>::min(),
      std::numeric_limits<uint16_t>::max());
  }

  //cleanup MsgClockStatus header data
  ::memset(&m_header, 0, sizeof(m_header));
}

IPDBMsgObject* ClockStatusGenerator::_generateObject(const uint32_t iteration)
{
  __DEV_CALLSTACK_FUNC__;
  //set cross-input values
  m_header.timestamp = m_recordTimestamp;
  
  //simulate data using generators
  {
    m_header.duty_cycle = static_cast<MsgClockStatus::Header::eDutyCycle>(m_generators[eGeneratorID::DUTY_CYCLE]->generateClipped(iteration));

    m_header.antenna_status = static_cast<MsgClockStatus::Header::eAntennaStatus>(m_generators[eGeneratorID::ANTENNA_STATUS]->generateClipped(iteration));
    m_header.fix_status     = static_cast<MsgClockStatus::Header::eFixStatus>(m_generators[eGeneratorID::FIX_STATUS]->generateClipped(iteration));
    m_header.clock_status   = static_cast<MsgClockStatus::Header::eClockStatus>(m_generators[eGeneratorID::CLOCK_STATUS]->generateClipped(iteration));

    m_header.acc_freerun = static_cast<uint32_t>(m_generators[eGeneratorID::ACC_FREERUN]->generateRaw(iteration));

    m_header.converge_time = static_cast<uint16_t>(m_generators[eGeneratorID::CONVERGE_TIME]->generateRaw(iteration));

    m_header.n_satellites = static_cast<uint8_t>(m_generators[eGeneratorID::NUM_SATELLITES]->generateRaw(iteration));

    m_header.latitude  = m_generators[eGeneratorID::LATITUDE]->generateRaw(iteration);
    m_header.longitude = m_generators[eGeneratorID::LONGITUDE]->generateRaw(iteration);
    m_header.altitude  = static_cast<float>(m_generators[eGeneratorID::ALTITUDE]->generateRaw(iteration));

    m_header.hdop = static_cast<dop_t>(m_generators[eGeneratorID::HDOP]->generateRaw(iteration));
    m_header.pdop = static_cast<dop_t>(m_generators[eGeneratorID::PDOP]->generateRaw(iteration));
    m_header.vdop = static_cast<dop_t>(m_generators[eGeneratorID::VDOP]->generateRaw(iteration));

    m_header.residual_meas = static_cast<float>(m_generators[eGeneratorID::RESIDUAL_MEAS]->generateRaw(iteration));

    m_header.drift_est = static_cast<int32_t>(m_generators[eGeneratorID::DRIFT_EST]->generateClipped(iteration));
    
    m_header.vcxo.control = static_cast<uint32_t>(m_generators[eGeneratorID::VCXO_CONTROL]->generateClipped(iteration));
  }
  
  //tss_harvlib::create health input packet
  MsgClockStatus* const pRet = m_clockStatusMemPool.new_object();
  if (pRet && pRet->init(m_header))
  {
    //tss_harvlib::update next record time (current + packet duration)
    const timediff_t packetDuration = pdb_utils::get_packet_duration_nanoseconds(1, m_sampleRate);
    m_recordTimestamp += packetDuration + m_gapGenerator->generate(iteration);
    //tss_harvlib::return packet
    return pRet;
  }

  return nullptr;
}
