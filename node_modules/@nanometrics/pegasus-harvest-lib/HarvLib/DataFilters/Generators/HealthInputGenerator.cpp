#include "HealthInputGenerator.h"

#include <Utils/pdb_utils.h>

#define _USE_MATH_DEFINES
#include <math.h>

HealthInputGenerator::HealthInputGenerator(const timestamp_t startTimestamp, const uint32_t nPackets,
  const std::shared_ptr<IGapGenerator>& gapGenerator,
  const double signalLevel, const double noiseLevel,
  const float updateStep, const std::shared_ptr<ILogger>& logger)
:  IPDBDataGenerator("HealthInputGenerator", nPackets, updateStep, logger)
,  m_recordTimestamp(startTimestamp)
,  m_sampleRate(MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT)
,  m_gapGenerator(gapGenerator)
,  m_healthInputsMemPool(new mem_pool_allocator_new<MsgHealthInput(void)>(), logger)
,  m_channelsData{
     { 0.05, nullptr, 0ULL },
     { 0.10, nullptr, 0ULL },
     { 0.15, nullptr, 0ULL },
     { 0.20, nullptr, 0ULL },
     { 0.25, nullptr, 0ULL },
     { 0.30, nullptr, 0ULL },
     { 0.35, nullptr, 0ULL },
     { 0.40, nullptr, 0ULL }
  }
{
  __DEV_CALLSTACK_FUNC__;
  m_healthInputsMemPool.allocate(1);
  for (uint8_t channel = 0; channel < NUM_ELEMENTS(m_channelsData); channel++)
  {
    sChannelData& channelData = m_channelsData[channel];
    //tss_harv::creating samples generator for channel
    const std::vector<std::shared_ptr<ISamplesGenerator>> generators = {
      std::make_shared<SamplesGenerator_Sine>(
        0.0, //initial sinusoid phase, radians
        2.0 * M_PI * channelData.signalFreqNormalized, //step per sample, radians (implies sinusoid frequency)
        //Eg. for sample rate=100Hz we have offset=0.0 radians and step=0.1 radians implies 15.9Hz sinusoid (100Hz * 0.1 / 2Pi)     
        signalLevel
        ),
      std::make_shared<SamplesGenerator_RandomNormal>(
        0.0,        // zero DC offset
        noiseLevel  // RMS noise level
        )
    };
    channelData.generator = std::make_shared<SamplesGenerator_Accumulator>(generators);
    channelData.generator->setClipLimits(16); //set 16-bits clippers
  }
}

IPDBMsgObject* HealthInputGenerator::_generateObject(const uint32_t iteration)
{
  __DEV_CALLSTACK_FUNC__;
  //set cross-input values
  m_header.timestamp = m_recordTimestamp;
  m_header.n_samples = NUM_ELEMENTS(m_header.samples);
  m_header.sample_rate = m_sampleRate;
  //initialize samples for each input
  for (uint8_t input = 0; input < PDB_eHealthInput_t::HEALTH_INPUTS_COUNT; input++)
  {
    //tss_harvlib::generate samples for each metric
    sChannelData& channelData = m_channelsData[input];
    for (uint32_t sampleIdx = 0; sampleIdx < m_header.n_samples; sampleIdx++)
    {
      const float sample = static_cast<float>(channelData.generator->generateRaw(channelData.nSamplesTotal++));
      m_header.samples[sampleIdx][input] = sample;
    }
  }

  //tss_harvlib::create health input packet
  MsgHealthInput* const pRet = m_healthInputsMemPool.new_object();
  if (pRet && pRet->init(m_header))
  {
    //tss_harvlib::update next record time (current + packet duration)
    const timediff_t packetDuration = pdb_utils::get_packet_duration_nanoseconds(m_header.n_samples, m_header.sample_rate);
    m_recordTimestamp += packetDuration + m_gapGenerator->generate(iteration);
    //tss_harvlib::return packet
    return pRet;
  }

  return nullptr;
}
