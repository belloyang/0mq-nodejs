#include "SensorInputGenerator.h"

#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_Steim1.h"
#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_Steim2.h"

#include "samplers/samplers.h"

#include <Utils/pdb_utils.h>
#include <Utils/psf_utils.h>

#define _USE_MATH_DEFINES
#include <math.h>

#include <cinttypes> //PRIu64

//! Default software gain (see PEGA-255)
#define SENSOR_INPUT_SOFTWARE_GAIN_DEFAULT 16.0f

/**
 * Synthesizer delegate for this generator.
 * This class just handles when record is ready and queues it into specific queue.
 */
class SynthesizerDelegate_Queue : public IMiniSEEDRecordsSynthesizerDelegate
{
public:
  SynthesizerDelegate_Queue(const timestamp_t startTimestamp, 
    const uint8_t channel, const PDB_sSampleRate_t& sampleRate,
    const std::shared_ptr<IGapGenerator>& gapGenerator,
    std::queue<MsgSensorInput*>& outputQueue,
    const std::shared_ptr<ILogger>& logger)
  : IMiniSEEDRecordsSynthesizerDelegate(logger)
  , m_recordTimestamp(startTimestamp)
  , m_channel(channel)
  , m_sampleRate(sampleRate)
  , m_gapGenerator(gapGenerator)
  , m_outputQueue(outputQueue)
  , m_sensorInputsMemPool(new mem_pool_allocator_new<MsgSensorInput(void)>(), logger)
  , m_nRecordsTotal(0)
  {
    __DEV_CALLSTACK_FUNC__;
    m_sensorInputsMemPool.allocate(1); //1 object pool is enough for single-threaded generation
  }

  virtual ~SynthesizerDelegate_Queue() = default;
  
  virtual void onRecordReady(const MiniSEEDRecordData& record) __OVERRIDES__(IMiniSEEDRecordsSynthesizerDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //tss_harv::create PDB message
    MsgSensorInput::Header header;
    {
      ::memset(&header, 0, sizeof(header));
      header.input = m_channel;
      header.flags = (record.isBigEndian) ? MsgSensorInput::Header::eFlags::FLAG_BIG_ENDIAN : 0;
      header.timestamp = m_recordTimestamp;
      header.n_samples = record.nSamples;
      header.sample_rate = m_sampleRate;
      header.soft_gain = SENSOR_INPUT_SOFTWARE_GAIN_DEFAULT;
      header.media_type = record.mediaType;
      // copy miniSEED record data (represents Steim2 frames produces by synthesizer) to the message header
      ::memcpy(header.frames, record.data, record.dataSizeInBytes);
    }
    MsgSensorInput* const pPacket = m_sensorInputsMemPool.new_object();
    if (pPacket && pPacket->init(header))
    {
      m_nRecordsTotal++;
      //tss_harv::push packet to the queue
      m_outputQueue.emplace(pPacket);

      //update timestamp for the next record
      {
        const timediff_t packetDuration = pdb_utils::get_packet_duration_nanoseconds(record.nSamples, m_sampleRate);
        //tss_harvlib::update next record time (current + packet duration + gap)
        const timediff_t gapDuration = m_gapGenerator->generate(m_nRecordsTotal - 1);
        m_recordTimestamp += packetDuration + gapDuration;
      }
    }
    else
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED, 
        "Failed to init 'MsgSensorInput' element");
    }
  }

private:
  timestamp_t m_recordTimestamp;
  const uint8_t m_channel;
  const PDB_sSampleRate_t m_sampleRate;
  const std::shared_ptr<IGapGenerator> m_gapGenerator;
  std::queue<MsgSensorInput*>& m_outputQueue;
  mem_pool<MsgSensorInput(void)> m_sensorInputsMemPool;
  uint32_t m_nRecordsTotal;
};

SensorInputGenerator::SensorInputGenerator(const timestamp_t startTimestamp, const uint8_t channelsMask, const size_t nPackets,
  const PDB_eMediaType_t mediaType, const bool useBigEndian,
  const std::shared_ptr<IGapGenerator>& gapGenerator,
  const double signalLevel, const double noiseLevel,
  const float updateStep,
  const std::shared_ptr<ILogger>& logger)
:  IPDBDataGenerator("SensorInputGenerator", nPackets, updateStep, logger)
,  m_startTimestamp(startTimestamp)
,  m_channelsMask(channelsMask)
,  m_gapGenerator(gapGenerator)
,  m_channelsData{
     { PDB_sSampleRate_t{{100, 1}}, 0.01, nullptr, nullptr, 0ULL, sChannelData::sStatistics{0U, 0ULL} },
     { PDB_sSampleRate_t{{50,  1}}, 0.03, nullptr, nullptr, 0ULL, sChannelData::sStatistics{0U, 0ULL} },
     { PDB_sSampleRate_t{{20,  1}}, 0.10, nullptr, nullptr, 0ULL, sChannelData::sStatistics{0U, 0ULL} },
     { PDB_sSampleRate_t{{1,   1}}, 0.30, nullptr, nullptr, 0ULL, sChannelData::sStatistics{0U, 0ULL} }
   }
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::create synthesizers and generators
  // NOTE:
  // Pegasus is a 28-bit digitizer. Full-scale counts is +/- (2^27 - 1).
  for (uint8_t channel = 0; channel < NUM_ELEMENTS(m_channelsData); channel++)
  {
    sChannelData& channelData = m_channelsData[channel];
    //tss_harv::creating samples generator for channel
    const std::vector<std::shared_ptr<ISamplesGenerator>> generators = {
      std::make_shared<SamplesGenerator_Sine>(
        0.0, //initial sinusoid phase, radians
        2.0 * M_PI * channelData.signalFreqNormalized, //step per sample, radians (implies sinusoid frequency)
        //Eg. for sample rate=100Hz we have offset=0.0 radians and step=0.1 radians implies 15.9Hz sinusoid (100Hz * 0.1 / 2Pi)     
        signalLevel
        ),
      std::make_shared<SamplesGenerator_RandomNormal>(
        0.0,        // zero DC offset
        noiseLevel  // RMS noise level
        )
    };
    channelData.generator = std::make_shared<SamplesGenerator_Accumulator>(generators);

    // create synthesizer for channel
    switch (mediaType)
    {
    case PDB_eMediaType_t::MEDIA_STEIM1:
      channelData.generator->setClipLimits_Steim1();
      channelData.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_Steim1>(
        std::make_shared<buffer_malloc<SteimFrame_t>>(PDB_SENSOR_INPUT_FRAMES_COUNT), //allocate buffer to contain max supported frames count
        std::make_shared<SynthesizerDelegate_Queue>(m_startTimestamp, channel, channelData.sampleRate,
          m_gapGenerator, //gaps generator
          m_packetsQueue, m_logger),
        useBigEndian,
        m_logger);
      break;

    case PDB_eMediaType_t::MEDIA_STEIM2:
      channelData.generator->setClipLimits_Steim2();
      channelData.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_Steim2>(
        std::make_shared<buffer_malloc<SteimFrame_t>>(PDB_SENSOR_INPUT_FRAMES_COUNT), //allocate buffer to contain max supported frames count
        std::make_shared<SynthesizerDelegate_Queue>(m_startTimestamp, channel, channelData.sampleRate,
          m_gapGenerator, //gaps generator
          m_packetsQueue, m_logger),
        useBigEndian,
        m_logger);
      break;

    default:
      __ASSERT__(false && "Unhandled media type!");
      break;
    }
  }
}

SensorInputGenerator::~SensorInputGenerator()
{
  __DEV_CALLSTACK_FUNC__;
  for (uint32_t channelIdx = 0; channelIdx < NUM_ELEMENTS(m_channelsData); channelIdx++)
  {
    sChannelData& channelData = m_channelsData[channelIdx];
    m_logger->info(__THIS_FUNC__, "Channel #%u: %" PRIu64 " samples generated in %u Steim frames",
      channelIdx, channelData.statistics.nSamples, channelData.statistics.nRecords);
  }
}

IPDBMsgObject* SensorInputGenerator::_generateObject(const uint32_t /*iteration*/)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::while packets queue is empty and not hard stop requested -> build packet
  while (m_packetsQueue.empty() && !m_bStopRequested)
  {
    //tss_harv::iterate over each channel
    for (uint8_t channel = 0; channel < PDB_MAXIMUM_CHANNELS_COUNT; channel++)
    {
      //check if channel is enabled
      const uint8_t channelMask = (1 << channel);
      if ((channelMask & m_channelsMask) == 0)
        continue;

      sChannelData& channelData = m_channelsData[channel];
      //tss_harv::generate samples for the channel for 1 second duration
      const uint32_t nSamplesPerSecond = static_cast<uint32_t>(pdb_utils::decode_sample_rate(channelData.sampleRate));
      for (uint32_t sampleIdx = 0; sampleIdx < nSamplesPerSecond; sampleIdx++)
      {
        const sample_t sample = channelData.generator->generateClipped(channelData.sampleIndex++);
        //tss_harv::feed the sample to synthesizer and update channel state (amount of sample)
        channelData.synthesizer->addSample(sample);
        //tss_harv::check if the queue is not empty -> fetch last element
        if (!m_packetsQueue.empty())
        {
          MsgSensorInput* const pPacket = reinterpret_cast<MsgSensorInput*>(m_packetsQueue.front());
          const MsgSensorInput::Header* const pHeader = pPacket->getHeader();
          // update statistics
          {
            __ASSERT__(pHeader->input <= NUM_ELEMENTS(m_channelsData) && "There is no channel data for channel index! Check m_channelData allocating!");
            sChannelData& channelData = m_channelsData[pHeader->input];
            channelData.statistics.nRecords++;
            channelData.statistics.nSamples += pHeader->n_samples;
          }
          //erase remove front element
          m_packetsQueue.pop();
          //return packet extracted
          return pPacket;
        }
      }
    }
  }

  return nullptr;
}
