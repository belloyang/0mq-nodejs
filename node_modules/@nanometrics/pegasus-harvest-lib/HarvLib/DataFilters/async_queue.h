#ifndef async_queue_h__
#define async_queue_h__

#include "../harvlib_defines.h"

#include <mutex>
#include <condition_variable>
#include <vector>

template <class T>
class async_queue
{
public:
  async_queue()
    : m_maxSize(0u)
    , m_head(0)
    , m_size(0)
    , m_bWaitingStopRequested(false)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  ~async_queue()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  void init(const uint32_t maxSize)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(maxSize > 0 && "Queue should be initialized with positive capacity");
    m_head = m_size = 0;
    m_maxSize = maxSize;
    m_data.resize(m_maxSize);
  }

  /**
   * Pushes data to the back of the queue.
   * @param value   value to push to the queue
   * @param wait    flag that indicates if "push"-operation should wait for free space in the queue or override the oldest element
   */
  FORCE_INLINE void push_back(const T& value, const bool wait)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_maxSize > 0 && "Queue should be initialized before");
    std::unique_lock<std::mutex> lk(m_mutex);
    // wait for free space if needed
    while (wait && (m_size >= m_maxSize))
    {
      m_dataPoppedEvent.wait(lk);
    }

    //tss_harv::thread-safe push (mutex is still locked by unique_lock here)
    const uint32_t index = (m_head + m_size) % m_maxSize;
    m_data[index] = value;
    m_size++;
    //tss_harv::notify that new data received
    m_dataPushedEvent.notify_all();
  }

  FORCE_INLINE bool empty() const
  {
    __DEV_CALLSTACK_FUNC__;
    std::lock_guard<std::mutex> lk(m_mutex);
    return (m_size == 0);
  }

  /**
   * Pops data from the front of the queue.
   * @param output  output to store data to
   * @param wait    flag that indicates if "pop"-operation should wait for any data to appear on the queue if it's empty
   * @return  true if data popped; false - otherwise (no data to pop due to empty queue)
   */
  FORCE_INLINE bool pop_front(T* output, const bool wait)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_maxSize > 0 && "Queue should be initialized before");
    std::unique_lock<std::mutex> lk(m_mutex);
    // wait for free space if needed
    while (wait && !m_bWaitingStopRequested && (m_size == 0u))
    {
      m_dataPushedEvent.wait(lk);
    }

    if (m_size == 0)
    {
      return false;
    }

    *output = m_data[m_head];
    m_head = (m_head + 1) % m_maxSize;
    m_size--;
    //tss_harv::notify that element was removed from the queue
    m_dataPoppedEvent.notify_all();
    return true;
  }

  uint32_t size() const
  {
    __DEV_CALLSTACK_FUNC__;
    std::lock_guard<std::mutex> lk(m_mutex);
    return m_size;
  }

  /**
   * Stops waiting for data arrival on queue
   */
  void stop_waiting()
  {
    __DEV_CALLSTACK_FUNC__;
    {
      std::lock_guard<std::mutex> lk(m_mutex);
      m_bWaitingStopRequested = true;
    }
    //tss_harv::notify that stop flag raised (simulate data pushing. It's safe as waiting "pop" call simply returns false for this case).
    m_dataPushedEvent.notify_all();
  }

protected:
  uint32_t m_maxSize;
  std::vector<T> m_data;
  uint32_t m_head;
  uint32_t m_size;
  mutable std::mutex m_mutex;
  std::condition_variable m_dataPushedEvent;
  std::condition_variable m_dataPoppedEvent;
  bool m_bWaitingStopRequested; // protected with m_mutex above

private:
  // not implemented
  async_queue(const async_queue&) = delete;
  async_queue& operator=(const async_queue&) = delete;
};

#endif //async_queue_h__
