#include "MnemonicsDecoder.h"

#include <Utils/psf_utils.h>

#include <ctime>
#include <cstring>
#include <algorithm> // std::sort

MnemonicsDecoder::MnemonicsDecoder(const std::string& pattern,
  const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider,
  const timediff_t timePrecisionNs,
  const std::shared_ptr<ILogger>& logger)
:  m_pattern(pattern)
,  m_packetInfoProvider(packetInfoProvider)
,  m_timePrecisionNs(timePrecisionNs)
,  m_logger(logger)
,  m_buffer(std::make_shared<buffer_malloc<char>>(1024))
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::initialize decodes
  m_decoderFuncs = {
    {"${TIME}", DECODER_FUNC(MnemonicsDecoder::_decodeTime)}, //is the event time in YYYYMMDD_hhmmss format
    {"${Y}", DECODER_FUNC(MnemonicsDecoder::_decodeYear)  }, //is 4-digit year
    {"${M}", DECODER_FUNC(MnemonicsDecoder::_decodeMonth) }, //is 2-digit month
    {"${D}", DECODER_FUNC(MnemonicsDecoder::_decodeDay)   }, //is 2-digit day of month
    {"${J}", DECODER_FUNC(MnemonicsDecoder::_decodeJDay)  }, //is Julian day (day of year)
    
    {"${h}", DECODER_FUNC(MnemonicsDecoder::_decodeHour) }, //is hour of 2-digit hour of day
    {"${m}", DECODER_FUNC(MnemonicsDecoder::_decodeMin)  }, //is hour of 2-digit minutes of the hour
    {"${s}", DECODER_FUNC(MnemonicsDecoder::_decodeSec)  }, //is hour of 2-digit seconds of the minute

    {"${N}",  DECODER_FUNC(MnemonicsDecoder::_decodeNetwork)  }, //is the network name
    {"${S}",  DECODER_FUNC(MnemonicsDecoder::_decodeStation)  }, //is the station name
    {"${C}",  DECODER_FUNC(MnemonicsDecoder::_decodeChannelName)  }, //is the channel name
    {"${L}",  DECODER_FUNC(MnemonicsDecoder::_decodeChannelLocation) }, //is the channel location
  };

  //tss_harv::analyze mnemonic pattern
  this->_analyze();
}

void MnemonicsDecoder::_analyze()
{
  __DEV_CALLSTACK_FUNC__;
  m_occurrences.reserve(m_pattern.length() >> 2); //each mnemonic is at least 4 chars long
  // find occurrences of each supported mnemonic
  for (const auto& decoder : m_decoderFuncs)
  {
    const std::string& mnemonic = decoder.first;
    std::string::size_type pos = 0;
    while (pos != std::string::npos)
    {
       pos = m_pattern.find(mnemonic, pos);
       if (pos != std::string::npos)
       {
         sOccurrence occurrence;
         occurrence.mnemonic = mnemonic;
         occurrence.position = pos;
         m_occurrences.emplace_back(occurrence);
         pos += mnemonic.length();
       }
    }
  }
  // sort occurrences by position (ascending order)
  std::sort(m_occurrences.begin(), m_occurrences.end(), [](const sOccurrence& arg0, const sOccurrence& arg1) -> int{
    return arg0.position <= arg1.position;
  });
}

bool MnemonicsDecoder::hasMnemonic(const std::string& mnemonic) const
{
  __DEV_CALLSTACK_FUNC__;
  for (const auto& occurence : m_occurrences)
  {
    if (occurence.mnemonic == mnemonic)
      return true;
  }

  return false;
}

size_t MnemonicsDecoder::decode(const sPacketSlice& slice, const std::shared_ptr<buffer_base<char>>& buffer)
{
  __DEV_CALLSTACK_FUNC__;
  std::string::size_type input_pos = 0;
  //use default buffer
  m_decodeStream.reset(buffer);
  //tss_harv::go over all the occurrences
  for (const auto& occurrence : m_occurrences)
  {
    const std::string& mnemonic = occurrence.mnemonic;
    const uint32_t match_pos = occurrence.position;
    const auto foundDecoderIt = m_decoderFuncs.find(mnemonic);
    __ASSERT__(foundDecoderIt != m_decoderFuncs.end() && "occurence found for unregistered menmonic. Check '_analyze' logic");
    // copy data before mnemonic
    m_decodeStream.write(m_pattern.c_str() + input_pos, match_pos - input_pos);
    // decode mnemonic
    (this->*foundDecoderIt->second)(slice, m_decodeStream);
    // adjust input position
    input_pos = (match_pos + mnemonic.length());
  }

  // copy the rest of the input to output
  if (input_pos < m_pattern.length())
  {
    m_decodeStream.write(m_pattern.c_str() + input_pos, m_pattern.length() - input_pos);
  }
  return m_decodeStream.pos();
}

size_t MnemonicsDecoder::decode(const sPacketSlice& slice, std::string& output)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t pos = this->decode(slice, m_buffer);
  if (pos != (size_t)-1)
  {
    output = std::string(m_buffer->ptr<char>(), pos);
    return pos;
  }

  return (size_t)-1;
}

size_t MnemonicsDecoder::_decodeTimeEntity(const sPacketSlice& slice, const char* timeFormat, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  const timestamp_t packetTimestamp = m_packetInfoProvider->getTimestamp(slice);
  const timestamp_t alignedTimestamp = (packetTimestamp / m_timePrecisionNs) * m_timePrecisionNs; //align timestamp to time precision chunks (e.i: 1h, 4h, 24h boundaries, etc.) 
  tm timeAligned; psf_utils::gmtime_from_timestamp(alignedTimestamp, &timeAligned);
  const int len = ::strftime(m_alignedTimeBuff, sizeof(m_alignedTimeBuff), timeFormat, &timeAligned);
  if (len > 0)
    return output.write(m_alignedTimeBuff, len);
  return 0;
}
size_t MnemonicsDecoder::_decodeTime(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%Y%m%d_%H%M%S", output);
}
size_t MnemonicsDecoder::_decodeYear(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%Y", output);
}
size_t MnemonicsDecoder::_decodeMonth(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%m", output);
}
size_t MnemonicsDecoder::_decodeDay(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%d", output);
}
size_t MnemonicsDecoder::_decodeJDay(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%j", output);
}
size_t MnemonicsDecoder::_decodeHour(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%H", output);
}
size_t MnemonicsDecoder::_decodeMin(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%M", output);
}
size_t MnemonicsDecoder::_decodeSec(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  return this->_decodeTimeEntity(slice, "%S", output);
}

size_t MnemonicsDecoder::_decodeNetwork(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& value = m_packetInfoProvider->getNetwork(slice);
  return output.write(value.c_str(), value.length());
}
size_t MnemonicsDecoder::_decodeStation(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& value = m_packetInfoProvider->getStation(slice);
  return output.write(value.c_str(), value.length());
}
size_t MnemonicsDecoder::_decodeChannelName(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& value = m_packetInfoProvider->getChannelName(slice);
  return output.write(value.c_str(), value.length());
}
size_t MnemonicsDecoder::_decodeChannelLocation(const sPacketSlice& slice, StringStream& output) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& value = m_packetInfoProvider->getChannelLocation(slice);
  return output.write(value.c_str(), value.length());
}
