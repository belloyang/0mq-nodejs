#include "PSFReaderPredicate_AND.h"

#include <algorithm>

PSFReaderPredicate_AND::PSFReaderPredicate_AND(const std::shared_ptr<ILogger>& logger)
: IPSFReaderPredicate(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

sSequenceRange PSFReaderPredicate_AND::_getSequenceRangeImpl(PSFStream* pStream) const
{
  __DEV_CALLSTACK_FUNC__;
  sSequenceRange ret;
  {
    ret.lower = 0;
    ret.upper = PSF_SEQUENCE_NUMBER_INVALID;
  }
  //tss_harvlib::do intersection for sequence ranges
  for (const auto& predicate : m_predicates)
  {
      const sSequenceRange& range = predicate->getSequenceRange(pStream);
      if ((range.lower == PSF_SEQUENCE_NUMBER_INVALID) && (range.upper == PSF_SEQUENCE_NUMBER_INVALID))
      {
        return range;
      }
      else
      {
        ret.lower = std::max<sequence_number_t>(ret.lower, range.lower);
        ret.upper = std::min<sequence_number_t>(ret.upper, range.upper);
      }
  }

  return ret;
}

bool PSFReaderPredicate_AND::_checkImpl(const PSFDataElement* pDataElement) const
{
  __DEV_CALLSTACK_FUNC__;
  for (const auto& predicate : m_predicates)
  {
    if (!predicate->check(pDataElement))
      return false;
  }

  return true;
}

bool PSFReaderPredicate_AND::_updateImpl(const PSFDataElement* pDataElement)
{
  __DEV_CALLSTACK_FUNC__;
  for (const auto& predicate : m_predicates)
  {
    if (!predicate->update(pDataElement))
      return false;
  }

  return true;
}
