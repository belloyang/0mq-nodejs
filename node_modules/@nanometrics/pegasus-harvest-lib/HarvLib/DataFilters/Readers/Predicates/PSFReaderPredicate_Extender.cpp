#include "PSFReaderPredicate_Extender.h"

#include <algorithm>

PSFReaderPredicate_Extender::PSFReaderPredicate_Extender(const std::shared_ptr<IPSFReaderPredicate>& basePredicate,
  const int32_t lowerOffset, const int32_t upperOffset,
  const std::shared_ptr<ILogger>& logger)
: IPSFReaderPredicate(logger)
, m_basePredicate(basePredicate)
, m_lowerOffset(lowerOffset)
, m_upperOffset(upperOffset)
{
  __DEV_CALLSTACK_FUNC__;
}

sSequenceRange PSFReaderPredicate_Extender::_getSequenceRangeImpl(PSFStream* pStream) const
{
  __DEV_CALLSTACK_FUNC__;
  sSequenceRange oldRange = m_basePredicate->getSequenceRange(pStream);
  sSequenceRange ret = oldRange;
  // extend sequence range
  if (oldRange.lower != PSF_SEQUENCE_NUMBER_INVALID && oldRange.upper != PSF_SEQUENCE_NUMBER_INVALID)
  {
    // retrieve global available sequence ranges
    const sequence_number_t startSequence = pStream->rtell();
    const sequence_number_t endSequence = pStream->wtell() - 1;
    // calculate extended ranges and restrict to range supported by type
    ret.lower = static_cast<sequence_number_t>(std::max<int64_t>(startSequence, (int64_t)oldRange.lower + m_lowerOffset));
    ret.upper = static_cast<sequence_number_t>(std::min<int64_t>(endSequence, (int64_t)oldRange.upper + m_upperOffset));
  }

  m_logger->info(__THIS_FUNC__, "Sequence range [%u, %u] extended to [%u, %u]",
    oldRange.lower, oldRange.upper,
    ret.lower, ret.upper);
  return ret;
}

bool PSFReaderPredicate_Extender::_checkImpl(const PSFDataElement* pDataElement) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_basePredicate->check(pDataElement);
}

bool PSFReaderPredicate_Extender::_updateImpl(const PSFDataElement* pDataElement)
{
  __DEV_CALLSTACK_FUNC__;
  return m_basePredicate->update(pDataElement);
}
