#include "PSFReaderPredicate_TimeRange.h"

#include <Library/PSFVolume.h>
#include <Library/PSFDataElement.h>
#include <Library/search/SearchEngine.h>

#include "Timestamp_Dichotomizer.h"

#include <cinttypes> // PRIu64
#include <algorithm>

PSFReaderPredicate_TimeRange::PSFReaderPredicate_TimeRange(const sHarvestParams& params,
  const std::shared_ptr<ITimeRangeFetcher>& timeRangeFetcher,
  const std::shared_ptr<ILogger>& logger)
: IPSFReaderPredicate(logger)
, m_params(params)
, m_timeRangeFetcher(timeRangeFetcher)
{
  __DEV_CALLSTACK_FUNC__;
}

sSequenceRange PSFReaderPredicate_TimeRange::_getSequenceRangeImpl(PSFStream* pStream) const
{
  __DEV_CALLSTACK_FUNC__;
  const sequence_number_t readCursorPos = pStream->rtell();
  const sequence_number_t writeCursorPos = pStream->wtell();
  sSequenceRange ret; // {PSF_SEQUENCE_NUMBER_INVALID, PSF_SEQUENCE_NUMBER_INVALID}
  // empty stream check (nothing to read)
  if (readCursorPos == PSF_SEQUENCE_NUMBER_INVALID)
  {
    return ret;
  }

  const PSFVolume* const pVolume = pStream->getVolume();
  PSFDataElement dataElement(pVolume->getHasher(), m_logger);
  // fetch lower boundary
  if (m_params.lower.sequence_number != PSF_SEQUENCE_NUMBER_INVALID)
  {
    // There is a chance that requested sequence doesn't exist anymore (overwritten after ring-buffer looped)
    // select max(readCursor, requestedCursor)
    ret.lower = std::max<sequence_number_t>(readCursorPos, m_params.lower.sequence_number);
  }
  else
  {
    timestamp_t actualDataLowerTime = 0ull;
    pStream->rpush(); // save cursor
    {
      // read first element's lower time
      pStream->readNext(dataElement);
      m_timeRangeFetcher->getLowerTime(dataElement, &actualDataLowerTime);
    }
    pStream->rpop(); // restore cursor
    // check if requested time range ends before the actual lower time
    if (m_params.upper.time < actualDataLowerTime)
    {
      m_logger->warning(__THIS_FUNC__, "Requested time range [%" PRId64 ", %" PRId64 "] ends before actual data lower time %" PRId64,
        m_params.lower.time, m_params.upper.time,
        actualDataLowerTime);
      ret.lower = ret.upper = PSF_SEQUENCE_NUMBER_INVALID;
      return ret;
    }
    else if (m_params.lower.time <= actualDataLowerTime)
    {
      // requested lower time before actual -> start from beginning
      ret.lower = readCursorPos;
    }
    else
    {
      // search lower boundary
      ret.lower = this->_searchLower(pStream);
    }
  }

  // fetch upper boundary
  if (m_params.upper.sequence_number != PSF_SEQUENCE_NUMBER_INVALID)
  {
    // There is a chance that requested sequence doesn't exist anymore (overwritten after ring-buffer looped)
    // select min(writeCursor - 1, requestedCursor)
    ret.upper = std::min<sequence_number_t>(writeCursorPos - 1, m_params.upper.sequence_number);
  }
  else
  {
    timestamp_t actualDataUpperTime = 0ull;
    pStream->rpush(); // save cursor
    {
      // read last element's upper time
      pStream->rseek_end();
      pStream->readPrev(dataElement);
      m_timeRangeFetcher->getUpperTime(dataElement, &actualDataUpperTime);
    }
    pStream->rpop(); // restore cursor
    // check if requested time range starts after the actual upper time
    if (m_params.lower.time > actualDataUpperTime)
    {
      m_logger->warning(__THIS_FUNC__, "Requested time range [%" PRId64 ", %" PRId64 "] starts after actual data upper time %" PRId64,
        m_params.lower.time, m_params.upper.time,
        actualDataUpperTime);
      ret.lower = ret.upper = PSF_SEQUENCE_NUMBER_INVALID;
      return ret;
    }
    else if (m_params.upper.time > actualDataUpperTime)
    {
      // upper time (exclusive) is after actual upper -> finish at the end
      ret.upper = writeCursorPos - 1;
    }
    else
    {
      // search lower boundary
      ret.upper = this->_searchUpper(pStream);
    }
  }

  return ret;
}

sequence_number_t PSFReaderPredicate_TimeRange::_searchLower(PSFStream* pStream) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pStream != nullptr && "pStream cnanot be nullptr here");
  sequence_number_t ret = PSF_SEQUENCE_NUMBER_INVALID;
  const PSFVolume* const pVolume = pStream->getVolume();
  PSFDataElement dataElement(pVolume->getHasher(), m_logger);

  // search for timestamp in [0, nChapters - 2] range (considering 1 chapter reserved for section's header)
  const size_t sectionIdx = SearchEngine().dichotomySearch(0, pVolume->getHeader()->sizeInChapters - 2,
    std::make_shared<Timestamp_Dichotomizer>(pVolume, m_params.lower.time, m_timeRangeFetcher, m_logger));
  if (sectionIdx != (size_t)-1)
  {
    // load section
    PSFSection section(pVolume);
    pVolume->loadSection(sectionIdx, section);
    ret = section.getHeader()->sequenceStart;
    // iterate through section to find the first data element (sequence number) that crosses lower bound
    timestamp_t lowerTime = 0LL, upperTime = 0LL, resultLowerTime = 0LL, resultUpperTime = 0LL;
    PSFSection::iterator it = section.begin();
    while (it.readNext(dataElement))
    {
      const bool bTimestampFetched = m_timeRangeFetcher->getTimeRange(dataElement, &lowerTime, &upperTime);
      __ASSERT__(bTimestampFetched && "Failed to fetch time range. Probably invalid type or invalid fetcher used!");
      // if current packet starts after lower time -> use previous sequence number (might be gap in between)
      if (lowerTime > m_params.lower.time)
      {
        break;
      }
      ret = dataElement.getHeader()->sequenceNumber;
      resultLowerTime = lowerTime;
      resultUpperTime = upperTime;
      //as soon lower time is covered by packet's time range -> break (sequence found)
      if (lowerTime <= m_params.lower.time && m_params.lower.time < upperTime)
      {
        break;
      }
    }
    m_logger->debug(__THIS_FUNC__, "Lower bound (%" PRId64 ") found @ {section #%" PRIu32 ", sequence #%" PRIu32
                    ", covers [%" PRId64 ", %" PRId64 ")}",
                    m_params.lower.time, static_cast<uint32_t>(sectionIdx), ret,
                    resultLowerTime, resultUpperTime);
  }
  else
  {
    m_logger->warning(__THIS_FUNC__, "Lower bound (%" PRId64 ") not found!", m_params.lower.time);
  }

  return ret;
}

sequence_number_t PSFReaderPredicate_TimeRange::_searchUpper(PSFStream* pStream) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pStream != nullptr && "pStream cnanot be nullptr here");
  sequence_number_t ret = PSF_SEQUENCE_NUMBER_INVALID;
  const PSFVolume* const pVolume = pStream->getVolume();
  PSFDataElement dataElement(pVolume->getHasher(), m_logger);
  // search for timestamp in [0, nChapters - 2] range (considering 1 chapter reserved for section's header)
  const size_t sectionIdx = SearchEngine().dichotomySearch(0, pVolume->getHeader()->sizeInChapters - 2,
      std::make_shared<Timestamp_Dichotomizer>(pVolume, m_params.upper.time, m_timeRangeFetcher, m_logger));
  if (sectionIdx != (size_t)-1)
  {
    // load section
    PSFSection section(pVolume);
    pVolume->loadSection(sectionIdx, section);
    ret = section.getHeader()->sequenceStart;
    //Iterate through section to find the first data element that crosses upper bound
    timestamp_t lowerTime = 0LL, upperTime = 0LL, resultLowerTime = 0LL, resultUpperTime = 0LL;
    PSFSection::iterator it = section.begin();
    while (it.readNext(dataElement))
    {
      const bool bTimestampFetched = m_timeRangeFetcher->getTimeRange(dataElement, &lowerTime, &upperTime);
      __ASSERT__(bTimestampFetched && "Failed to fetch time range. Probably invalid type or invalid fetcher used!");
      // if current packet starts after upper time -> use previous sequence number (might be gap in between)
      if (lowerTime > m_params.upper.time)
      {
        break;
      }
      ret = dataElement.getHeader()->sequenceNumber;
      resultLowerTime = lowerTime;
      resultUpperTime = upperTime;
      // as soon upper time is covered by packet's time range -> break (sequence found)
      if (lowerTime <= m_params.upper.time && m_params.upper.time < upperTime)
      {
        break;
      }
    }
    m_logger->debug(__THIS_FUNC__, "Upper bound (%" PRId64 ") found @ {section #%" PRIu32 ", sequence #%" PRIu32
                    ", covers [%" PRId64 ", %" PRId64 ")}",
                    m_params.upper.time, static_cast<uint32_t>(sectionIdx), ret,
                    resultLowerTime, resultUpperTime);
  }
  else
  {
    m_logger->warning(__THIS_FUNC__, "Upper bound (%" PRId64 ") not found!", m_params.upper.time);
  }

  return ret;
}

bool PSFReaderPredicate_TimeRange::_checkImpl(const PSFDataElement* /*pDataElement*/) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::this predicate returns sequences range that satisfy time range & all element it accepts is from this range -> check is always satisfied
  return true;
}

bool PSFReaderPredicate_TimeRange::_updateImpl(const PSFDataElement* /*pDataElement*/)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::Data element does not affect this predicate as it only shrinks the reading range at initialization stage (getSequenceRange call)
  return true;
}
