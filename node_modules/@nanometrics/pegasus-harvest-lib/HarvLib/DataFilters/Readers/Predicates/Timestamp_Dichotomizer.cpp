#include "Timestamp_Dichotomizer.h"

Timestamp_Dichotomizer::Timestamp_Dichotomizer(const PSFVolume* volume, const timestamp_t timestamp,
  const std::shared_ptr<ITimeRangeFetcher>& timeRangeFetcher,
  const std::shared_ptr<ILogger>& logger)
  : IDichotomiser(logger)
  , m_volume(volume)
  , m_timestamp(timestamp)
  , m_timeRangeFetcher(timeRangeFetcher)
  , m_section(nullptr)
  , m_dataElement(nullptr)
  , m_nCalculations(0)
{
  __DEV_CALLSTACK_FUNC__;
  m_dataElement = new PSFDataElement(m_volume->getHasher(), m_volume->getLogger());
  m_section = new PSFSection(m_volume);
  m_cache.reserve(6); //6 elements is enough for [to, middle, upper] for 2 rounds of dichotomy before detecting unused values in the cache
}

Timestamp_Dichotomizer::~Timestamp_Dichotomizer()
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->debug(__THIS_FUNC__, "Section loaded from I/O context %u times", m_nCalculations);
  delete m_section;
  delete m_dataElement;
}

bool Timestamp_Dichotomizer::_fetchTimespan(const uint32_t sectionIdx, sTimespan& out) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::discard values
  out.lower = out.upper = 0LL;
  out.valid = false;

  //tss_harvlib::load section
  m_volume->loadSection(sectionIdx, *m_section);
  if (!m_section->isEmpty())
  {
    const sPSFSectionHeader_t* const pHeader = m_section->getHeader();
    //load the very first data element in the section
    {
      m_section->loadDataElement(pHeader->sequenceStart, *m_dataElement);
      const bool isLowerValid = m_timeRangeFetcher->getLowerTime(*m_dataElement, &out.lower);
      if (!isLowerValid)
        return false;
    }
    //load the very last data element in the section
    {
      m_section->loadDataElement(pHeader->sequenceEnd, *m_dataElement);
      const bool isUpperValid = m_timeRangeFetcher->getUpperTime(*m_dataElement, &out.upper);
      if (!isUpperValid)
        return false;
    }
    //lower & upper are valid -> mark the entire output as valid
    out.valid = true;
  }

  //tss_harvlib::increase amount of calculations done (for statistics)
  m_nCalculations++;

  return out.valid;
}

sTimespan Timestamp_Dichotomizer::_getTimespan(const uint32_t sectionIdx) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harvlib::look for value in the cache
  for (auto& cachedValue : m_cache)
  {
    if (cachedValue.sectionIndex == sectionIdx)
    {
      cachedValue.weight++;
      return cachedValue.timespan;
    }
  }

  //tss_harvlib::if cache is not filled -> append new calculated value
  if (m_cache.capacity() > m_cache.size())
  {
    //tss_harvlib::init cached value
    sCache cachedValue;
    {
      cachedValue.sectionIndex = sectionIdx;
      cachedValue.weight = 1;
      this->_fetchTimespan(sectionIdx, cachedValue.timespan);
    }
    //append value to cache
    m_cache.emplace_back(cachedValue);
    return cachedValue.timespan;
  }
  
  //cache is filled here -> find unused and replace it
  uint32_t minWeightIdx = 0; uint32_t minWeight = m_cache[0].weight;
  for (uint32_t i = 1; i < m_cache.size(); i++)
  {
    sCache &cachedVal = m_cache[i];
    if (cachedVal.weight < minWeight)
    {
      minWeight = cachedVal.weight;
      minWeightIdx = i;
    }
  }
  //update unused value with new data
  sCache& cachedVal = m_cache[minWeightIdx];
  {
    cachedVal.sectionIndex = sectionIdx;
    cachedVal.weight++; //increase weight (not reset to 1) to make it viable (as this one can live as long as any other cached value since now)
    this->_fetchTimespan(sectionIdx, cachedVal.timespan);
  }

  return cachedVal.timespan;
}

bool Timestamp_Dichotomizer::shrinkRange(size_t from, size_t to, size_t& newFrom, size_t& newTo) const
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->debug(__THIS_FUNC__, "Processing range [%lu, %lu]", (unsigned long)from, (unsigned long)to);

  //tss_harvlib::check from section
  const sTimespan& fromTimespan = this->_getTimespan(from);
  if (!fromTimespan.valid) //if "from" section is not valid -> presumingly all the folowing are empty -> timestamp cannot be found
  {
    return false;
  }

  //tss_harvlib::load "middle" section
  const size_t middle = (from + to) >> 1;
  const sTimespan& middleTimespan = this->_getTimespan(middle);
  if (!middleTimespan.valid) //"from" is valid but "middle" - is not -> (data not looped) -> shrink range to [from, middle]
  {
    //tss_harvlib::middle & to are neighbours, but "middle" is invalid ("from" is valid here) -> check if from is good
    if (middle - from <= 1)
    {
      if (m_timestamp < fromTimespan.lower || m_timestamp > fromTimespan.upper)
      {
        return false;
      }
      
      newFrom = newTo = from;
      return true;    
    }

    if (m_timestamp < fromTimespan.lower) //timestamp is before lowest -> cannot be found
    {
      return false;
    }

    //shrink range to [from, middle]
    newFrom = from;
    newTo = middle;
    return true;
  }

  //tss_harvlib::load "to" section
  const sTimespan& toTimespan = this->_getTimespan(to);
  //"from" && "middle" are valid, but "to" is invalid -> (data is not looped) -> shrink range
  if (!toTimespan.valid)
  {
    //neighbour sections -> pick better one ("to" is invalid here, "from" & "middle" - valid) -> check if "from" fits timestamp
    if (to - from <= 1)
    {
      if (m_timestamp < toTimespan.lower || m_timestamp > middleTimespan.upper)
      {
        return false;
      }

      newFrom = newTo = from;
      return true;
    }

    if (m_timestamp < fromTimespan.lower) //timestamp is before lowest -> cannot be found
    {
      return false;
    }
    else if (m_timestamp <= middleTimespan.lower) //timestamp >= from lower && <= middle lower -> search in [from, middle] 
    {
      newFrom = from;
      newTo = middle;
      return true;
    }

    newFrom = middle;
    newTo = to;
    return true;
  }

  //"from", "middle", "to" are valid here
  
  //not looped case: "from" section timestamp is lower then "to" section timestamp (growith time on [from, to]) (data filled up but not looped)
  if (fromTimespan.lower < toTimespan.lower)
  {
    if (m_timestamp < fromTimespan.lower || m_timestamp > toTimespan.upper) //timestamp is before lower timestamp or after upper timestamp -> cannot be found
    {
      return false;
    }

    //neighbour sections -> pick better one
    if (to - from <= 1)
    {
      if (m_timestamp >= toTimespan.lower)
      {
        newFrom = newTo = to;
        return true;
      }

      newFrom = newTo = from;
      return true;
    }

    //timestamp after from lower but before middle lower -> search in [from, middle]
    if (m_timestamp < middleTimespan.lower)
    {
      newFrom = from;
      newTo = middle;
      return true;
    }
    //timestamp after from lower and after middle lowe -> search in [middle, to]
    newFrom = middle;
    newTo = to;
    return true;
  }
  else //looped case ("from" lower is > "to" lower)
  {
    //neighbour sections
    if (to - from <= 1) //e.i (7)|(6)
    {
      if (m_timestamp < toTimespan.upper)
      {
        newFrom = newTo = to;
        return true;
      }

      newFrom = newTo = from;
      return true;
    }

    // (7) 8 |2 (3) 4 5 (6) -> looped in between [from, to]
    if (fromTimespan.lower > middleTimespan.lower)
    {
      if (m_timestamp > fromTimespan.lower || m_timestamp < middleTimespan.lower) //[from, middle] range contains timestamps [from lower; middle upper] (middle section will be covered anyway)
      {
        newFrom = from;
        newTo = middle;
        return true;
      }
      else if (middleTimespan.lower <= m_timestamp && m_timestamp <= toTimespan.upper) //[middle, to] range contains timestamps from middle lower to upper higher
      {
        newFrom = middle;
        newTo = to;
        return false;
      }

      //none of previous conditions met -> timestamp out of range at all
      return false;
    }
    else //from lower < middle lower -> (5) 6 7 (8) | 2 3 (4) -> looped in [middle, to]
    {
      if (fromTimespan.lower <= m_timestamp && m_timestamp <= middleTimespan.lower) //[from, middle] range contains from lower to middle lower timestamps (middle upper middle section is covered anyway)
      {
        newFrom = from;
        newTo = middle;
        return true;
      }
      else if (m_timestamp >= middleTimespan.lower || m_timestamp <= toTimespan.upper)
      {
        newFrom = middle;
        newTo = to;
        return true;
      }

      //none of above met -> return false;
      return false;
    }
  }

  __ASSERT__(false && "logic should never fall back here!");
  return false;
}
