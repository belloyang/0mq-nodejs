#include "PSFReaderFilter.h"

#include "Predicates/PSFReaderPredicate_AND.h"
#include "Predicates/PSFReaderPredicate_Common.h"
#include "Predicates/PSFReaderPredicate_MaxPages.h"
#include "Predicates/PSFReaderPredicate_TimeRange.h"
#include "Predicates/PSFReaderPredicate_Extender.h"

#include "../../TimeRangeFetchers/TimeRangeFetcher_SensorInput.h"
#include "../../TimeRangeFetchers/TimeRangeFetcher_ForensicLog.h"
#include "../../TimeRangeFetchers/TimeRangeFetcher_SohData.h"
#include "../../TimeRangeFetchers/TimeRangeFetcher_ClockStatus.h"

#include <Library/PSFStream.h>
#include <Utils/psf_utils.h>

#include <algorithm>

PSFReaderFilter::PSFReaderFilter(const std::shared_ptr<PSFVolume>& volume, const sHarvestParams& params,
  const uint32_t psfPoolSize, const uint32_t nPagesPerElement,
  const std::shared_ptr<ILogger>& logger)
  : IBaseFilter("PSFReaderFilter", logger)
  , m_volume(volume)
  , m_params(params)
  , m_psfPoolSize(psfPoolSize)
  , m_nPagesPerElement(nPagesPerElement)
  , m_nElementsRead(0)
{
  __DEV_CALLSTACK_FUNC__;
}

ErrorDataDesc* PSFReaderFilter::run(const Config* /*pConfig*/)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_volume == nullptr)
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND,
      "Cannot find 'Logs' volume to harvest logs from");
  }

  //tss_harv::create data elements pool
  struct mem_pool_allocator_psf : public mem_pool_allocator_new<PSFDataElement(const std::shared_ptr<IHasher>&, const std::shared_ptr<ILogger>&)>
  {
  public:
    mem_pool_allocator_psf(const uint32_t preallocatedPages) : m_nPreallocatedPages(preallocatedPages) {}
    PSFDataElement* alloc(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger) __OVERRIDES__(mem_pool_allocator_new)
    {
      __DEV_CALLSTACK_FUNC__;
      PSFDataElement* const pRet = new PSFDataElement(hasher, logger);
      //tss_harv::reserve memory for data element
      pRet->reserveMemory(PSF_PAGES_to_BYTES(m_nPreallocatedPages));
      return pRet;
    }
  private:
    const uint32_t m_nPreallocatedPages;
  };
  mem_pool<PSFDataElement(const std::shared_ptr<IHasher>&, const std::shared_ptr<ILogger>&)> dataElementsPool(new mem_pool_allocator_psf(m_nPagesPerElement),
    m_logger);
  dataElementsPool.allocate(m_psfPoolSize, m_volume->getHasher(), m_volume->getLogger());

  //tss_harv::create PSFDataDesc pool
  mem_pool<PSFDataDesc(PSFDataElement*)> psfPool(new mem_pool_allocator_new_init<PSFDataDesc(PSFDataElement*)>(), m_logger);
  psfPool.allocate(m_psfPoolSize, nullptr);

  const PDB_eVolumeID volumeID = static_cast<PDB_eVolumeID>(m_volume->getHeader()->uniqueId);
  //tss_harvlib::build predicate to follow max pages and time range conditions
  const std::shared_ptr<PSFReaderPredicate_AND> readerPredicate = std::make_shared<PSFReaderPredicate_AND>(m_logger);
  {
    //tss_harvlib::add common predicate
    readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_Common>(volumeID, m_logger));
    //tss_harvlib::add predicate to control max amount of pages
    readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_MaxPages>(m_params.nPagesMax, m_logger));
    //tss_harvlib::add predicate for MsgSensorInput to control time ranges
    switch (volumeID)
    {
    case PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES:
      readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_TimeRange>(m_params,
        std::make_shared<TimeRangeFetcher_SensorInput>(m_logger), m_logger));
      break;

    case PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES:
      readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_TimeRange>(m_params,
        std::make_shared<TimeRangeFetcher_SohData>(m_logger), m_logger));
      break;

    case PDB_eVolumeID::VOLUME_CLOCK_STATUS:
      readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_Extender>(
        std::make_shared<PSFReaderPredicate_TimeRange>(m_params,
          std::make_shared<TimeRangeFetcher_ClockStatus>(m_logger), m_logger),
        0, //no offset for lower bound
        1, //1 offset for upper bound: we need to include the next element into reading just to allow extrapolate/resample data
        m_logger));
      break;

    case PDB_eVolumeID::VOLUME_FORENSIC_LOG:
      readerPredicate->addPredicate(std::make_shared<PSFReaderPredicate_TimeRange>(m_params,
        std::make_shared<TimeRangeFetcher_ForensicLog>(m_logger), m_logger));
      break;

    default:
      // do nothing here
      break;
    }
  }

  //tss_harv::open stream
  PSFStream* const pStream = new PSFStream(m_volume.get(), m_logger);
  //tss_harvlib::fetch sequences range to read by reader predicate
  IBaseFilter::Config config;
  // init run configuration
  {
    config.startTime = psf_utils::get_timestamp();
    config.volumeID = volumeID;
    config.timeRange.lower = m_params.lower.time;
    config.timeRange.upper = m_params.upper.time;
    config.timeRange.valid = true; // init requested time range
    config.sequenceRange = readerPredicate->getSequenceRange(pStream);
  }
  m_logger->info(__THIS_FUNC__, "Reading will be done on [%u, %u] range", config.sequenceRange.lower, config.sequenceRange.upper);

  // run the chain with run configuration
  if (m_successor != nullptr)
  {
    ErrorDataDesc* const pErrorDesc = m_successor->run(&config);
    if (pErrorDesc != nullptr)
      return pErrorDesc;
  }

  // if there is some data to read
  if ((config.sequenceRange.lower != PSF_SEQUENCE_NUMBER_INVALID) && (config.sequenceRange.upper != PSF_SEQUENCE_NUMBER_INVALID))
  {
    //tss_harvlib::set read cursor to beginning of the read range
    pStream->rseek(config.sequenceRange.lower);
    sequence_number_t currentSequence = config.sequenceRange.lower; //future use information only
    //tss_harvlib::iterate through the stream till end not reached || stop requested
    while (!m_bStopRequested && !pStream->is_eof())
    {
      PSFDataElement* const pDataElement = dataElementsPool.new_object(m_volume->getHasher(), m_volume->getLogger());
      //tss_harv::read data element
      if (pStream->readNext(*pDataElement) > 0)
      {
        m_nElementsRead++;

        //tss_harvlib::update current sequence number
        currentSequence = pDataElement->getHeader()->sequenceNumber;

        //tss_harvlib::check if reading cannot be continued (predicate check failed or sequence is higher then needed!)
        if (!readerPredicate->check(pDataElement) || currentSequence > config.sequenceRange.upper)
        {
          break;
        }
        //tss_harv::pass data element through the chain
        PSFDataDesc* const psfData = psfPool.new_object(pDataElement);
        this->processData(psfData, nullptr);

        //tss_harvlib::update predicate with element processed
        readerPredicate->update(pDataElement);
      }
      else
      {
        ErrorDataDesc* pErrorDesc = this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
          "Failed to read data element");
        this->processData(pErrorDesc, nullptr);
        this->requestStop();
      }

      //tss_harv::update
      this->update();
    }
  }
  delete pStream;

  // finalize with report
  sHarvestOpReport report;
  {
    report.finishTime = psf_utils::get_timestamp();
    report.status = m_bStopRequested ? eOperationStatus::OP_STATUS_ABORTED : eOperationStatus::OP_STATUS_COMPLETED;
  }
  return this->finalize(&report);
}

ErrorDataDesc* PSFReaderFilter::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->info(__THIS_FUNC__, "%lu elements read!", m_nElementsRead);
  return IBaseFilter::finalize(pReport);
}
