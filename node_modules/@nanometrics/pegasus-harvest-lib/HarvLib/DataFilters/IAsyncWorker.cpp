#include "IAsyncWorker.h"

#include <thread>
#include <cinttypes>

IAsyncWorker::IAsyncWorker(async_queue<DataDescPtr>& input, async_queue<DataDescPtr>& output,
  const std::shared_ptr<ILogger>& logger)
  : m_inputQueue(input)
  , m_outputQueue(output)
  , m_logger(logger)
  , m_bIsLaunched(false)
  , m_bIsFinished(false)
  , m_bIsStopRequested(false)
  , m_bIsFinishRequested(false)
  , m_nElementsProcessed(0u)
{
  __DEV_CALLSTACK_FUNC__;
}

IAsyncWorker::~IAsyncWorker()
{
  __DEV_CALLSTACK_FUNC__;
  // request stop and wait for finish
  m_bIsStopRequested = true;
  this->wait();
}

void IAsyncWorker::wait()
{
  __DEV_CALLSTACK_FUNC__;
  this->_waitForFinish();
}

void IAsyncWorker::start()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::start task thread
  std::thread th(&IAsyncWorker::_threadFunc, this);
  th.detach();
  this->_waitForStart();
}

void IAsyncWorker::_waitForStart()
{
  __DEV_CALLSTACK_FUNC__;
  std::unique_lock<std::mutex> lk(m_mutex);
  while (!m_bIsLaunched)
  {
    m_startedEvent.wait(lk);
  }
}

void IAsyncWorker::_waitForFinish()
{
  __DEV_CALLSTACK_FUNC__;
  std::unique_lock<std::mutex> lock(m_mutex);
  while (!m_bIsFinished)
  {
    m_finishedEvent.wait(lock);
  }
}

void IAsyncWorker::_threadFunc()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::mark that process is running and notify start event
  {
    std::lock_guard<std::mutex> lk(m_mutex);
    m_bIsLaunched = true;
    m_startedEvent.notify_all();
  }
  m_logger->debug(__THIS_FUNC__, "Worker %p started", this);
  //tss_harv::while stop (hard stop) is not requested -> execute
  try
  {
    while (!m_bIsStopRequested)
    {
      const bool bContinue = this->_loopTick();
      if (!bContinue)
        break;
    }
  }
  catch (const std::exception& e)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Exception caught: UNKNOWN");
  }
  //tss_harv::mark process as not running and notify that execution is done
  {
    std::lock_guard<std::mutex> lk(m_mutex);
    m_bIsFinished = true;
    m_finishedEvent.notify_all();
  }
  m_logger->debug(__THIS_FUNC__, "Worker %p finished (%" PRIu32 " elements processed)",
    this, m_nElementsProcessed);
}

bool IAsyncWorker::_loopTick()
{
  __DEV_CALLSTACK_FUNC__;
  bool bContinue = true;
  // wait for data to appear in the queue
  DataDescPtr data = nullptr;
  // retrieve the data from queue and process it if retrieved (wait till data appears or till "stop_waiting" called)
  while (m_inputQueue.pop_front(&data, true))
  {
    const DataDescPtr processedData = this->_processImpl(data);
    m_nElementsProcessed++;
    // push result into processed queue (wait for free space in the queue)
    m_outputQueue.push_back(processedData, true);
  }

  // check if finish requested
  if (m_bIsFinishRequested)
  {
    // finalize processing if finish requested and no data to process
    bContinue = !m_inputQueue.empty();
  }
  return bContinue;
}
