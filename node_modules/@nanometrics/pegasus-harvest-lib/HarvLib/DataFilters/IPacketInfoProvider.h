#ifndef IPacketInfoProvider_h__
#define IPacketInfoProvider_h__

#include "../harvlib_defines.h"

#include <string>

struct sPacketSlice
{
  sequence_number_t sequenceNumber = PSF_SEQUENCE_NUMBER_INVALID; // PSF sequence number for the element that slice created from
  timestamp_t timestamp = 0LL; // timestamp of the very first sample in the slice
  uint8_t channelIndex = 0;
  int32_t sliceIndex = 0;
  const char* data = nullptr;
  timestamp_t expectedTimestamp = 0LL; // timestamp that is expected for the next sample to be pushed to the slice.
  // is used to detect gaps and flush the packets
  uint32_t firstSampleIndex = 0U;
  size_t dataSizeInBytes = 0;
  uint32_t nSamples = 0U;
  uint32_t nFramesCompressed = 0U; // number of compressed rames (required by blockette #1001)
  PDB_sSampleRate_t sampleRate = PDB_sSampleRate_t{ {0, 0} };
  PDB_eMediaType_t mediaType = PDB_eMediaType_t::MEDIA_UNCOMPRESSED;
  bool isBigEndian = false; // indicates if 'data' is represented in big-endian byte order
  bool isLast = false; // specifies if the slice ends up the channel in the file (hits upper time boundary for the file)
};

class IPacketInfoProvider
{
protected:
  IPacketInfoProvider() {}

public:
  virtual ~IPacketInfoProvider() {}
  virtual void initialize(const sSequenceRange& seuqenceRange) = 0;

  virtual timestamp_t getTimestamp(const sPacketSlice& slice) const = 0;
  virtual const std::string& getNetwork(const sPacketSlice& slice) const = 0;
  virtual const std::string& getStation(const sPacketSlice& slice) const = 0;
  virtual const std::string& getChannelName(const sPacketSlice& slice) const = 0;
  virtual const std::string& getChannelLocation(const sPacketSlice& slice) const = 0;
};

#endif //IPacketInfoProvider_h__
