#ifndef PacketSlicer_TimeRange_h__
#define PacketSlicer_TimeRange_h__

#include "../../harvlib_defines.h"

#include <Logger/ILogger.h>

#include <DataTypes/SensorTimeSeries/MsgSensorInput.h>

#include "../../steim/decoders/ISteimDecoder.h"
#include "../../steim/synthesizers/IMiniSEEDRecordsSynthesizer.h"
#include "../IPacketInfoProvider.h"

#include <vector>
#include <memory>
#include <map>

class PacketSlicer_TimeRange
{
public:
  PacketSlicer_TimeRange(const sTimespan& timeRange, const sSequenceRange& sequenceRange,
    const timediff_t sliceLengthNs, const std::shared_ptr<ILogger>& logger);
  virtual ~PacketSlicer_TimeRange();

  std::vector<sPacketSlice> slice(const MsgSensorInput* pPacket, const sequence_number_t sequenceNumber);

  DECLARE_NOCOPYABLE(PacketSlicer_TimeRange);

protected:
  void _recompressSlice(const uint32_t sliceIndex, sPacketSlice& slice, const PDB_eMediaType_t mediaType);

private:
  // verify that slice lies within the same global slice index (doesn't cross miniSEED duration boundary)
  bool _checkSlice(const sPacketSlice& slice, const double sampleDurationNs) const;

private:
  const std::shared_ptr<ILogger> m_logger;
  const sTimespan m_timeRange;
  const sSequenceRange m_sequenceRange;
  const timediff_t m_sliceLengthNs; //general slice length in nanoseconds
  const std::map<PDB_eMediaType_t, std::shared_ptr<ISteimDecoder>> m_decodersMap;
  const std::map<PDB_eMediaType_t, std::shared_ptr<IMiniSEEDRecordsSynthesizer>> m_synthesizersMap;

  sample_t* m_samplesBuffer;
  std::vector<std::shared_ptr<buffer_base<SteimFrame_t>>> m_frameBuffers;
  std::vector<MiniSEEDRecordData> m_recompressedRecordsQueue;
  sample_t m_lastSamples[PDB_MAXIMUM_CHANNELS_COUNT]; //last sample in each channel
};

#endif //PacketSlicer_TimeRange_h__

