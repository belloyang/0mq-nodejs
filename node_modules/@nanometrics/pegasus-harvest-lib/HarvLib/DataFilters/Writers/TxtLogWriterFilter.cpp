#include "TxtLogWriterFilter.h"

#include "../AsyncWorker_Functor.h"
#include "PacketInfoProvider_DigitizerStartBased.h"

#include <IOContext/io_contexts.h>

#include <Utils/psf_utils.h>
#include <PlatformUtils/PlatformUtils.h>

#include <cstring>

/**
 * This class is designed to handle packet info specifically for forensic log messages (have everything like seismic data but no channels)
 */
class PacketInfoProvider_ForensicLog : public PacketInfoProvider_DigitizerStartBased
{
public:
  PacketInfoProvider_ForensicLog(const std::shared_ptr<PSFLibrary>& library)
    : PacketInfoProvider_DigitizerStartBased(library, PDB_eVolumeID::VOLUME_FORENSIC_LOG)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual ~PacketInfoProvider_ForensicLog() = default;

  virtual const std::string& getChannelName(const sPacketSlice& packetSlice) const __OVERRIDES__(PacketInfoProvider_DigitizerStartBased)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(packetSlice.channelIndex == 0 && "No channels supported for logs -> only '0' should be set");
    const static std::string ret = "LOG";
    return ret;
  }
};

TxtLogWriterFilter::TxtLogWriterFilter(const std::shared_ptr<PSFLibrary>& library,
  const sHarvestParams& params,
  const uint32_t poolSize,
  const std::shared_ptr<ILogger>& logger)
  : IWriterFilter("TxtLogWritterFilter", params, poolSize, logger)
{
  __DEV_CALLSTACK_FUNC__;
  // register handlers to process PSF data
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PSF, HandlerFunc(&TxtLogWriterFilter::_processPSFData, this));
  // create packet info provider
  m_packetInfoProvider = std::make_shared<PacketInfoProvider_ForensicLog>(library);
}

TxtLogWriterFilter::~TxtLogWriterFilter()
{
  __DEV_CALLSTACK_FUNC__;
  // free TXT directory states (removes files contexts -> causes flushing to disk before removal)
  for (auto& it : m_dirStates)
  {
    delete (it.second);
  }
}

ErrorDataDesc* TxtLogWriterFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pConfig != nullptr && "pConfig cannot be nullptr here");
  m_packetInfoProvider->initialize(pConfig->sequenceRange);
  return IWriterFilter::run(pConfig);
}

void TxtLogWriterFilter::_createWorkers()
{
  __DEV_CALLSTACK_FUNC__;
  __TO_DO__("PGWU-401: add multiple workers support");
  const uint32_t nWorkers = 1;
  m_workers.reserve(nWorkers);
  for (uint32_t i = 0; i < nWorkers; ++i)
  {
    m_workers.push_back(std::make_shared<AsyncWorker_Functor>(m_dataQueue, m_results,
      AsyncWorker_Functor::Functor(&TxtLogWriterFilter::_workerFunc, this),
      m_logger));
  }
}

DataDescPtr TxtLogWriterFilter::_workerFunc(IAsyncWorker* pWorker, const DataDescPtr data)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_processDataImpl(data, pWorker);
}

DataDescPtr TxtLogWriterFilter::_processPSFData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data cannot be NULL here!");
  //tss_harv::create PDB log object and restore it from PSF data element
  PSFDataDesc* const pPSFData = static_cast<PSFDataDesc*>(data);
  std::shared_ptr<MsgForensicLog> const pLog = std::make_shared<MsgForensicLog>();
  PSFDataElement* const pDataElement = pPSFData->getElement();
  if (pLog && pLog->restore(pDataElement))
  {
    const sequence_number_t sequenceNumber = pDataElement->getHeader()->sequenceNumber;
    ErrorDataDesc* const pErrorData = this->_writeLog(pLog.get(), sequenceNumber);
    //tss_harv::if writing failed -> return error data
    if (pErrorData != nullptr)
      return pErrorData;
    // track element processed
    const uint32_t elementSize = PSF_PAGES_to_BYTES(pDataElement->getHeader()->sizeInPages);
    this->_trackElementProcessed(elementSize);
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Failed to retrieve information from Data Element");
  }

  // return progress data
  return this->_makeProgress();
}

TxtLogDirectoryState* TxtLogWriterFilter::_getDirectoryState(const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& outputDirectory = this->_getOutputDirectory(slice);
  const auto& foundIt = m_dirStates.find(outputDirectory);
  if (foundIt != m_dirStates.end())
  {
    return foundIt->second;
  }

  // create new directory state
  std::string workingDir = "";
  const std::string& outputDirFull = PlatformUtils::getInstance()->resolvePath(m_params.outputDir);
  //tss_harv::build full path for output miniSEED within this state (base path + decoded path)
  {
    const std::string& mergedFullPath = PlatformUtils::getInstance()->join(outputDirFull, outputDirectory);
    //tss_harv::trying to create base directory for mSEED files
    if (PlatformUtils::getInstance()->makePath(mergedFullPath))
    {
      //tss_harv::set decoded path as output path
      workingDir = mergedFullPath;
    }
    else
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to create '%s' path. Output path ('%s') will be used : %s",
        mergedFullPath.c_str(),
        outputDirFull.c_str(),
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      workingDir = outputDirFull;
    }
  }

  //tss_harv::creating new MiniSEED state
  const std::string& fileNamePattern = PlatformUtils::getInstance()->getBaseName(m_params.outputPattern);
  std::unique_ptr<TxtLogDirectoryState> newState(new TxtLogDirectoryState(workingDir, fileNamePattern, m_params.nHoursPerFile,
    m_packetInfoProvider, m_logger));
  //tss_harv::append new state to states map and return it
  if (m_dirStates.insert(std::make_pair(outputDirectory, newState.get())).second == false)
  {
    return nullptr;
  }
  return newState.release();
}

ErrorDataDesc* TxtLogWriterFilter::_writeLog(MsgForensicLog* pLog, const sequence_number_t sequenceNumber)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pLog != nullptr && "pLog cannot be nullptr here!");
  // get output directory state for the log
  sPacketSlice slice;
  {
    const MsgForensicLog::Header* const pHeader = pLog->getHeader();
    slice.sequenceNumber = sequenceNumber;
    slice.channelIndex = 0; // no channels for log messages -> use the same for all of them
    slice.timestamp = pHeader->timestamp;
    slice.dataSizeInBytes = pHeader->length;
    slice.data = pHeader->text;
    // the rest of parameters is meaningless
  }
  TxtLogDirectoryState* pState = this->_getDirectoryState(slice);
  if (pState == nullptr)
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Failed to retrieve directory state for log");
  }

  const size_t nBytesWritten = pState->writeSlice(slice, slice.isLast);
  if (nBytesWritten <= 0)
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Failed to write slice!");
  }

  // update progress
  {
    // track timerange
    this->_trackTimerange(slice.timestamp, slice.timestamp);
    // track files harvested
    m_progress.nFilesGenerated = 0u;
    for (const auto& state : m_dirStates)
    {
      m_progress.nFilesGenerated += state.second->getFilesCount();
    }
  }

  // return nullptr as no error indication
  return nullptr;
}

ErrorDataDesc* TxtLogWriterFilter::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->info(__THIS_FUNC__, "%lu messages harvested", m_progress.nElementsProcessed);
  return IWriterFilter::finalize(pReport);
}
