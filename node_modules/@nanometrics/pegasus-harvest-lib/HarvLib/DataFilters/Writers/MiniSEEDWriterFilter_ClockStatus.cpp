#define NOMINMAX

#include "MiniSEEDWriterFilter_ClockStatus.h"

#include "../../Utils/harvester_utils.h"

#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_Steim2.h"
#include "PacketInfoProvider_DigitizerStartBased.h"
#include "../AsyncWorker_Functor.h"

#include <Utils/pdb_utils.h>

#include <IOContext/io_contexts.h>
#include <PlatformUtils/PlatformUtils.h>

#include <libmseed.h>

#include <map>
#include <algorithm> //std::min
#include <climits>

namespace //anonymous
{
  // Derive Timing SOH parameter 'Clock Quality' at given output time.
  // Return value is a percentage within the range [0, 100].
  // A return value of 100 equates with best possible quality.
  FORCE_INLINE sample_t resample_VCQ(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t timestamp)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(timestamp >= latest.timestamp && "timestamp t should be not less then latest header timestamp!");
    // result is based on current duty cycle mode
    typedef int32_t(*ClockQualityFunc)(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& sampleRate, const timestamp_t t);
    static const std::map<MsgClockStatus::Header::eDutyCycle, ClockQualityFunc> clockQualityFuncMap = {
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_AUTOMATIC, &MsgClockStatus::getClockQuality_Automatic },
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_ALWAYS_ON, &MsgClockStatus::getClockQuality_AlwaysOn },
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_FREE_RUN,  &MsgClockStatus::getClockQuality_FreeRun },
    };
    const auto& foundIt = clockQualityFuncMap.find(latest.duty_cycle);
    __ASSERT__(foundIt != clockQualityFuncMap.end() && "eDutyCycle is not mapped!");
    return foundIt->second(latest, sampleRate, timestamp);
  }

  // The Pegasus - specific algorithm for computing Time Uncertainty at each output sample time is as follows(pseudo code) :
  // Derive Timing SOH parameter 'Time Uncertainty' at given output time.
  // Return value has units of microseconds.
  FORCE_INLINE sample_t resample_ATU(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t timestamp)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(timestamp >= latest.timestamp && "timestamp t should be not less then latest header timestamp!");
    // result is based on current duty cycle mode
    typedef int32_t(*TimeUncertaintyFunc)(const MsgClockStatus::Header& latest, const timestamp_t t);
    static const std::map<MsgClockStatus::Header::eDutyCycle, TimeUncertaintyFunc> timeUncertaintyFuncMap = {
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_AUTOMATIC, &MsgClockStatus::getTimeUncertainty_Automatic },
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_ALWAYS_ON, &MsgClockStatus::getTimeUncertainty_AlwaysOn },
      { MsgClockStatus::Header::eDutyCycle::DUTY_CYCLE_FREE_RUN,  &MsgClockStatus::getTimeUncertainty_FreeRun },
    };
    const auto& foundIt = timeUncertaintyFuncMap.find(latest.duty_cycle);
    __ASSERT__(foundIt != timeUncertaintyFuncMap.end() && "eDutyCycle is not mapped!");
    return foundIt->second(latest, timestamp);
  }

  FORCE_INLINE sample_t resample_VCE(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    // return system clock error in microseconds (seconds -> microseconds)
    return harvester_utils::clamp<sample_t>(std::round(latest.residual_meas * 1e+6f));
  }

  FORCE_INLINE sample_t resample_VPP(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return harvester_utils::clamp<sample_t>(pdb_utils::dop_to_fixed_point(latest.pdop));
  }

  FORCE_INLINE sample_t resample_VPH(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return harvester_utils::clamp<sample_t>(pdb_utils::dop_to_fixed_point(latest.hdop));
  }

  FORCE_INLINE sample_t resample_VPV(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return harvester_utils::clamp<sample_t>(pdb_utils::dop_to_fixed_point(latest.vdop));
  }

  FORCE_INLINE sample_t resample_VNS(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return static_cast<sample_t>(latest.n_satellites);
  }

  FORCE_INLINE sample_t resample_VLA(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    // degrees -> microdegrees
    return harvester_utils::clamp<sample_t>(std::round(latest.latitude * 1e+6)); // note: latitude is double precision
  }

  FORCE_INLINE sample_t resample_VLO(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    // degrees -> microdegrees
    return harvester_utils::clamp<sample_t>(std::round(latest.longitude * 1e+6)); // note: longitude is double precision
  }

  FORCE_INLINE sample_t resample_VEL(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    // GNSS elevation (meters -> centimeters)
    return harvester_utils::clamp<sample_t>(std::round(latest.altitude * 1e+2f));
  }

  FORCE_INLINE sample_t resample_VST(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return static_cast<sample_t>(latest.fix_status);
  }

  FORCE_INLINE sample_t resample_VPL(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    static const std::map<MsgClockStatus::Header::eClockStatus, ePLLStatus_t> pllStatusMap = {
      { MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_NO_LOCK,      ePLLStatus_t::PLL_STATUS_NO_LOCK },
      { MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_FREE_RUN,     ePLLStatus_t::PLL_STATUS_FREE_RUNNING },
      { MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_PARTIAL_LOCK, ePLLStatus_t::PLL_STATUS_COARSE_LOCK },
      { MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_FULL_LOCK,    ePLLStatus_t::PLL_STATUS_FINE_LOCK },
      { MsgClockStatus::Header::eClockStatus::CLOCK_STATUS_ALWAYS_ON,    ePLLStatus_t::PLL_STATUS_FINE_LOCK }
    };
    const auto& foundIt = pllStatusMap.find(latest.clock_status);
    __ASSERT__(foundIt != pllStatusMap.end() && "eClockStatus is not mapped!");
    return static_cast<sample_t>(foundIt->second);
  }

  FORCE_INLINE sample_t resample_VAN(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return static_cast<sample_t>(latest.antenna_status);
  }

  FORCE_INLINE sample_t resample_VCO(const MsgClockStatus::Header& latest, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return static_cast<sample_t>(latest.vcxo.control);
  }

  typedef sample_t(*ResampleFunc)(const MsgClockStatus::Header& /*latest*/, const PDB_sSampleRate_t& /*sampleRate*/, const timestamp_t /*timestamp*/);
  const struct ChannelInfo
  {
    const std::string name;
    const ResampleFunc resampler;
  } CHANNEL_INFOS[] =
  {
    { "VCQ", resample_VCQ }, //Clock quality
    { "ATU", resample_ATU }, //Time uncertainty
    { "VCE", resample_VCE }, //System clock error (residual meas)
    { "VPP", resample_VPP }, //GNSS engine PDOP value
    { "VPH", resample_VPH }, //GNSS engine HDOP value
    { "VPV", resample_VPV }, //GNSS engine VDOP value
    { "VNS", resample_VNS }, //GNSS number of satellites used
    { "VLA", resample_VLA }, //GNSS latitude
    { "VLO", resample_VLO }, //GNSS longitude
    { "VEL", resample_VEL }, //GNSS elevation (altitude)
    { "VST", resample_VST }, //GNSS position fix status
    { "VPL", resample_VPL }, //PLL status (clock_status)
    { "VAN", resample_VAN }, //GNSS antenna status
    { "VCO", resample_VCO }, //VCXO control setpoint
  };

  /*
    Sample rate for ClockStatus is MSG_CLOCK_STATUS_RESAMPLING_RATE -> 3600 * MSG_CLOCK_STATUS_RESAMPLING_RATE samples / hour
    assuming the worst compression (1x), we have 3600 * MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT datasets
    1st frame has 13 dataset for samples
    2nd and following - 15 datasets
    max(frames)/hour = 1 (for 13 datasets) + ceil( (3600 * MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT - 13) / 15 )
  */
  const uint32_t CLOCK_STATUS_STEIM_FRAMES_PER_HOUR_MAX = 1u + //1 frame for 13 samples/datasets (16 - 3 for first+last+compression datasets)
    (uint32_t)(pdb_utils::decode_sample_rate(MSG_CLOCK_STATUS_RESAMPLING_RATE) * 3600.0 - (steim::DATASETS_PER_FRAME - 3) - 1) / (steim::DATASETS_PER_FRAME - 1) + 1; //the remaining samples go to 15 datasets frames (16 - 1 for compression)

} // anonymous namespace

class PacketInfoProvider_ClockStatus : public PacketInfoProvider_DigitizerStartBased
{
public:
  PacketInfoProvider_ClockStatus(const std::shared_ptr<PSFLibrary>& library)
    : PacketInfoProvider_DigitizerStartBased(library, PDB_eVolumeID::VOLUME_CLOCK_STATUS)
    , m_unknownLocation("")
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual ~PacketInfoProvider_ClockStatus() = default;

  // override only these two methods
  virtual const std::string& getChannelName(const sPacketSlice& packetSlice) const __OVERRIDES__(PacketInfoProvider_DigitizerStartBased)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(packetSlice.channelIndex < NUM_ELEMENTS(CHANNEL_INFOS) && "channel index is out of range");
    return CHANNEL_INFOS[packetSlice.channelIndex].name;
  }
  virtual const std::string& getChannelLocation(const sPacketSlice& /*packetSlice*/) const __OVERRIDES__(PacketInfoProvider_DigitizerStartBased)
  {
    __DEV_CALLSTACK_FUNC__;
    __TO_DO__("Provide some valid location for ClockStatus when available");
    return m_unknownLocation;
  }

private:
  std::string m_unknownLocation;
};

class Steim2Synthesizer_Delegate : public IMiniSEEDRecordsSynthesizerDelegate
{
public:
  Steim2Synthesizer_Delegate(std::vector<MiniSEEDRecordData>& output,
    const std::shared_ptr<ILogger>& logger)
    : IMiniSEEDRecordsSynthesizerDelegate(logger)
    , m_output(output)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual void onRecordReady(const MiniSEEDRecordData& recordData) __OVERRIDES__(IMiniSEEDRecordsSynthesizerDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_output.emplace_back(recordData);
  }

private:
  std::vector<MiniSEEDRecordData>& m_output;
};

MiniSEEDWriterFilter_ClockStatus::MiniSEEDWriterFilter_ClockStatus(const std::shared_ptr<PSFLibrary>& library,
  const sHarvestParams& params,
  const uint32_t poolSize,
  const std::shared_ptr<ILogger>& logger)
  : IWriterFilter("MiniSEEDWriterFilter_ClockStatus", params, poolSize, logger)
  , m_msgClockStatusPool(new mem_pool_allocator_new<MsgClockStatus()>(), logger)
  , m_bFirstPacketReceived(false)
  , m_nFramesPerRecordMax(std::min<uint32_t>(MAX_FRAMES_PER_RECORD,
      CLOCK_STATUS_STEIM_FRAMES_PER_HOUR_MAX * params.nHoursPerFile))
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_params.nHoursPerFile > 0 && "nHoursPerFile per file must be > 0");
  // register handlers to process PSF data
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PSF, HandlerFunc(&MiniSEEDWriterFilter_ClockStatus::_processPSFData, this));

  //tss_harvlib::allocate memory pool for packets
  m_msgClockStatusPool.allocate(poolSize + 1);

  const uint32_t nChannels = NUM_ELEMENTS(CHANNEL_INFOS);
  m_inputStates.reserve(nChannels);
  //create synthesizers for each input
  for (uint32_t input = 0; input < nChannels; ++input)
  {
    m_inputStates.push_back(ClockStatusState());
    ClockStatusState& state = m_inputStates.back();
    state.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_Steim2>(
      std::make_shared<buffer_malloc<SteimFrame_t>>(m_nFramesPerRecordMax),
      std::make_shared<Steim2Synthesizer_Delegate>(state.recordsQueue, m_logger), //create delegate to collect compressed packets in its specific queue
      true, // generate big-endian frames
      m_logger);
  }
  // create packets info provider
  m_packetInfoProvider = std::make_shared<PacketInfoProvider_ClockStatus>(library);
}

MiniSEEDWriterFilter_ClockStatus::~MiniSEEDWriterFilter_ClockStatus()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::free miniSEED states
  for (auto& it : m_mseedStates)
  {
    delete (it.second);
  }
}

ErrorDataDesc* MiniSEEDWriterFilter_ClockStatus::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pConfig != nullptr && "pConfig cannot be nullptr here");
  m_packetInfoProvider->initialize(pConfig->sequenceRange);
  return IWriterFilter::run(pConfig);
}

void MiniSEEDWriterFilter_ClockStatus::_createWorkers()
{
  __DEV_CALLSTACK_FUNC__;
  __TO_DO__("PGWU-400: add multiple workers support");
  const uint32_t nWorkers = 1;
  m_workers.reserve(nWorkers);
  for (uint32_t i = 0; i < nWorkers; ++i)
  {
    m_workers.push_back(std::make_shared<AsyncWorker_Functor>(m_dataQueue, m_results,
      AsyncWorker_Functor::Functor(&MiniSEEDWriterFilter_ClockStatus::_workerFunc, this),
      m_logger));
  }
}

DataDescPtr MiniSEEDWriterFilter_ClockStatus::_workerFunc(IAsyncWorker* pWorker, const DataDescPtr data)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_processDataImpl(data, pWorker);
}

DataDescPtr MiniSEEDWriterFilter_ClockStatus::_processPSFData(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  //tss_harv::retrieve PDB object from data and check its type
  PSFDataDesc* const pPSFData = static_cast<PSFDataDesc*>(data);
  PSFDataElement* const pDataElement = pPSFData->getElement();
  if (pDataElement != nullptr)
  {
    MsgClockStatus* const pPacket = m_msgClockStatusPool.new_object();
    if (pPacket && pPacket->restore(pDataElement))
    {
      const sequence_number_t sequenceNumber = pDataElement->getHeader()->sequenceNumber;
      ErrorDataDesc* const pErrorData = this->_processPacket(pPacket, sequenceNumber, userData);
      if (pErrorData != nullptr)
        return pErrorData;
      // track element processed
      const uint32_t elementSize = PSF_PAGES_to_BYTES(pDataElement->getHeader()->sizeInPages);
      this->_trackElementProcessed(elementSize);
    }
    else
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to retrieve information from Data Element");
    }
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "PSFDataElement invalid handle");
  }

  // return progress data
  return this->_makeProgress();
}

MiniSEEDDirectoryState* MiniSEEDWriterFilter_ClockStatus::_getDirectoryState(const sPacketSlice& packetSlice)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::get unique state code for the packet
  const std::string& outputDirectory = this->_getOutputDirectory(packetSlice);
  //tss_harv::find if the state is already created
  const auto foundIt = m_mseedStates.find(outputDirectory);
  if (foundIt != m_mseedStates.end())
    return foundIt->second;

  std::string workingDir = "";
  const std::string& outputDirFull = PlatformUtils::getInstance()->resolvePath(m_params.outputDir);
  //tss_harv::build full path for output miniSEED within this state (base path + decoded path)
  {
    const std::string& mergedFullPath = PlatformUtils::getInstance()->join(outputDirFull, outputDirectory);
    //tss_harv::trying to create base directory for mSEED files
    if (PlatformUtils::getInstance()->makePath(mergedFullPath))
    {
      //tss_harv::set decoded path as output path
      workingDir = mergedFullPath;
    }
    else
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to create '%s' path. Output path ('%s') will be used : %s",
        mergedFullPath.c_str(),
        outputDirFull.c_str(),
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      workingDir = outputDirFull;
    }
  }

  //tss_harv::creating new MiniSEED state
  const std::string& fileNamePattern = PlatformUtils::getInstance()->getBaseName(m_params.outputPattern);
  //tss_harv::detect amount of channels per file (If ${C} mnemonic persists -> each channel is in it's own file, otherwise - multiple channels per file)
  const uint32_t nChannels = static_cast<uint32_t>(m_inputStates.size());
  const uint8_t nChannelsPerFile = m_mnemonicsDecoder->hasMnemonic("${C}") ? 1 : nChannels;
  std::unique_ptr<MiniSEEDDirectoryState> newStatePtr(new MiniSEEDDirectoryState(workingDir, fileNamePattern,
    m_params.nHoursPerFile, nChannelsPerFile, nChannels,
    m_nFramesPerRecordMax, //set fixed frames count
    m_packetInfoProvider, m_logger));

  //tss_harv::append new state to states map and return it
  m_mseedStates.insert(std::make_pair(outputDirectory, newStatePtr.get()));
  return newStatePtr.release();
}

ErrorDataDesc* MiniSEEDWriterFilter_ClockStatus::_processPacket(const MsgClockStatus* pPacket, const sequence_number_t sequenceNumber, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pPacket != nullptr && "pPacket cannot be nullptr here!");
  //__ASSERT__(userData != nullptr && "method expects IAsyncWOrker passed through the userData here!");
  const MsgClockStatus::Header* const pHeader = pPacket->getHeader();
  //save last/previous header if not set yet (required for resampling logic). This packet should have timestamp <= lowerBound
  if (!m_bFirstPacketReceived)
  {
    ::memcpy(&m_latestHeader, pHeader, sizeof(MsgClockStatus::Header));
    m_bFirstPacketReceived = true;
    return nullptr;
  }

  //resample all the data from the previous record till current
  ErrorDataDesc* const pError = this->_resample(m_latestHeader, sequenceNumber, pHeader->timestamp, MSG_CLOCK_STATUS_RESAMPLING_RATE);
  if (pError != nullptr)
  {
    return pError;
  }

  // update progress
  {
    m_progress.nFilesGenerated = 0u;
    for (const auto& state : m_mseedStates)
    {
      m_progress.nFilesGenerated += state.second->getFilesCount();
    }
  }

  //save current header as the last
  ::memcpy(&m_latestHeader, pHeader, sizeof(MsgClockStatus::Header));
  //report no error
  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_ClockStatus::_resample(const MsgClockStatus::Header& prev,
  const sequence_number_t sequenceNumber, const timestamp_t upperBound, const PDB_sSampleRate_t& sampleRate)
{
  __DEV_CALLSTACK_FUNC__;
  // adjust slicing ranges with respect to global time bounds (for the first and last sequence indices)
  const timestamp_t lower = (sequenceNumber == m_targetRange.lower) ?
      std::max<timestamp_t>(prev.timestamp, m_params.lower.time) :
      prev.timestamp;
  const timestamp_t upper = (sequenceNumber == m_targetRange.upper) ?
      std::min<timestamp_t>(upperBound, m_params.upper.time) :
      upperBound;

  //get slicing parameters
  const timediff_t sliceLengthNs = static_cast<timediff_t>(pdb_utils::hours_to_nanoseconds(m_params.nHoursPerFile));
  const timediff_t sampleStepNs = pdb_utils::get_packet_duration_nanoseconds(1, sampleRate);

  //do resampling
  {
    //'start sample time' should be aligned to 'resampling rate' and do not commence before 'lower'
    timestamp_t sampleTimestamp = harvester_utils::get_slice_index(lower, sampleStepNs) * sampleStepNs; //lower aligned bound
    //adjust 'sample start time' if it is before 'lower'
    if (sampleTimestamp < lower)
      sampleTimestamp += sampleStepNs;

    const uint32_t nChannels = static_cast<uint32_t>(m_inputStates.size());
    //do resampling till sample timestamp hits upper bound
    while (sampleTimestamp < upper)
    {
      for (uint8_t input = 0; input < nChannels; ++input)
      {
        const ChannelInfo& channelInfo = CHANNEL_INFOS[input];
        ClockStatusState& inputState = m_inputStates[input];
        //check & update input slice
        sPacketSlice& slice = inputState.slice;
        slice.sequenceNumber = sequenceNumber;
        //initialize an empty slice
        if (slice.nSamples == 0)
        {
          slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
          slice.channelIndex = input;
          slice.timestamp = sampleTimestamp;
          slice.expectedTimestamp = sampleTimestamp;
          slice.sampleRate = sampleRate;
          slice.isLast = false;
        }

        //check slice's boundaries for sample
        {
          const timestamp_t sliceUpperTime = static_cast<int64_t>(slice.sliceIndex + 1) * sliceLengthNs;
          const bool upperBoundIsHit = (sampleTimestamp >= sliceUpperTime);
          //if sample hits upper slice's bound -> finalize record immediately, current sample will go to the next record/slice (file)
          if (upperBoundIsHit)
          {
            slice.isLast = true;
            inputState.synthesizer->flush(); //this should produce the record in channel state records queue
          }
        }

        //resample value
        {
          __ASSERT__(channelInfo.resampler != nullptr && "resample function is not set for channel!");
          // call resample function
          const sample_t sampleVal = channelInfo.resampler(m_latestHeader, sampleRate, sampleTimestamp);
          // add sample
          inputState.synthesizer->addSample(sampleVal);
        }

        //process Steim queue for channel. Record can be caused by 'flush' call on synnthesizer or when max frames reached. If processed - slice gets emptified
        ErrorDataDesc* const pErrorDesc = this->_processSteimQueue(inputState);
        if (pErrorDesc != nullptr)
        {
          return pErrorDesc;
        }
        //if slice is empty -> start new slice at the current sample
        if (slice.nSamples == 0)
        {
          slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
          slice.channelIndex = input;
          slice.timestamp = sampleTimestamp;
          slice.expectedTimestamp = sampleTimestamp;
          slice.sampleRate = sampleRate;
          slice.isLast = false;
        }

        //update samples count covered by slice
        slice.nSamples++;

        // update processed range upper time
        this->_trackTimerange(slice);
      }

      //step up to the next sample for specified sample rate
      sampleTimestamp += sampleStepNs;
    }
  }

  //return nullptr - no error indication
  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_ClockStatus::_processSteimQueue(ClockStatusState& state)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(state.recordsQueue.size() <= 1 && "Queue can have only 1 packet max at a time due to real time compression!");
  if (!state.recordsQueue.empty())
  {
    //get this steim frame
    const MiniSEEDRecordData& record = state.recordsQueue.front();
    //build slice info
    sPacketSlice& slice = state.slice;
    {
      __ASSERT__(slice.nSamples == record.nSamples && "Sanity check failed. Slice and MiniSEED record are not synced!");
      slice.mediaType = record.mediaType;
      slice.nFramesCompressed = record.nFrames;
      slice.data = record.data;
      slice.dataSizeInBytes = record.dataSizeInBytes;
      slice.isBigEndian = record.isBigEndian;
    }
    //get directory state to append slice to
    MiniSEEDDirectoryState* const pState = this->_getDirectoryState(slice);
    const size_t nBytesWritten = pState->writeSlice(slice, slice.isLast);
    if (nBytesWritten <= 0)
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to write slice!");
    }
    //free up the queue
    state.recordsQueue.clear();

    //discard the slice (mark as empty) to let it be reset
    slice.nSamples = 0;
  }

  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_ClockStatus::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  m_bFinishRequested = true;
  //tss_harv::stop waiting for data
  m_dataQueue.stop_waiting();
  //tss_harv::wait till finalized
  this->_finishWorkers(true);
  //tss_harv::process results that might remain in the results queue
  this->_processResults();

  //flush each input's data
  for (auto& state : m_inputStates)
  {
    state.synthesizer->flush();
    this->_processSteimQueue(state);
  }
  return IWriterFilter::finalize(pReport);
}
