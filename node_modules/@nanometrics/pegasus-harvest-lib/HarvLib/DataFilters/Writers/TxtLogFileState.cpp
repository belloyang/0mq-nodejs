#include "TxtLogFileState.h"

#include <PlatformUtils/PlatformUtils.h>
#include <IOContext/io_contexts.h>

TxtLogFileState::TxtLogFileState(const std::string& name, const std::shared_ptr<ILogger>& logger)
  : m_name(name)
  , m_recordOffset(0ull)
  , m_context(nullptr)
  , m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

void TxtLogFileState::createContext(const std::string& workingDir, const uint32_t cacheSize)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_context == nullptr && "context already created");
  //tss_harv::get output filename for the packet & build the full output path for the file
  const std::string& filePath = PlatformUtils::getInstance()->join(workingDir, m_name);
#if defined(DEV_PLATFORM_LINUX)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(filePath, O_WRONLY | O_CREAT | O_APPEND | O_LARGEFILE, m_logger);
#elif defined(DEV_PLATFORM_MACOS)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(filePath, O_WRONLY | O_CREAT | O_APPEND, m_logger);
#elif defined(DEV_PLATFORM_WIN32)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_Windows>(filePath, FILE_APPEND_DATA, 0, OPEN_ALWAYS, m_logger);
#endif
  //tss_harv::create buffered I/O context
  m_context = std::make_shared<BufferedIOContext>(fileContext,
    0 /*no cache for reading as we are only writing to TXT files*/,
    cacheSize,
    m_logger);
}

void TxtLogFileState::finishRecord(const uint32_t recordLen)
{
  __DEV_CALLSTACK_FUNC__;
  m_recordOffset += recordLen;
}
