#include "MiniSEEDDirectoryState.h"

#include <Utils/pdb_utils.h>

#include "../../Utils/harvester_utils.h"

#include "../../steim/steim1.h"
#include "../../steim/steim2.h"

#include <algorithm>
#include <cinttypes>

MiniSEEDDirectoryState::MiniSEEDDirectoryState(const std::string& workingDir, const std::string& fileNamePattern,
  const uint32_t nHoursPerFile, const uint8_t nChannelsPerFile, const uint8_t maxChannels,
  const uint32_t fixedSteimFramesCount,
  const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider,
  const std::shared_ptr<ILogger>& logger)
: m_workingDir(workingDir)
, m_fileNamePattern(fileNamePattern)
, m_nChannelsPerFile(nChannelsPerFile)
, m_nFixedSteimFrames(fixedSteimFramesCount)
, m_recordLen(1U)
, m_recordLenPowOf2Base(0U)
, m_packetInfoProvider(packetInfoProvider)
, m_logger(logger)
, m_miniSEEDWriteCacheSize(4 * 1024 * 1024/*4MiB cache*/)
, m_mnemonicsDecoder(new MnemonicsDecoder(fileNamePattern, packetInfoProvider, pdb_utils::hours_to_nanoseconds(nHoursPerFile), logger))
, m_nFilesGenerated(0)
, m_zeroBuffer(nullptr)
, m_swappedBuffer(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_nFixedSteimFrames != 0u && "m_nFixedSteimFrames cannot be 0");
  const uint32_t miniSeedDataOfset = 64u; //64 bytes offset from header start for miniSEED data (required for Steim2)
  // verify if data can be written after the miniSEED start structure sequentially
  __STATIC_ASSERT__(miniSeedDataOfset == sizeof(sChannelState::MiniSEEDRecordStart),
      "miniSEEDRecordStart structure is designed to take all the space in miniSEED before the seismic data "
      "to simulate sequential writing (miniSEED header + data) required for write caching");

  // init channel states for each channel
  m_channelStates.reserve(maxChannels);
  for (uint32_t channel = 0; channel < maxChannels; ++channel)
  {
    sChannelState* const pChannelState = new sChannelState();
    pChannelState->channel = channel;
    // init fixed section header (static data -> the same for all the compressions, channels, etc.)
    {
      fsdh_s& fixedHeader = pChannelState->miniSEEDRecordStart.fixedHeader;
      ::memset(&fixedHeader, 0, sizeof(fsdh_s));
      fixedHeader.dataquality = 'D'; //! data quality (data)
      fixedHeader.reserved = ' '; //! reserved data (space)

      //tss_harv::init offsets (to blockettes and data)
      fixedHeader.data_offset = endianness_utils::swap<uint16_t>(miniSeedDataOfset);
      fixedHeader.numblockettes = 2; // we dump 2 blockettes (#1000, #1001)
      fixedHeader.blockette_offset = endianness_utils::swap<uint16_t>(sizeof(fsdh_s)); //(48 bytes) blockettes commence right after the fixed header
    }
    // init blockette #1000
    {
      auto& blkt = pChannelState->miniSEEDRecordStart.blkt1000;
      blkt.info[0] = endianness_utils::swap(blkt.info[0]);
      blkt.info[1] = endianness_utils::swap(blkt.info[1]);
      blkt.data.byteorder = 1; //stands for big-endian, as we have to generate big-endian miniSEED files
      blkt.data.reserved = ' ';
    }
    // init blockette #1001
    {
      auto& blkt = pChannelState->miniSEEDRecordStart.blkt1001;
      blkt.info[0] = endianness_utils::swap(blkt.info[0]);
      blkt.info[1] = endianness_utils::swap(blkt.info[1]);
      blkt.data.reserved = ' ';
    }
    m_channelStates.push_back(pChannelState);
  }

  // calculate record len, pow of 2 base & allocate zero buffer
  {
    // calculate maximum data size
    const uint32_t actualDataSize = miniSeedDataOfset + m_nFixedSteimFrames * sizeof(SteimFrame_t); //64 bytes for offset + frames size
    //calculate powOf2 ceiling value (recordSize) and it's base (log2). While loop + BSL serves this purpose better then Furie series put behind ::log2(double)
    m_recordLen = 1;
    {
      while (m_recordLen < actualDataSize)
      {
        m_recordLen <<= 1;
        m_recordLenPowOf2Base++;
      }
    }
    m_zeroBuffer = std::make_shared<buffer_malloc<char>>(m_recordLen); //allocate buffer big enough to fill up the entire record in the single write operation
    //tss_harvlib::fill up the buffer with zeros
    m_zeroBuffer->clear();
  }

  // create buffer for swapped steim frames data
  m_swappedBuffer = std::make_shared<buffer_malloc<char>>(m_recordLen);
}

MiniSEEDDirectoryState::~MiniSEEDDirectoryState()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::free up files states
  for (const auto& fileState : m_fileStates)
  {
    delete fileState.second;
  }
  //tss_harv::free up channels states
  for (const auto& channelState : m_channelStates)
  {
    delete channelState;
  }
}

std::string MiniSEEDDirectoryState::_getOutputFileName(const sPacketSlice& slice) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string decodedPath;
  if (m_mnemonicsDecoder->decode(slice, decodedPath) != (size_t)-1) {
    return decodedPath;
  }

  //tss_harv::decoding failed -> return "" (data will be dumped right into base folder)
  m_logger->warning(__THIS_FUNC__, "Failed to decode '%s'. Base name for miniSEED files won't be set (\"\")", m_fileNamePattern.c_str());
  return std::string("");
}

MiniSEEDFileState* MiniSEEDDirectoryState::_getFileState(const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  // lock resources here (fileStates array and MnemonicsDecoder used in _getOutputFileName)
  std::lock_guard<std::mutex> lock(m_mutex);
  //tss_harvlib::build filename for packet
  const std::string& outputFileName = this->_getOutputFileName(slice);
  //tss_harvlib::find filestate for this filename
  const auto foundIt = m_fileStates.find(outputFileName);
  if (foundIt != m_fileStates.end())
  {
    return foundIt->second;
  }

  //tss_harv::creating new file state
  std::unique_ptr<MiniSEEDFileState> newFileStatePtr(new MiniSEEDFileState(outputFileName, m_nChannelsPerFile, m_logger));
  {
    //tss_harvlib::PGWU-210: create file context (!!allows to append to existing files)
    newFileStatePtr->createContext(m_workingDir, m_miniSEEDWriteCacheSize);
  }
  if (m_fileStates.insert(std::make_pair(newFileStatePtr->getName(), newFileStatePtr.get())).second == false)
  {
    return nullptr;
  }

  m_nFilesGenerated++;
  return newFileStatePtr.release();
}

void MiniSEEDDirectoryState::_deleteFileState(const std::string& filename)
{
  __DEV_CALLSTACK_FUNC__;
  std::lock_guard<std::mutex> lock(m_mutex);
  const auto& foundIt = m_fileStates.find(filename);
  __ASSERT__(foundIt != m_fileStates.end() && "File state wasn't found!");
  delete foundIt->second;
  m_fileStates.erase(foundIt);
}


size_t MiniSEEDDirectoryState::writeSlice(const sPacketSlice& slice, const bool bCompletesChannel)
{
  __DEV_CALLSTACK_FUNC__;
  //get channel state for slice's channel
  sChannelState* const pChannelState = m_channelStates[slice.channelIndex];
  MiniSEEDFileState* const pFileState = this->_getFileState(slice);
  fsdh_s& fixedHeader = pChannelState->miniSEEDRecordStart.fixedHeader;

  // Get start time rounded to tenths of milliseconds and microsecond offset
  const hptime_t starttime = pdb_utils::nanoseconds_to_microseconds(slice.timestamp);
  hptime_t hptimems = 0; int8_t usecoffset = 0;
  ms_hptime2tomsusecoffset(starttime, &hptimems, &usecoffset);

  // build fixed header
  {
    // init station & location & channel & network
    const std::string& station = m_packetInfoProvider->getStation(slice);
    ::memset(fixedHeader.station, ' ', sizeof(fixedHeader.station));
    ::memcpy(fixedHeader.station, station.c_str(), std::min<size_t>(sizeof(fixedHeader.station), station.length()));

    const std::string& location = m_packetInfoProvider->getChannelLocation(slice);
    ::memset(fixedHeader.location, ' ', sizeof(fixedHeader.location));
    ::memcpy(fixedHeader.location, location.c_str(), std::min<size_t>(sizeof(fixedHeader.location), location.length()));

    const std::string& channelName = m_packetInfoProvider->getChannelName(slice);
    ::memset(fixedHeader.channel, ' ', sizeof(fixedHeader.channel));
    ::memcpy(fixedHeader.channel, channelName.c_str(), std::min<size_t>(sizeof(fixedHeader.channel), channelName.length()));

    const std::string& network = m_packetInfoProvider->getNetwork(slice);
    ::memset(fixedHeader.network, ' ', sizeof(fixedHeader.network));
    ::memcpy(fixedHeader.network, network.c_str(), std::min<size_t>(sizeof(fixedHeader.network), network.length()));

    // set samples count
    fixedHeader.numsamples = endianness_utils::swap<uint16_t>(slice.nSamples);
    // set and normalize sample rate
    fixedHeader.samprate_fact = endianness_utils::swap<int16_t>(slice.sampleRate.details.factor);
    fixedHeader.samprate_mult = endianness_utils::swap<int16_t>(slice.sampleRate.details.multiplier);
    if (fixedHeader.samprate_mult == 0)
    {
      fixedHeader.samprate_mult =  endianness_utils::swap<int16_t>(1);
    }

    // Update fixed-section start time (in tenth of millisconds precision)
    ms_hptime2btime(hptimems, &(fixedHeader.start_time));
    fixedHeader.start_time.year = endianness_utils::swap(fixedHeader.start_time.year);
    fixedHeader.start_time.day = endianness_utils::swap(fixedHeader.start_time.day);
    fixedHeader.start_time.fract = endianness_utils::swap(fixedHeader.start_time.fract);

    // set sequence number
    char buff[7] = { 0 };
    ::snprintf(buff, 7, "%06u", pChannelState->sequenceNumber);
    ::memcpy(fixedHeader.sequence_number, buff, 6);
  }

  // update blockette #1000
  {
    blkt_1000_s& blkt = pChannelState->miniSEEDRecordStart.blkt1000.data;
    blkt.reclen = m_recordLenPowOf2Base;
    blkt.encoding = harvester_utils::map_media_type_to_mseed_encoding(slice.mediaType);
  }
  // update blockette #1001
  {
    blkt_1001_s& blkt = pChannelState->miniSEEDRecordStart.blkt1001.data;
    // set microseconds offset
    blkt.usec = usecoffset;
    // set frames count
    blkt.framecnt = slice.nFramesCompressed;
    // set timing quality
    __TO_DO__("PGFW-1063: set timing quality value properly");
    blkt.timing_qual = 100;
  }
  
  size_t bytesWritten = 0;
  // dump slice to file state
  {
    // dump data
    bytesWritten += this->_writeData(pChannelState, pFileState, slice);
    // if we have any further slices to write -> mark file's channel as filled as the following slices will go to the next file
    if (bCompletesChannel)
    {
      // finish channel
      if (pFileState->finishChannel() <= 0)
      {
        const std::string& filename = pFileState->getName();
        this->_deleteFileState(filename);
      }
      // discard samples count
      pChannelState->nSamples = 0u;
    }
  }

  // return total data size written (in bytes)
  return bytesWritten;
}

size_t MiniSEEDDirectoryState::_writeData(sChannelState* pChannelState, MiniSEEDFileState* pFileState, const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pChannelState != nullptr && "pChannelState cannot be nullptr here");
  __ASSERT__(pFileState != nullptr && "pFileState cannot be nullptr here. New should be created if doesn't exist");
  const fsdh_s& fixedHeader = pChannelState->miniSEEDRecordStart.fixedHeader;
  // calculate record length and log2(recordLen)
  // max record length = 1048576 (MAXRECLEN) so the way more then uncompressed Steim2 frame can have
  const uint32_t actualDataSize = endianness_utils::swap(fixedHeader.data_offset) + slice.dataSizeInBytes;
  __ASSERT__(actualDataSize <= MAXRECLEN && "Data size exceeds maximum record length for Steim");
  // dump miniSEED record start (fixed header, blockette info, blockette data)
  const io_offset_t recordOffset = pFileState->getRecordOffset();
  const std::shared_ptr<IIOContext>& context = pFileState->getContext();
  context->writeBlock(recordOffset, sizeof(pChannelState->miniSEEDRecordStart), &pChannelState->miniSEEDRecordStart);

  // dump data
  {
    __ASSERT__((slice.dataSizeInBytes % 4 == 0) && "the data should be array of 4 bytes values (32-bits datasets or int32_t raw samples");
    io_offset_t offset = recordOffset + endianness_utils::swap(fixedHeader.data_offset);
    if (slice.isBigEndian) // write data as is (it's already big-endian)
    {
      offset += context->writeBlock(offset, slice.dataSizeInBytes, slice.data);
    }
    else // swap data (little -> big endian)
    {
      m_logger->debug(__THIS_FUNC__, "Swapping record (media_type=%" PRIu32 ") to big-endian", static_cast<uint32_t>(slice.mediaType));
      switch (slice.mediaType)
      {
        case PDB_eMediaType_t::MEDIA_UNCOMPRESSED:
        {
          const uint32_t* inPtr = reinterpret_cast<const uint32_t*>(slice.data);
          uint32_t* outPtr = m_swappedBuffer->ptr<uint32_t>();
          for (uint32_t i = 0; i < slice.dataSizeInBytes >> 2u; ++i)
          {
            *(outPtr++) = endianness_utils::swap(*(inPtr++));
          }
        }
        break;

        case PDB_eMediaType_t::MEDIA_STEIM1:
        {
          const SteimFrame_t* inPtr = reinterpret_cast<const SteimFrame_t*>(slice.data);
          SteimFrame_t* outPtr = m_swappedBuffer->ptr<SteimFrame_t>();
          steim1::toBigEndian(inPtr, slice.nFramesCompressed, outPtr);
        }
        break;

        case PDB_eMediaType_t::MEDIA_STEIM2:
        {
          const SteimFrame_t* inPtr = reinterpret_cast<const SteimFrame_t*>(slice.data);
          SteimFrame_t* outPtr = m_swappedBuffer->ptr<SteimFrame_t>();
          steim2::toBigEndian(inPtr, slice.nFramesCompressed, outPtr);
        }
        break;

        default:
          __ASSERT__(false && "unhandled media type case");
      }
      // write swapped data
      offset += context->writeBlock(offset, slice.dataSizeInBytes, m_swappedBuffer->ptr());
    }
    // end up the record with zeroes
    const size_t afterDataSpan = (m_recordLen - actualDataSize);
    if (afterDataSpan > 0)
    {
      __ASSERT__(afterDataSpan <= m_zeroBuffer->size() && "'zeroBuffer' is not big enough!");
      context->writeBlock(offset, afterDataSpan, m_zeroBuffer->ptr<char>());
    }
  }
  // update channel state
  const uint32_t SEED_SEQ_NUM_LIMIT = 1000000u; // 6 significant figures
  pChannelState->sequenceNumber = (pChannelState->sequenceNumber + 1) % SEED_SEQ_NUM_LIMIT;
  pChannelState->nSamples += slice.nSamples;

  // finish record
  pFileState->finishRecord(m_recordLen);

  return m_recordLen;
}
