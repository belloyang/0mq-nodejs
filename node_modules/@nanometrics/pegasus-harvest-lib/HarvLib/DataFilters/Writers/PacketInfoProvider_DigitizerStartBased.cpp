#include "PacketInfoProvider_DigitizerStartBased.h"

#include <DataTypes/DigitizerOperationLog/MsgDigitizerStart.h>

#include <Library/PSFStream.h>

#include <limits>
#include <ctime>
#include <cinttypes>
#include <cstring>

namespace
{
  const char THIS_CLASS_NAME[] = "PacketInfoProvider_DigitizerStartBased";
}

PacketInfoProvider_DigitizerStartBased::PacketInfoProvider_DigitizerStartBased(const std::shared_ptr<PSFLibrary>& library,
  const uint32_t volumeID)
  : IPacketInfoProvider()
  , m_library(library)
  , m_volumeID(volumeID)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_library != nullptr && "'library' cannot be nullptr here");
}

void PacketInfoProvider_DigitizerStartBased::initialize(const sSequenceRange& sequenceRange)
{
  __DEV_CALLSTACK_FUNC__;
  const std::shared_ptr<IHasher>& hasher = m_library->getHasher();
  const std::shared_ptr<ILogger>& logger = m_library->getLogger();
  std::unique_ptr<PSFVolume> volume(m_library->findVolumeByID(PDB_eVolumeID::VOLUME_OPERATION_LOG));
  if (volume == nullptr)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND,
      "Failed to find VOLUME_OPERATION_LOG(id=%u) volume in library", (uint32_t)PDB_eVolumeID::VOLUME_OPERATION_LOG);
    return;
  }
  // create volume's stream
  PSFStream stream(volume.get(), logger);
  PSFDataElement dataElement(hasher, logger);
  MsgDigitizerStart digitizerStart;
  bool lastDigitizerStartFound = false;
  while (!stream.is_eof() && !lastDigitizerStartFound)
  {
    // read only DigitizerStart messages
    if ((stream.readNext(dataElement) > 0) && (dataElement.isInstanceOf(MSG_DIGITIZER_START_V0)) && digitizerStart.restore(&dataElement))
    {
      const MsgDigitizerStart::Header* const pHeader = digitizerStart.getHeader();
      // find sequence index for required volume ref
      const PDB_sVolumeRefIndex_t& index = pHeader->index;
      for (uint32_t refIdx = 0u; refIdx < index.n_refs; ++refIdx)
      {
        const PDB_sVolumeRef_t& volumeRef = index.refs[refIdx];
        if (volumeRef.volume_id == m_volumeID)
        {
          // check if configuration applies to the data after requested range -> stop fetching configurations
          if (volumeRef.sequence > sequenceRange.upper)
          {
            lastDigitizerStartFound = true;
            break;
          }
          // build start info
          const DigitizerStartInfo& startInfo = PacketInfoProvider_DigitizerStartBased::_buildStartInfo(volumeRef.sequence, pHeader, logger);
          // if configuration was active before the requested range -> make it the very first
          if (startInfo.startSequence <= sequenceRange.lower)
          {
            m_startInfo.clear();
            m_startInfo.emplace_back(startInfo);
          }
          // configuration is inside requested range -> check if it has changed from the previous saved
          else if (m_startInfo.empty() || !_isEqual(m_startInfo.back(), startInfo))
          {
            m_startInfo.emplace_back(startInfo);
          }
          break;
        }
      }
    }
  }

  // if data for 0-th sequence not found -> generate dummy/default data to use (at the beginning)
  if (m_startInfo.empty() || m_startInfo.front().startSequence != 0u)
  {
    DigitizerStartInfo unknown;
    m_startInfo.insert(m_startInfo.begin(), unknown);
  }

  uint32_t startInfoIndex = 0u;
  for (const auto& info : m_startInfo)
  {
    logger->debug(THIS_CLASS_NAME, "Start info #%" PRIu32 " for volumeID=%" PRIu32 ":\n"
      "   start sequence = %" PRIu32 "\n"
      "   network = '%s'\n"
      "   station = '%s'\n"
      "   n_channels = %" PRIu32,
      startInfoIndex++, m_volumeID,
      info.startSequence,
      info.network.c_str(),
      info.station.c_str(),
      static_cast<uint32_t>(info.nChannels));
    for (uint8_t channelIdx = 0; channelIdx < info.nChannels; ++channelIdx)
    {
      const auto& channelInfo = info.channels[channelIdx];
      logger->debug(THIS_CLASS_NAME, "Channel %" PRIu32 ": name='%s', location='%s'",
        static_cast<uint32_t>(channelIdx + 1),
        channelInfo.name.c_str(), channelInfo.location.c_str());
    }
  }
}

/*static*/ PacketInfoProvider_DigitizerStartBased::DigitizerStartInfo PacketInfoProvider_DigitizerStartBased::_buildStartInfo(
    const sequence_number_t startSequence, const MsgDigitizerStart::Header* header,
    const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  DigitizerStartInfo ret;
  ret.startSequence = startSequence;
  // update channels
  ret.nChannels = header->n_channels;
  for (uint8_t channelIdx = 0; channelIdx < ret.nChannels; ++channelIdx)
  {
    auto& output = ret.channels[channelIdx];
    const auto& input = header->channels[channelIdx];
    if (!_updateString(output.name, input.name, NUM_ELEMENTS(input.name)))
    {
      logger->warning(__THIS_FUNC__, "Provided channel #%" PRIu32 " name is invalid. Default '%s' will be used",
        static_cast<uint32_t>(channelIdx), output.name.c_str());
    }
    _updateString(output.location, input.location, NUM_ELEMENTS(input.location));
    // From SEED specification; Location code is optional, so no need to report if default will be used.
  }
  // update network
  if (!_updateString(ret.network, header->network, NUM_ELEMENTS(header->network)))
  {
    logger->warning(__THIS_FUNC__, "Provided network is invalid. Default '%s' will be used", ret.network.c_str());
  }
  // update station
  if (!_updateString(ret.station, header->station, NUM_ELEMENTS(header->station)))
  {
    logger->warning(__THIS_FUNC__, "Provided station is invalid. Default '%s' will be used", ret.station.c_str());
  }
  return ret;
}

/*static*/ bool PacketInfoProvider_DigitizerStartBased::_isEqual(const DigitizerStartInfo& info1, const DigitizerStartInfo& info2)

{
  __DEV_CALLSTACK_FUNC__;
  // compare basic info
  if (info1.nChannels != info2.nChannels ||
      info1.network   != info2.network ||
      info1.station   != info2.station)
  {
    return false;
  }
  // compare channels
  for (uint8_t channelIdx = 0; channelIdx < info1.nChannels; ++channelIdx)
  {
    if (info1.channels[channelIdx].name     != info2.channels[channelIdx].name ||
        info1.channels[channelIdx].location != info2.channels[channelIdx].location)
    {
      return false;
    }
  }
  return true;
}


/*static*/ bool PacketInfoProvider_DigitizerStartBased::_updateString(std::string& output, const char* input, uint32_t maxLen)
{
  __DEV_CALLSTACK_FUNC__;
  if (input == nullptr || ::strnlen(input, maxLen) == 0)
  {
    return false;
  }
  const size_t actualLen = ::strnlen(input, maxLen);
  output = std::string(input, actualLen);
  return true;
}

const PacketInfoProvider_DigitizerStartBased::DigitizerStartInfo& PacketInfoProvider_DigitizerStartBased::_getStartInfo(const sequence_number_t sequenceNumber) const
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t infoIndex = 0; //0 by default causes:
  // if seismic packet dates before the very first Digitizer Start message (DigitizerStart implemented recently so no strict match till "format")
  // -> just reuse first start message available.
  const uint32_t nCached = static_cast<uint32_t>(m_startInfo.size());
  for (uint32_t i = 1; i < nCached; ++i)
  {
    const auto& cache = m_startInfo.at(i);
    if (cache.startSequence > sequenceNumber)
    {
      break;
    }
    infoIndex = i;
  }
  return m_startInfo.at(infoIndex);
}

timestamp_t PacketInfoProvider_DigitizerStartBased::getTimestamp(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  return packetSlice.timestamp;
}

const std::string& PacketInfoProvider_DigitizerStartBased::getNetwork(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  const DigitizerStartInfo& info = this->_getStartInfo(packetSlice.sequenceNumber);
  return info.network;
}

const std::string& PacketInfoProvider_DigitizerStartBased::getStation(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  const DigitizerStartInfo& info = this->_getStartInfo(packetSlice.sequenceNumber);
  return info.station;
}

const std::string& PacketInfoProvider_DigitizerStartBased::getChannelName(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  const DigitizerStartInfo& info = this->_getStartInfo(packetSlice.sequenceNumber);
  __ASSERT__(packetSlice.channelIndex < NUM_ELEMENTS(info.channels) && "Invalid channel index, [0-3] available only");
  return info.channels[packetSlice.channelIndex].name;
}

const std::string& PacketInfoProvider_DigitizerStartBased::getChannelLocation(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  const DigitizerStartInfo& info = this->_getStartInfo(packetSlice.sequenceNumber);
  __ASSERT__(packetSlice.channelIndex < NUM_ELEMENTS(info.channels) && "Invalid channel index, [0-3] available only");
  return info.channels[packetSlice.channelIndex].location;
}
