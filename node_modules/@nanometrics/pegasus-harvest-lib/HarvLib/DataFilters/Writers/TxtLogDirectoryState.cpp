#include "TxtLogDirectoryState.h"

#include <Utils/pdb_utils.h>
#include <Utils/psf_utils.h>

#include <algorithm>

TxtLogDirectoryState::TxtLogDirectoryState(const std::string& workingDir, const std::string& fileNamePattern,
  const uint32_t nHoursPerFile,
  const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider,
  const std::shared_ptr<ILogger>& logger)
  : m_workingDir(workingDir)
  , m_fileNamePattern(fileNamePattern)
  , m_packetInfoProvider(packetInfoProvider)
  , m_logger(logger)
  , m_mnemonicsDecoder(new MnemonicsDecoder(fileNamePattern, packetInfoProvider, pdb_utils::hours_to_nanoseconds(nHoursPerFile), logger))
  , m_nFilesGenerated(0)
{
  __DEV_CALLSTACK_FUNC__;
}

TxtLogDirectoryState::~TxtLogDirectoryState()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::free up files states
  for (const auto& fileState : m_fileStates)
  {
    delete fileState.second;
  }
}

std::string TxtLogDirectoryState::_getOutputFileName(const sPacketSlice& slice) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string decodedPath;
  if (m_mnemonicsDecoder->decode(slice, decodedPath) != (size_t)-1) {
    return decodedPath;
  }

  //tss_harv::decoding failed -> return "" (data will be dumped right into base folder)
  m_logger->warning(__THIS_FUNC__, "Failed to decode '%s'. Base name for TXT files won't be set (\"\")", m_fileNamePattern.c_str());
  return std::string("");
}

TxtLogFileState* TxtLogDirectoryState::_getFileState(const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  // lock resources here (fileStates array and MnemonicsDecoder used in _getOutputFileName)
  std::lock_guard<std::mutex> lock(m_mutex);
  //tss_harvlib::build filename for packet
  const std::string& outputFileName = this->_getOutputFileName(slice);
  //tss_harvlib::find filestate for this filename
  const auto foundIt = m_fileStates.find(outputFileName);
  if (foundIt != m_fileStates.end())
  {
    return foundIt->second;
  }

  //tss_harv::creating new file state
  std::unique_ptr<TxtLogFileState> newFileStatePtr(new TxtLogFileState(outputFileName, m_logger));
  {
    // create file context (!!allows appending to existing files) with 4MiBytes buffer for writing
    newFileStatePtr->createContext(m_workingDir, 1024ul * 1024ul * 4ul);
  }
  if (m_fileStates.insert(std::make_pair(newFileStatePtr->getName(), newFileStatePtr.get())).second == false)
  {
    return nullptr;
  }

  m_nFilesGenerated++;
  return newFileStatePtr.release();
}

void TxtLogDirectoryState::_deleteFileState(const std::string& filename)
{
  __DEV_CALLSTACK_FUNC__;
  std::lock_guard<std::mutex> lock(m_mutex);
  const auto& foundIt = m_fileStates.find(filename);
  __ASSERT__(foundIt != m_fileStates.end() && "File state wasn't found!");
  delete foundIt->second;
  m_fileStates.erase(foundIt);
}

size_t TxtLogDirectoryState::writeSlice(const sPacketSlice& slice, const bool bCompletesChannel)
{
  __DEV_CALLSTACK_FUNC__;
  TxtLogFileState* const pFileState = this->_getFileState(slice);
  size_t bytesWritten = 0;
  //tss_harvlib::dump slice to file state
  {
    // dump data
    bytesWritten = this->_writeData(pFileState, slice);
    // finish log record
    pFileState->finishRecord(bytesWritten);
    //tss_harvlib::if we have any further slices to write -> mark file's channel as filled as the following slices will go to the next file
    if (bCompletesChannel)
    {
      // finish channel
      const std::string& filename = pFileState->getName();
      this->_deleteFileState(filename);
    }
  }

  //tss_harvlib::return total data size written (in bytes)
  return bytesWritten;
}

size_t TxtLogDirectoryState::_writeData(TxtLogFileState* pFileState, const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pFileState != nullptr && "pFileState cannot be nullptr here. New should be created if doesn't exist");
  const std::shared_ptr<IIOContext>& context = pFileState->getContext();
  const io_offset_t recordOffset = pFileState->getRecordOffset();
  //tss_harv::dump data
  const uint16_t messageLen = slice.dataSizeInBytes;
  const char* pMessage = slice.data;
  // build timestamp string
  psf_utils::timestamp_to_string(m_timeBuffer, NUM_ELEMENTS(m_timeBuffer), slice.timestamp);
  const int headingSize = ::snprintf(m_stagingBuffer, NUM_ELEMENTS(m_timeBuffer), "%s: ", m_timeBuffer);
  // append message text to buffer
  ::memcpy(m_stagingBuffer + headingSize, pMessage, messageLen);
  // write message buffer to context
  const size_t nBytesToWrite = headingSize + messageLen;
  const size_t nBytesWritten = context->writeBlock(recordOffset, nBytesToWrite, m_stagingBuffer);
  return nBytesWritten;
}
