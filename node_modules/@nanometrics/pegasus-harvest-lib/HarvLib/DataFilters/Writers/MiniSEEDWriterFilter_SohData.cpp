#include "MiniSEEDWriterFilter_SohData.h"

#include "../../Utils/harvester_utils.h"
#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_NoCompression.h"
#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_Steim1.h"
#include "../../steim/synthesizers/MiniSEEDRecordsSynthesizer_Steim2.h"
#include "PacketInfoProvider_DigitizerStartBased.h"
#include "../AsyncWorker_Functor.h"

#include <Utils/pdb_utils.h>

#include <IOContext/io_contexts.h>
#include <PlatformUtils/PlatformUtils.h>

#include <libmseed.h>

#include <algorithm> //std::min

namespace
{
  template <typename T> inline sample_t steim2_clamp(const T value)
  {
    const double clampedValue = harvester_utils::clamp<T>(value,
      static_cast<T>(steim::BITS_29_MIN),
      static_cast<T>(steim::BITS_29_MAX));
    return static_cast<sample_t>(clampedValue);
  }

  // https://docs.google.com/spreadsheets/d/16bBlOC_5alfFElqXmCs3GnYRz9JRzD7EvOXNr3XQmBw/edit#gid=0
  struct ChannelInfo
  {
    const MsgSohData::ChannelID id;
    const std::string name;
    const PDB_eMediaType_t mediaType;
    template <typename THeader> using Sampler = sample_t(*)(const THeader& header, const uint16_t sampleIndex);
    Sampler<MsgHealthInput::Header> healthInputSampler;
    Sampler<MsgSohData::Header> sohDataSampler;
  } CHANNEL_INFOS[] = {
      { // time uncertainty
        MsgSohData::ChannelID::ATU, "ATU",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.time_uncertainty); // microseconds -> microseconds
        }
      },
      { // antenna status
        MsgSohData::ChannelID::VAN, "VAN",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.gnss_antenna_status);
        }
      },
      { // system clock error
        MsgSohData::ChannelID::VCE, "VCE",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.system_clock_error); // microseconds -> microseconds
        }
      },
      { // VCXO control setpoint
        MsgSohData::ChannelID::VCO, "VCO",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.vcxo_control);
        }
      },
      { // clock quality
        MsgSohData::ChannelID::VCQ, "VCQ",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.clock_quality); // percent -> percent
        }
      },
      { // system pressure
        MsgSohData::ChannelID::VDP, "VDP",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SYSTEM_PRESSURE]); // pascal -> pascal
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.system_pressure); // pascal -> pascal
        }
      },
      { // system temperature
        MsgSohData::ChannelID::VDT, "VDT",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SYSTEM_TEMPERATURE] * 1e+6); // degrees -> microdegrees
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.system_temperature * 1e+2); // degrees -> centidegrees
        }
      },
      { // system current
        MsgSohData::ChannelID::VE1, "VE1",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SYSTEM_CURRENT] * 1e+6); // amps -> microamps
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.system_current * 1e+6); // amps -> microamps
        }
      },
      { // sensor current
        MsgSohData::ChannelID::VE2, "VE2",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SENSOR_CURRENT] * 1e+6); // amps -> microamps
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.sensor_current * 1e+6); // amps -> microamps
        }
      },
      { // system voltage
        MsgSohData::ChannelID::VEI, "VEI",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SYSTEM_VOLTAGE] * 1e+6); // volts -> microvolts
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.system_voltage * 1e+3); // volts -> millivolts
        }
      },
      { // GNSS elevation
        MsgSohData::ChannelID::VEL, "VEL",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_elevation); // meters -> meters
        }
      },
      { // lock time
        MsgSohData::ChannelID::VGL, "VGL",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.gnss_lock_time); // seconds -> seconds
        }
      },
      { // GNSS time
        MsgSohData::ChannelID::VGT, "VGT",
        PDB_eMediaType_t::MEDIA_UNCOMPRESSED,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.gnss_time); // seconds -> seconds
        }
      },
      { // GNSS latitude
        MsgSohData::ChannelID::VLA, "VLA",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_latitude * 1e+6); // arcdegrees -> microarcdegrees
        }
      },
      { // GNSS longitude
        MsgSohData::ChannelID::VLO, "VLO",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_longitude * 1e+6); // arcdegrees -> microarcdegrees
        }
      },

      { // Sensor 1 SOH
        MsgSohData::ChannelID::VM1, "VM1",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SENSOR_1_SOH] * 1e+6); // volts -> microvolts
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.sensor_soh[0] * 1e+3); // volts -> millivolts
        }
      },
      { // Sensor 2 SOH
        MsgSohData::ChannelID::VM2, "VM2",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SENSOR_2_SOH] * 1e+6); // volts -> microvolts
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.sensor_soh[1] * 1e+3); // volts -> millivolts
        }
      },
      { // Sensor 3 SOH
        MsgSohData::ChannelID::VM3, "VM3",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SENSOR_3_SOH] * 1e+6); // volts -> microvolts
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.sensor_soh[2] * 1e+3); // volts -> millivolts
        }
      },
      { // Sensor 4 SOH
        MsgSohData::ChannelID::VM4, "VM4",
        PDB_eMediaType_t::MEDIA_STEIM2,
        [](const MsgHealthInput::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.samples[sampleIndex][HEALTH_SENSOR_4_SOH] * 1e+6); // volts -> microvolts
        },
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].health_inputs.sensor_soh[3] * 1e+3); // volts -> millivolts
        }
      },
      { // GNSS HDOP
        MsgSohData::ChannelID::VPH, "VPH",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_hdop * 1e+3); // units -> milliunits
        }
      },
      { // VCXO PLL status
        MsgSohData::ChannelID::VPL, "VPL",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.vcxo_pll_status);
        }
      },
      { // Seascan PPS phase
        MsgSohData::ChannelID::VPO, "VPO",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.seascan_pps_phase * 1e-3); // nanoseconds -> microseconds
        }
      },
      { // GNSS PDOP
        MsgSohData::ChannelID::VPP, "VPP",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_pdop * 1e+3); // units -> milliunits
        }
      },
      { // PLL converge time (NO public availability)
        MsgSohData::ChannelID::VPT, "VPT",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.vcxo_pll_converge); // seconds -> seconds
        }
      },
      { // GNSS VDOP
        MsgSohData::ChannelID::VPV, "VPV",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return steim2_clamp(header.soh_data[sampleIndex].clock_status.gnss_vdop * 1e+3); // units -> milliunits
        }
      },
      { // GNSS number of satellites
        MsgSohData::ChannelID::VNS, "VNS",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.gnss_satellite_count);
        }
      },
      { // GNSS position fix status
        MsgSohData::ChannelID::VST, "VST",
        PDB_eMediaType_t::MEDIA_STEIM2,
        nullptr,
        [](const MsgSohData::Header& header, const uint16_t sampleIndex) {
          return static_cast<sample_t>(header.soh_data[sampleIndex].clock_status.gnss_fix_status);
        }
      }
  };
  /*
    Sample rate for Health input is MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT -> 3600 * MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT samples / hour
    assuming the worst compression (1x), we have 3600 * MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT datasets
    1st frame has 13 dataset for samples
    2nd and following - 15 datasets
    max(frames)/hour = 1 (for 13 datasets) + ceil( (3600 * MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT - 13) / 15 )
  */
  const uint32_t HEALTH_INPUT_STEIM_FRAMES_PER_HOUR_MAX = 1u + //1 frame for 13 samples/datasets (16 - 3 for first+last+compression datasets)
    (uint32_t)(pdb_utils::decode_sample_rate(MSG_HEALTH_INPUT_SAMPLE_RATE_DEFAULT) * 3600.0 - (steim::DATASETS_PER_FRAME - 3) - 1) / (steim::DATASETS_PER_FRAME - 1) + 1; //the remaining samples go to 15 datasets frames (16 - 1 for compression)
}

/**
 * This class is designed to provide dummy data for station, network, instrumentID, etc.
 * Enhanced one will be used when this data can be retrieved from PSF library
 */
class PacketInfoProvider_HealthInput : public PacketInfoProvider_DigitizerStartBased
{
public:
  PacketInfoProvider_HealthInput(const std::shared_ptr<PSFLibrary>& library)
  : PacketInfoProvider_DigitizerStartBased(library, PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES)
  , m_unknownLocation("")
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual ~PacketInfoProvider_HealthInput() = default;

  // override only these 2 methods
  virtual const std::string& getChannelName(const sPacketSlice& packetSlice) const __OVERRIDES__(IPacketInfoProvider)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(packetSlice.channelIndex < NUM_ELEMENTS(CHANNEL_INFOS) && "channel index is out of range");
    return CHANNEL_INFOS[packetSlice.channelIndex].name;
  }

  virtual const std::string& getChannelLocation(const sPacketSlice& /*packetSlice*/) const __OVERRIDES__(IPacketInfoProvider)
  {
    __DEV_CALLSTACK_FUNC__;
    __TO_DO__("Provide some valid location for HealthInputs when available");
    return m_unknownLocation;
  }

private:
  std::string m_unknownLocation;
};

class MiniSEEDRecordsSynthesizerDelegate_SOH : public IMiniSEEDRecordsSynthesizerDelegate
{
public:
  MiniSEEDRecordsSynthesizerDelegate_SOH(std::vector<MiniSEEDRecordData>& output,
    const std::shared_ptr<ILogger>& logger)
    : IMiniSEEDRecordsSynthesizerDelegate(logger)
    , m_output(output)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual void onRecordReady(const MiniSEEDRecordData& recordData) __OVERRIDES__(IMiniSEEDRecordsSynthesizerDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_output.emplace_back(recordData);
  }

private:
  std::vector<MiniSEEDRecordData>& m_output;
};


MiniSEEDWriterFilter_SohData::MiniSEEDWriterFilter_SohData(const std::shared_ptr<PSFLibrary>& library,
  const sHarvestParams& params,
  const uint32_t channelsMask,
  const uint32_t poolSize,
  const std::shared_ptr<ILogger>& logger)
  : IWriterFilter("MiniSEEDWriterFilter_SohData", params, poolSize, logger)
  , m_channelsMask(channelsMask)
  , m_msgHealthInputsPool(new mem_pool_allocator_new<MsgHealthInput()>(), logger)
  , m_msgSohDataPool(new mem_pool_allocator_new<MsgSohData()>(), logger)
  , m_nFramesPerRecordMax(std::min<uint32_t>(MAX_FRAMES_PER_RECORD,
      HEALTH_INPUT_STEIM_FRAMES_PER_HOUR_MAX * params.nHoursPerFile))
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_params.nHoursPerFile > 0 && "nHoursPerFile per file must be > 0");
  // register handlers to process PSF data
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PSF, HandlerFunc(&MiniSEEDWriterFilter_SohData::_processPSFData, this));

  //tss_harvlib::allocate memory pool for packets
  m_msgHealthInputsPool.allocate(poolSize + 1);
  m_msgSohDataPool.allocate(poolSize + 1);

  const bool useBigEndian = true;
  // initialize channel state for each channel/input
  const uint32_t nChannels = NUM_ELEMENTS(CHANNEL_INFOS);
  m_channelStates.reserve(nChannels);
  for (uint32_t channel = 0; channel < nChannels; ++channel)
  {
    m_channelStates.emplace_back(ChannelState());
    ChannelState& state = m_channelStates.back();
    ChannelInfo& info = CHANNEL_INFOS[channel];
    switch (info.mediaType)
    {
      case PDB_eMediaType_t::MEDIA_UNCOMPRESSED:
        state.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_NoCompression>(
          std::make_shared<buffer_malloc<SteimFrame_t>>(m_nFramesPerRecordMax),
          std::make_shared<MiniSEEDRecordsSynthesizerDelegate_SOH>(state.recordsQueue, m_logger), //create delegate to collect compressed packets in its specific queue
          useBigEndian,
          m_logger);
        break;

      case PDB_eMediaType_t::MEDIA_STEIM1:
        state.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_Steim1>(
          std::make_shared<buffer_malloc<SteimFrame_t>>(m_nFramesPerRecordMax),
          std::make_shared<MiniSEEDRecordsSynthesizerDelegate_SOH>(state.recordsQueue, m_logger), //create delegate to collect compressed packets in its specific queue
          useBigEndian,
          m_logger);
        break;

      case PDB_eMediaType_t::MEDIA_STEIM2:
        state.synthesizer = std::make_shared<MiniSEEDRecordsSynthesizer_Steim2>(
          std::make_shared<buffer_malloc<SteimFrame_t>>(m_nFramesPerRecordMax),
          std::make_shared<MiniSEEDRecordsSynthesizerDelegate_SOH>(state.recordsQueue, m_logger), //create delegate to collect compressed packets in its specific queue
          useBigEndian,
          m_logger);
        break;

      default:
        __ASSERT__(false && "unsupported media type");
    }
  }
  // create packet infor provider
  m_packetInfoProvider = std::make_shared<PacketInfoProvider_HealthInput>(library);
}

MiniSEEDWriterFilter_SohData::~MiniSEEDWriterFilter_SohData()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::free miniSEED states
  for (auto& it : m_mseedStates)
  {
    delete (it.second);
  }
}

ErrorDataDesc* MiniSEEDWriterFilter_SohData::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pConfig != nullptr && "pConfig cannot be nullptr here");
  m_packetInfoProvider->initialize(pConfig->sequenceRange);
  return IWriterFilter::run(pConfig);
}

void MiniSEEDWriterFilter_SohData::_createWorkers()
{
  __DEV_CALLSTACK_FUNC__;
  __TO_DO__("PGWU-399: add multiple workers support");
  const uint32_t nWorkers = 1;
  m_workers.reserve(nWorkers);
  for (uint32_t i = 0; i < nWorkers; ++i)
  {
    m_workers.push_back(std::make_shared<AsyncWorker_Functor>(m_dataQueue, m_results,
      AsyncWorker_Functor::Functor(&MiniSEEDWriterFilter_SohData::_workerFunc, this),
      m_logger));
  }
}

DataDescPtr MiniSEEDWriterFilter_SohData::_workerFunc(IAsyncWorker* pWorker, const DataDescPtr data)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_processDataImpl(data, pWorker);
}

DataDescPtr MiniSEEDWriterFilter_SohData::_processPSFData(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  PSFDataDesc* const pPSFData = static_cast<PSFDataDesc*>(data);
  PSFDataElement* const pDataElement = pPSFData->getElement();
  if (pDataElement == nullptr)
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "PSFDataElement invalid handle");
  }

  // check DataElement message type (new MsgSohData or legacy MsgHealthInput)
  if (pDataElement->isInstanceOf(PDB_eMessageType_t::MSG_SOH_DATA_V0))
  {
    MsgSohData* const pPacket = m_msgSohDataPool.new_object();
    if (pPacket && pPacket->restore(pDataElement))
    {
      const sequence_number_t sequenceNumber = pDataElement->getHeader()->sequenceNumber;
      ErrorDataDesc* const pErrorData = this->_processPacket(pPacket, sequenceNumber, userData);
      if (pErrorData != nullptr)
      {
        return pErrorData;
      }
    }
    else
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to retrieve information from Data Element");
    }
  }
  else if (pDataElement->isInstanceOf(PDB_eMessageType_t::MSG_HEALTH_INPUT_V0))
  {
    MsgHealthInput* const pPacket = m_msgHealthInputsPool.new_object();
    if (pPacket && pPacket->restore(pDataElement))
    {
      const sequence_number_t sequenceNumber = pDataElement->getHeader()->sequenceNumber;
      ErrorDataDesc* const pErrorData = this->_processPacket(pPacket, sequenceNumber, userData);
      if (pErrorData != nullptr)
      {
        return pErrorData;
      }
    }
    else
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to retrieve information from Data Element");
    }
  }

  // track element processed
  const uint32_t elementSize = PSF_PAGES_to_BYTES(pDataElement->getHeader()->sizeInPages);
  this->_trackElementProcessed(elementSize);
  // return progress data
  return this->_makeProgress();
}

MiniSEEDDirectoryState* MiniSEEDWriterFilter_SohData::_getDirectoryState(const sPacketSlice& packetSlice)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::get unique state code for the packet
  const std::string& outputDirectory = this->_getOutputDirectory(packetSlice);
  //tss_harv::find if the state is already created
  const auto foundIt = m_mseedStates.find(outputDirectory);
  if (foundIt != m_mseedStates.end())
  {
    return foundIt->second;
  }

  std::string workingDir = "";
  const std::string& outputDirFull = PlatformUtils::getInstance()->resolvePath(m_params.outputDir);
  //tss_harv::build full path for output miniSEED within this state (base path + decoded path)
  {
    const std::string& mergedFullPath = PlatformUtils::getInstance()->join(outputDirFull, outputDirectory);
    //tss_harv::trying to create base directory for mSEED files
    if (PlatformUtils::getInstance()->makePath(mergedFullPath))
    {
      //tss_harv::set decoded path as output path
      workingDir = mergedFullPath;
    }
    else
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to create '%s' path. Output path ('%s') will be used : %s",
        mergedFullPath.c_str(),
        outputDirFull.c_str(),
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      workingDir = outputDirFull;
    }
  }

  //tss_harv::creating new MiniSEED state
  const std::string& fileNamePattern = PlatformUtils::getInstance()->getBaseName(m_params.outputPattern);
  //tss_harv::detect amount of channels per file (If ${C} mnemonic persists -> each channel is in it's own file, otherwise - multiple channels per file)
  const uint32_t nChannels = static_cast<uint32_t>(m_channelStates.size());
  const uint8_t nChannelsPerFile = m_mnemonicsDecoder->hasMnemonic("${C}") ? 1 : nChannels;
  std::unique_ptr<MiniSEEDDirectoryState> newStatePtr(new MiniSEEDDirectoryState(workingDir, fileNamePattern,
    m_params.nHoursPerFile, nChannelsPerFile, nChannels,
    m_nFramesPerRecordMax, //set fixed frames count
    m_packetInfoProvider, m_logger));

  //tss_harv::append new state to states map and return it
  m_mseedStates.insert(std::make_pair(outputDirectory, newStatePtr.get()));
  return newStatePtr.release();
}

ErrorDataDesc* MiniSEEDWriterFilter_SohData::_processPacket(const MsgSohData* pPacket,
  const sequence_number_t sequenceNumber, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pPacket != nullptr && "pPacket cannot be nullptr here!");
  //__ASSERT__(userData != nullptr && "method expects IAsyncWOrker passed through the userData here!");
  const MsgSohData::Header* const pHeader = pPacket->getHeader();
  // empty packet check
  if (pHeader->n_samples == 0u)
  {
    return nullptr;
  }
  // get packet info
  const timediff_t sampleDurationNs = pdb_utils::get_packet_duration_nanoseconds(1, pHeader->sample_rate);
  const timestamp_t packetFirstSampleTime = pHeader->timestamp; // the time of the very first sample
  const timestamp_t packetLastSampleTime = pHeader->timestamp + sampleDurationNs * (pHeader->n_samples - 1);
  const timediff_t sliceLengthNs = static_cast<timediff_t>(pdb_utils::hours_to_nanoseconds(m_params.nHoursPerFile));

  uint16_t firstSampleIdx = 0u;
  // first requested packet -> check cut off by lower timestamp if needed
  if (sequenceNumber == m_targetRange.lower)
  {
    // check if packet cut off by any of the boundaries
    if ((packetFirstSampleTime > m_params.upper.time) ||
        (packetLastSampleTime < m_params.lower.time))
    {
      return nullptr;
    }
    // determine the first sample (lower bound is inclusive)
    const timestamp_t lowerBoundary = std::max<timestamp_t>(m_params.lower.time, packetFirstSampleTime);
    firstSampleIdx = (lowerBoundary == packetFirstSampleTime) ?
        0 : //start from the very first sample
        static_cast<uint16_t>((lowerBoundary - packetFirstSampleTime - 1ull) / sampleDurationNs) + 1;
  }

  uint16_t lastSampleIdx = pHeader->n_samples - 1u;
  // last requested packet -> cut off by upper timestamp if needed
  if (sequenceNumber == m_targetRange.upper)
  {
    // check if packet cut off by any of the boundaries
    if ((packetFirstSampleTime >= m_params.upper.time) ||
        (packetLastSampleTime < m_params.lower.time))
    {
      return nullptr;
    }
    // determine the last sample (upper bound is exclusive -> +1 for last packet sample to include it)
    const timestamp_t upperBoundary = std::min<timestamp_t>(m_params.upper.time, packetLastSampleTime + 1ull);
    lastSampleIdx = (upperBoundary > packetLastSampleTime) ?
        pHeader->n_samples - 1u : // till the last sample
        static_cast<uint16_t>((upperBoundary - packetFirstSampleTime - 1ull) / sampleDurationNs);
  }
  
  const uint32_t nChannels = static_cast<uint32_t>(m_channelStates.size());
  //go over each channel in MsgSohData message and feed Steim synthesizers with samples
  for (uint32_t channel = 0; channel < nChannels; ++channel)
  {
    const ChannelInfo& channelInfo = CHANNEL_INFOS[channel];
    // skip the channel if it is not included in channels mask or doesn't have sampler function defined
    if (((m_channelsMask & channelInfo.id) == 0) || (channelInfo.sohDataSampler == nullptr))
    {
      continue;
    }

    ChannelState& channelState = m_channelStates[channel];
    timestamp_t sampleTimestamp = pHeader->timestamp + firstSampleIdx * sampleDurationNs; //sample timestamp
    sPacketSlice& slice = channelState.slice;
    slice.sequenceNumber = sequenceNumber;
    for (uint16_t sampleIdx = firstSampleIdx; sampleIdx <= lastSampleIdx; sampleIdx++)
    {
      //initialize an empty slice
      if (slice.nSamples == 0)
      {
        slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
        slice.channelIndex = channel;
        slice.timestamp = sampleTimestamp;
        slice.expectedTimestamp = sampleTimestamp;
        slice.sampleRate = pHeader->sample_rate;
        slice.isLast = false;
      }

      // check upper bound and discontinuity
      {
        const timestamp_t sliceUpperTime = static_cast<int64_t>(slice.sliceIndex + 1) * sliceLengthNs;
        const bool upperBoundIsHit = (sampleTimestamp >= sliceUpperTime);
        if (upperBoundIsHit || (slice.expectedTimestamp != sampleTimestamp))
        {
          slice.isLast = upperBoundIsHit;
          channelState.synthesizer->flush();
        }
      }

      // add sample
      channelState.synthesizer->addSample(channelInfo.sohDataSampler(*pHeader, sampleIdx));
      //process Steim frames queue for channel. Record can be caused by 'flush' call on synthesizer or when max frames reached. If processed - slice gets emptied
      ErrorDataDesc* const pErrorDesc = this->_processSteimQueue(channelState);
      if (pErrorDesc != nullptr)
      {
        return pErrorDesc;
      }

      //if slice is empty -> start new slice at the current sample
      if (slice.nSamples == 0)
      {
        slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
        slice.channelIndex = channel;
        slice.timestamp = sampleTimestamp;
        slice.expectedTimestamp = sampleTimestamp;
        slice.sampleRate = pHeader->sample_rate;
        slice.isLast = false;
      }

      //update samples count covered by slice
      slice.nSamples++;
      slice.expectedTimestamp += sampleDurationNs;
      //update timestamp for the next sample
      sampleTimestamp += sampleDurationNs;
      this->_trackTimerange(slice);
    }
  }

  // update progress
  {
    m_progress.nFilesGenerated = 0u;
    for (const auto& state : m_mseedStates)
    {
      m_progress.nFilesGenerated += state.second->getFilesCount();
    }
  }

  // return nullptr - no error indication
  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_SohData::_processPacket(const MsgHealthInput* pPacket,
  const sequence_number_t sequenceNumber, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pPacket != nullptr && "pPacket cannot be nullptr here!");
  //__ASSERT__(userData != nullptr && "method expects IAsyncWOrker passed through the userData here!");
  const MsgHealthInput::Header* const pHeader = pPacket->getHeader();
  const timediff_t sampleDurationNs = pdb_utils::get_packet_duration_nanoseconds(1, pHeader->sample_rate);
  const timestamp_t packetFirstSampleTime = pHeader->timestamp; // the time of the very first sample
  const timestamp_t packetLastSampleTime = pHeader->timestamp + sampleDurationNs * (pHeader->n_samples - 1);

  //get upper bound for slicing
  const timediff_t sliceLengthNs = static_cast<timediff_t>(pdb_utils::hours_to_nanoseconds(m_params.nHoursPerFile));
  // calculate the sample index to start (should not be before harvesting lowerTime)
  const uint16_t firstSampleIdx = (sequenceNumber != m_targetRange.lower) || (packetFirstSampleTime >= m_params.lower.time) ?
    0 :
    static_cast<uint16_t>((m_params.lower.time - packetFirstSampleTime - 1ull) / sampleDurationNs) + 1;
  // calculate the sample index to finish (should be before harvesting upperTime)
  const uint16_t lastSampleIdx = (sequenceNumber != m_targetRange.upper) || (packetLastSampleTime < m_params.upper.time) ?
    pHeader->n_samples - 1:
    static_cast<uint16_t>(pHeader->n_samples - 1 -
    		((packetLastSampleTime - m_params.upper.time) / sampleDurationNs) + 1);

  const uint32_t nChannels = static_cast<uint32_t>(m_channelStates.size());
  //go over each channel in HealthInput message and feed Steim synthesizers with samples
  for (uint32_t channel = 0; channel < nChannels; ++channel)
  {
    const ChannelInfo& channelInfo = CHANNEL_INFOS[channel];
    // skip the channel if it is not included in channels mask or doesn't have sampler function defined
    if (((m_channelsMask & channelInfo.id) == 0) || (channelInfo.healthInputSampler == nullptr))
    {
      continue;
    }

    ChannelState& channelState = m_channelStates[channel];
    timestamp_t sampleTimestamp = pHeader->timestamp + firstSampleIdx * sampleDurationNs; //sample timestamp
    sPacketSlice& slice = channelState.slice;
    slice.sequenceNumber = sequenceNumber;
    for (uint16_t sampleIdx = firstSampleIdx; sampleIdx <= lastSampleIdx; sampleIdx++)
    {
      //initialize an empty slice
      if (slice.nSamples == 0)
      {
        slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
        slice.channelIndex = channel;
        slice.timestamp = sampleTimestamp;
        slice.expectedTimestamp = sampleTimestamp;
        slice.sampleRate = pHeader->sample_rate;
        slice.isLast = false;
      }

      // check upper bound and discontinuity
      {
        const timestamp_t sliceUpperTime = static_cast<int64_t>(slice.sliceIndex + 1) * sliceLengthNs;
        const bool upperBoundIsHit = (sampleTimestamp >= sliceUpperTime);
        if (upperBoundIsHit || (slice.expectedTimestamp != sampleTimestamp))
        {
          slice.isLast = upperBoundIsHit;
          channelState.synthesizer->flush();
        }
      }

      // add sample
      channelState.synthesizer->addSample(channelInfo.healthInputSampler(*pHeader, sampleIdx));
      //process Steim frames queue for channel. Record can be caused by 'flush' call on synthesizer or when max frames reached. If processed - slice gets emptied
      ErrorDataDesc* const pErrorDesc = this->_processSteimQueue(channelState);
      if (pErrorDesc != nullptr)
      {
        return pErrorDesc;
      }

      //if slice is empty -> start new slice at the current sample
      if (slice.nSamples == 0)
      {
        slice.sliceIndex = harvester_utils::get_slice_index(sampleTimestamp, sliceLengthNs);
        slice.channelIndex = channel;
        slice.timestamp = sampleTimestamp;
        slice.expectedTimestamp = sampleTimestamp;
        slice.sampleRate = pHeader->sample_rate;
        slice.isLast = false;
      }

      //update samples count covered by slice
      slice.nSamples++;
      slice.expectedTimestamp += sampleDurationNs;
      //update timestamp for the next sample
      sampleTimestamp += sampleDurationNs;
      this->_trackTimerange(slice);
    }
  }

  // update progress
  {
    m_progress.nFilesGenerated = 0u;
    for (const auto& state : m_mseedStates)
    {
      m_progress.nFilesGenerated += state.second->getFilesCount();
    }
  }

  // return nullptr - no error indication
  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_SohData::_processSteimQueue(ChannelState& channelState)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(channelState.recordsQueue.size() <= 1 && "Queue can have only 1 packet max at a time due to real time compression!");
  if (!channelState.recordsQueue.empty())
  {
    //get this steim frame
    const MiniSEEDRecordData& record = channelState.recordsQueue.front();
    //build slice info
    sPacketSlice& slice = channelState.slice;
    {
      __ASSERT__(slice.nSamples == record.nSamples && "Sanity check failed. Slice and miniSEED record are not synced!");
      slice.mediaType = record.mediaType;
      slice.nFramesCompressed = record.nFrames;
      slice.data = record.data;
      slice.dataSizeInBytes = record.dataSizeInBytes;
      slice.isBigEndian = record.isBigEndian;
    }
    //get directory state to append slice to
    MiniSEEDDirectoryState* const pState = this->_getDirectoryState(slice);
    const size_t nBytesWritten = pState->writeSlice(slice, slice.isLast);
    if (nBytesWritten <= 0)
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to write slice!");
    }
    //free up the queue
    channelState.recordsQueue.clear();
    //discard the slice (mark as empty) to let it be reset
    slice.nSamples = 0;
  }

  return nullptr;
}

ErrorDataDesc* MiniSEEDWriterFilter_SohData::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  m_bFinishRequested = true;
  //tss_harv::stop waiting for data
  m_dataQueue.stop_waiting();
  //tss_harv::wait till finalized
  this->_finishWorkers(true);
  //tss_harv::process results that might remain in the results queue
  this->_processResults();
  //flush each input/channel
  for (auto& state : m_channelStates)
  {
    // flush remaining samples to record
    state.synthesizer->flush();
    // process records
    this->_processSteimQueue(state);
  }
  return IBaseFilter::finalize(pReport);
}
