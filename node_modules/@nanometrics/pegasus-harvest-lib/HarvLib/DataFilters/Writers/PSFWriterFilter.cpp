#include "PSFWriterFilter.h"

PSFWriterFilter::PSFWriterFilter(const std::shared_ptr<PSFVolume>& volume, const std::shared_ptr<ILogger>& logger)
:  IBaseFilter("PSFWriterFilter", logger)
,  m_volume(volume)
,  m_stream(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PSF, HandlerFunc(&PSFWriterFilter::_processPSFData, this));
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PDB, HandlerFunc(&PSFWriterFilter::_processPDBData, this));
}

PSFWriterFilter::~PSFWriterFilter()
{
  __DEV_CALLSTACK_FUNC__;
  delete m_stream;
}

DataDescPtr PSFWriterFilter::_processPSFData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data cannot be NULL here!");
  PSFDataDesc* const pPSFData = static_cast<PSFDataDesc*>(data);
  PSFDataElement* const pDataElement = pPSFData->getElement();
  if (pDataElement != 0)
  {
    const size_t bytesWritten = m_stream->write(pDataElement);
    if (bytesWritten <= 0)
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED, 
        "Failed to write data element");
    }
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Cannot write 0 data element");
  }

  return data;
}

DataDescPtr PSFWriterFilter::_processPDBData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data cannot be NULL here!");
  PDBDataDesc* const pPDBData = static_cast<PDBDataDesc*>(data);
  IPDBMsgObject* pPDBObject = pPDBData->getObject();
  if (pPDBObject != nullptr)
  {
    void* pBuffer = nullptr;
    size_t bufferSize = 0;
    if (pPDBObject->lockBuffer(&pBuffer, &bufferSize))
    {
      const int objType = pPDBObject->getType();
      const size_t bytesWritten = m_stream->write(objType, pBuffer, bufferSize);
      if (bytesWritten <= 0)
      {
        return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
          "Failed to write data element");
      }
    }
    else
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to lock PDBObject data");
    }
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Cannot write 0 data element");
  }

  return data;
}

ErrorDataDesc* PSFWriterFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_volume == nullptr)
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_VOLUME_NOT_FOUND, 
      "Cannot find 'Logs' volume to harvest logs from");
  }

  //tss_harv::open stream
  m_stream = new PSFStream(m_volume.get(), m_volume->getLogger());

  return IBaseFilter::run(pConfig);
}
