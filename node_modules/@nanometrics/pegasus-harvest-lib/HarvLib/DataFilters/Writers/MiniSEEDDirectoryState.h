#ifndef MiniSEEDDirectoryState_h__
#define MiniSEEDDirectoryState_h__

#include "../../harvlib_defines.h"

#include "MiniSEEDFileState.h"

#include "../MnemonicsDecoder.h"

#include <Logger/ILogger.h>
#include <IOContext/IIOContext.h>

#include <DataTypes/SensorTimeSeries/MsgSensorInput.h>

#include <libmseed.h>

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <mutex>
#include <atomic>

#define MAX_FRAMES_PER_RECORD 63u // imposed by Blockette #1001 (http://www.fdsn.org/pdf/SEEDManual_V2.4.pdf#page=128)
__STATIC_ASSERT__(MAX_FRAMES_PER_RECORD >= PDB_SENSOR_INPUT_FRAMES_COUNT,
    "PDB SeismicPacket maximum frames count exceeds maximum allowed");

/**
 * This class handles MiniSEED files inside single specific directory (its working directory). 
 * All the file states in this class reflect actual files in the working directory.
 * This class is used to group the files processing within single directory (this grouping allows to avoid multiple path existance check and creation system calls).
 * Once this instance is created, its working directory exists -> no need to perform any checks -> can freely create the miniSEED files in its working directory.
 */
class MiniSEEDDirectoryState
{
private:
  struct sChannelState
  {
    uint8_t channel = 0;
    uint32_t sequenceNumber = 0u; //sequence number
    uint32_t nSamples = 0u;
#pragma pack(push, 1) // compact byte packing
    struct MiniSEEDRecordStart
    {
      struct fsdh_s fixedHeader; //MiniSEED fixed header
      struct Blkt1000
      {
        uint16_t info[2] = { 1000, sizeof(fsdh_s) + sizeof(Blkt1000) }; //{ number, offset to the next blockette}
        struct blkt_1000_s data; // blockette data
      } blkt1000; // blockette #1000
      struct Blkt1001
      {
        uint16_t info[2] = { 1001, 0 }; //{ number, offset to the next blockette}
        struct blkt_1001_s data; // blockette data
      } blkt1001; // blockette #1001
    } miniSEEDRecordStart; //contiguous data each miniSEED record commences with
#pragma pack(pop) // #pragma pack(push, 1)
  };

public:
  MiniSEEDDirectoryState(const std::string& workingDir, const std::string& fileNamePattern,
    const uint32_t nHoursPerFile, const uint8_t nChannelsPerFile, const uint8_t maxChannels,
    const uint32_t fixedSteimFramesCount,
    const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider,
    const std::shared_ptr<ILogger>& logger);

  virtual ~MiniSEEDDirectoryState();

  size_t writeSlice(const sPacketSlice& slice, const bool bCompletesChannel);

  FORCE_INLINE uint32_t getFilesCount() const { return m_nFilesGenerated; }

  // prohibit copy/move/assignment
  DECLARE_NOCOPYABLE(MiniSEEDDirectoryState);

private:
  std::string _getOutputFileName(const sPacketSlice& slice) const;
  MiniSEEDFileState* _getFileState(const sPacketSlice& slice); // get file state for the channel
  void _deleteFileState(const std::string& filename);
  size_t _writeData(sChannelState* pChannelState, MiniSEEDFileState* pFileState,  const sPacketSlice& slice);

private:
  const std::string m_workingDir;
  const std::string m_fileNamePattern;
  const uint8_t m_nChannelsPerFile;
  const uint32_t m_nFixedSteimFrames;
  uint32_t m_recordLen;
  uint8_t m_recordLenPowOf2Base;

  const std::shared_ptr<IPacketInfoProvider> m_packetInfoProvider;
  const std::shared_ptr<ILogger> m_logger;

  const uint32_t m_miniSEEDWriteCacheSize; //cache size for BufferedIOContext decorator for miniSEED files
  //map is used to assign file names with file state
  std::map<std::string, MiniSEEDFileState*> m_fileStates;
  std::vector<sChannelState*> m_channelStates;
  const std::unique_ptr<MnemonicsDecoder> m_mnemonicsDecoder;
  std::atomic<uint32_t> m_nFilesGenerated;
  std::shared_ptr<buffer_base<char>> m_zeroBuffer; //this buffer is used to end up the record to power of 2 length (required for Steim2)
  //This buffer is cleared to contain zeros and is written sequentially after the header, so BufferedIOContext can utilize it's writing cache
  std::shared_ptr<buffer_base<char>> m_swappedBuffer; //this buffer is used to contain swapped steim frames
  std::mutex m_mutex;
};

#endif //MiniSEEDDirectoryState_h__

