#include "IWriterFilter.h"

#include <Utils/psf_utils.h>
#include <Utils/pdb_utils.h>
#include "../../Utils/harvester_utils.h"

#include <PlatformUtils/PlatformUtils.h>

#include <cstring>

IWriterFilter::IWriterFilter(const std::string& name,
  const sHarvestParams& params, const uint32_t maxQueueSize,
  const std::shared_ptr<ILogger>& logger)
  : IAsyncFilter(name, maxQueueSize, logger)
  , m_params(params)
  , m_packetInfoProvider(nullptr)
  , m_mnemonicsDecoder(nullptr)
  , m_startTime(0ll)
  , m_progressPool(new mem_pool_allocator_new_init<ProgressDataDesc(const IBaseFilter*, const sHarvestProgress&)>(), logger)
{
  __DEV_CALLSTACK_FUNC__;
  // initialize progress
  ::memset(&m_progress, 0, sizeof(m_progress));
  m_progressPool.allocate(maxQueueSize + 1, this, m_progress);
}

ErrorDataDesc* IWriterFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pConfig != nullptr && "pConfig cannot be nullptr here");
  m_startTime = pConfig->startTime;
  m_progress.nElementsTotal = (pConfig->sequenceRange.upper - pConfig->sequenceRange.lower) + 1;
  m_progress.timeRange.valid = false;
  m_targetRange = pConfig->sequenceRange;

  // initialize mnemonics decoder to build folder paths
  __ASSERT__(m_packetInfoProvider != nullptr && "m_packetInfoProvide should be created by this stage");
  const std::string& folderMnemonicPart = PlatformUtils::getInstance()->getBaseDir(m_params.outputPattern);
  m_mnemonicsDecoder = std::make_shared<MnemonicsDecoder>(folderMnemonicPart,
    m_packetInfoProvider,
    pdb_utils::hours_to_nanoseconds(m_params.nHoursPerFile), //time pattern encoding precision
    m_logger);

  return IAsyncFilter::run(pConfig);
}

ProgressDataDesc* IWriterFilter::_makeProgress()
{
  __DEV_CALLSTACK_FUNC__;
  // update progress (calculate other fields)
  {
    const timediff_t elapsedNs = psf_utils::get_timestamp() - m_startTime;
    m_progress.durationMs = harvester_utils::clamp<double, uint32_t>(
      pdb_utils::nanoseconds_to_milliseconds(elapsedNs),//nanoseconds to mil
      std::numeric_limits<uint32_t>::min(), std::numeric_limits<uint32_t>::max());
    const double dataSizeMiB = (double)m_progress.nBytesProcessed / (1024.0 * 1024.0);
    m_progress.speedMiBpSec = (float)(dataSizeMiB * 1e9 / ((double)elapsedNs));
    m_progress.progress = (float)m_progress.nElementsProcessed / (float)m_progress.nElementsTotal;
  }
  // create progress data object
  ProgressDataDesc* const pRet = m_progressPool.new_object(this, m_progress);
  return pRet;
}

std::string IWriterFilter::_getOutputDirectory(const sPacketSlice& packetSlice) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string decodedDirectory;
  //tss_harv::if decode succeeded -> return decoded path
  if (m_mnemonicsDecoder->decode(packetSlice, decodedDirectory) != (size_t)-1) {
    return decodedDirectory;
  }

  //tss_harv::decoding failed -> return "" (data will be dumped right into base folder)
  m_logger->warning(__THIS_FUNC__, "Failed to decode '%s'. Data will be dumped to the output dir '%s'",
    m_params.outputPattern.c_str(), m_params.outputDir.c_str());
  return std::string("");
}


void IWriterFilter::_trackTimerange(const timestamp_t lower, const timestamp_t upper)
{
  __DEV_CALLSTACK_FUNC__;
  if (!m_progress.timeRange.valid)
  {
    m_progress.timeRange.lower = lower;
    m_progress.timeRange.valid = true;
  }
  m_progress.timeRange.upper = upper;
}

void IWriterFilter::_trackTimerange(const sPacketSlice& slice)
{
  __DEV_CALLSTACK_FUNC__;
  const timestamp_t upper = slice.timestamp + pdb_utils::get_packet_duration_nanoseconds(slice.nSamples, slice.sampleRate);
  this->_trackTimerange(slice.timestamp, upper);
}

void IWriterFilter::_trackElementProcessed(const uint32_t nBytes)
{
  __DEV_CALLSTACK_FUNC__;
  m_progress.nElementsProcessed++;
  m_progress.nBytesProcessed += nBytes;
}
