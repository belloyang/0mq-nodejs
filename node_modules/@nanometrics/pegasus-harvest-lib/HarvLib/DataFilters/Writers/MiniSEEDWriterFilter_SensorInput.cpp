#include "MiniSEEDWriterFilter_SensorInput.h"

#include "../../Utils/harvester_utils.h"
#include "PacketInfoProvider_DigitizerStartBased.h"
#include "../AsyncWorker_Functor.h"

#include <Utils/pdb_utils.h>

#include <IOContext/io_contexts.h>
#include <PlatformUtils/PlatformUtils.h>

#include <libmseed.h>

#include <algorithm> //std::min

MiniSEEDWriterFilter_SensorInput::MiniSEEDWriterFilter_SensorInput(const std::shared_ptr<PSFLibrary>& library,
  const sHarvestParams& params, const uint32_t poolSize,
  const std::shared_ptr<ILogger>& logger)
  : MiniSEEDWriterFilter_SensorInput(std::make_shared<PacketInfoProvider_DigitizerStartBased>(library, PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES),
      params, poolSize, logger)
{
  __DEV_CALLSTACK_FUNC__;
}

MiniSEEDWriterFilter_SensorInput::MiniSEEDWriterFilter_SensorInput(const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider,
  const sHarvestParams& params, const uint32_t poolSize,
  const std::shared_ptr<ILogger>& logger)
: IWriterFilter("MiniSEEDWriterFilter_SensorInput", params, poolSize, logger)
, m_msgSensorInputsPool(new mem_pool_allocator_new<MsgSensorInput()>(), logger)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(params.nHoursPerFile > 0 && "nHoursPerFile per file must be > 0");
  // register handlers to process PSF and PDB data
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PSF, HandlerFunc(&MiniSEEDWriterFilter_SensorInput::_processPSFData, this));
  this->_registerDataHandler(IDataDesc::DATA_TYPE_PDB, HandlerFunc(&MiniSEEDWriterFilter_SensorInput::_processPDBData, this));
  // allocate memory pool for packets
  m_msgSensorInputsPool.allocate(poolSize + 1);
  // set packet info provider
  m_packetInfoProvider = packetInfoProvider;
}

MiniSEEDWriterFilter_SensorInput::~MiniSEEDWriterFilter_SensorInput()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::free miniSEED states
  for (auto& it : m_mseedStates)
  {
    delete (it.second);
  }
}

ErrorDataDesc* MiniSEEDWriterFilter_SensorInput::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pConfig != nullptr && "pConfig cannot be nullptr here");
  const sTimespan& timeRange = pConfig->timeRange;
  const sSequenceRange& sequenceRange = pConfig->sequenceRange;
  const timediff_t slicelengthNs = pdb_utils::hours_to_nanoseconds(m_params.nHoursPerFile);
  // create slicer
  m_slicer = std::make_shared<PacketSlicer_TimeRange>(timeRange, sequenceRange, slicelengthNs, m_logger);
  // create packet info provider
  m_packetInfoProvider->initialize(sequenceRange);
  return IWriterFilter::run(pConfig);
}

void MiniSEEDWriterFilter_SensorInput::_createWorkers()
{
  __DEV_CALLSTACK_FUNC__;
  __TO_DO__("PGWU-396: add multiple workers support");
  const uint32_t nWorkers = 1;
  m_workers.reserve(nWorkers);
  for (uint32_t i = 0; i < nWorkers; ++i)
  {
    m_workers.push_back(std::make_shared<AsyncWorker_Functor>(m_dataQueue, m_results,
      AsyncWorker_Functor::Functor(&MiniSEEDWriterFilter_SensorInput::_workerFunc, this),
      m_logger));
  }
}

DataDescPtr MiniSEEDWriterFilter_SensorInput::_workerFunc(IAsyncWorker* pWorker, const DataDescPtr data)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_processDataImpl(data, pWorker);
}

DataDescPtr MiniSEEDWriterFilter_SensorInput::_processPSFData(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  //tss_harv::retrieve PDB object from data and check its type
  PSFDataDesc* const pPSFData = static_cast<PSFDataDesc*>(data);
  PSFDataElement* const pDataElement = pPSFData->getElement();
  if (pDataElement != nullptr)
  {
    MsgSensorInput* const pPacket = m_msgSensorInputsPool.new_object();
    if (pPacket && pPacket->restore(pDataElement))
    {
      const sequence_number_t sequenceNumber = pDataElement->getHeader()->sequenceNumber;
      ErrorDataDesc* const pErrorData = this->_processPacket(pPacket, sequenceNumber, userData);
      if (pErrorData != nullptr)
        return pErrorData;
      // track element processed
      const uint32_t elementSize = PSF_PAGES_to_BYTES(pDataElement->getHeader()->sizeInPages);
      this->_trackElementProcessed(elementSize);
    }
    else
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to retrieve information from Data Element");
    }
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "PSFDataElement invalid handle");
  }

  // return progress data
  return this->_makeProgress();
}

DataDescPtr MiniSEEDWriterFilter_SensorInput::_processPDBData(const DataDescPtr data, void* userData)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  //tss_harv::retrieve PDB object from data and check its type
  PDBDataDesc* const pPDBData = static_cast<PDBDataDesc*>(data);
  IPDBMsgObject* const pPDBObj = pPDBData->getObject();
  const PDB_eMessageType_t objType = pPDBObj->getType();
  //tss_harv::writing PDB log
  if (objType == PDB_eMessageType_t::MSG_SENSOR_INPUT_V0)
  {
    MsgSensorInput* const pPacket = static_cast<MsgSensorInput*>(pPDBObj);
    const sequence_number_t sequenceNumber = pPDBData->getSequenceNumber();
    ErrorDataDesc* const pErrorData = this->_processPacket(pPacket, sequenceNumber, userData);
    if (pErrorData != nullptr)
      return pErrorData;
    // track element processed
    constexpr uint32_t elementSize = sizeof(MsgSensorInput::Header);
    this->_trackElementProcessed(elementSize);
  }
  else
  {
    return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
      "Unsupported PDB object type %u. Only MSG_SENSOR_INPUT_V0 (%u) is supported",
      (uint32_t)objType,
      (uint32_t)PDB_eMessageType_t::MSG_SENSOR_INPUT_V0);
  }

  // return progress data
  return this->_makeProgress();
}

ErrorDataDesc* MiniSEEDWriterFilter_SensorInput::_processPacket(const MsgSensorInput* pPacket,
  const sequence_number_t sequenceNumber, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pPacket != nullptr && "pPakcet cannot be nullptr here!");
  //__ASSERT__((userData != nullptr) && "Method expects IAsyncWorker instance that does this job");
  // slice packet to slices
  const std::vector<sPacketSlice>& slices = m_slicer->slice(pPacket, sequenceNumber);
  const uint32_t nSlices = static_cast<uint32_t>(slices.size());
  if (nSlices > 0u)
  {
    size_t nBytesWritten = 0;
    for (uint32_t sliceIdx = 0; sliceIdx < nSlices; ++sliceIdx)
    {
      const sPacketSlice& slice = slices[sliceIdx];
      //get directory state for slice
      MiniSEEDDirectoryState* const pState = this->_getDirectoryState(slice);
      if (pState == nullptr)
      {
        return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
          "Failed to retrieve miniSEED state for packet");
      }

      //if it's not the last slice (considering that all slices belong to the same channel) -> it completes channel for file
      //Slicing is done to fit samples in specific file duration, so when one packet is spliced to multiple chunks -> each slice but last is considered as the last slice to append to file for channel
      const bool bCompletesChannel = (nSlices - sliceIdx > 1);

      //write packet and set lower and upper times
      const size_t sliceWrittenBytes = pState->writeSlice(slice, bCompletesChannel);
      if (sliceWrittenBytes > 0)
      {
        //update timestamps if required
        this->_trackTimerange(slice);
        nBytesWritten += sliceWrittenBytes;
      }
    }
    if (nBytesWritten <= 0)
    {
      return this->_makeError(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_FILTER_PROCESS_DATA_FAILED,
        "Failed to write the packet");
    }
    // update progress
    {
      m_progress.nFilesGenerated = 0u;
      for (const auto& state : m_mseedStates)
      {
        m_progress.nFilesGenerated += state.second->getFilesCount();
      }
    }
  }

  // return nullptr (no error indication)
  return nullptr;
}

MiniSEEDDirectoryState* MiniSEEDWriterFilter_SensorInput::_getDirectoryState(const sPacketSlice& packetSlice)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::get unique state code for the packet
  const std::string& outputDirectory = this->_getOutputDirectory(packetSlice);
  //tss_harv::find if the state is already created
  const auto foundIt = m_mseedStates.find(outputDirectory);
  if (foundIt != m_mseedStates.end())
  {
    return foundIt->second;
  }

  std::string workingDir = "";
  const std::string& outputDirFull = PlatformUtils::getInstance()->resolvePath(m_params.outputDir);
  //tss_harv::build full path for output miniSEED within this state (base path + decoded path)
  {
    const std::string& mergedFullPath = PlatformUtils::getInstance()->join(outputDirFull, outputDirectory);
    //tss_harv::trying to create base directory for mSEED files
    if (PlatformUtils::getInstance()->makePath(mergedFullPath))
    {
      //tss_harv::set decoded path as output path
      workingDir = mergedFullPath;
    }
    else
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to create '%s' path. Output path ('%s') will be used : %s",
        mergedFullPath.c_str(),
        outputDirFull.c_str(),
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      workingDir = outputDirFull;
    }
  }
  //tss_harv::creating new MiniSEED state
  const std::string& fileNamePattern = PlatformUtils::getInstance()->getBaseName(m_params.outputPattern);
  //tss_harv::detect amount of channels per file (If ${C} mnemonic persists -> each channel is in it's own file, otherwise - multiple channels per file)
  const uint8_t nChannelsPerFile = (m_params.outputPattern.find("${C}") != std::string::npos) ? 1 : PDB_MAXIMUM_CHANNELS_COUNT;
  std::unique_ptr<MiniSEEDDirectoryState> newStatePtr(new MiniSEEDDirectoryState(workingDir, fileNamePattern,
    m_params.nHoursPerFile, nChannelsPerFile, PDB_MAXIMUM_CHANNELS_COUNT,
    PDB_SENSOR_INPUT_FRAMES_COUNT, //set fixed frames count
    m_packetInfoProvider, m_logger));

  //tss_harv::append new state to states map and return it
  m_mseedStates.insert(std::make_pair(outputDirectory, newStatePtr.get()));
  return newStatePtr.release();
}
