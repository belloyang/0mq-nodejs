#ifndef MnemonicsDecoder_h__
#define MnemonicsDecoder_h__

#include "../harvlib_defines.h"

#include <Logger/ILogger.h>
#include "IPacketInfoProvider.h"

#include "buffers.h"

#include <cstring>

#include <memory>
#include <string>
#include <map>
#include <vector>

class MnemonicsDecoder
{
private:
  class StringStream
  {
  public:
    StringStream()
    : m_buffer(nullptr)
    , m_offset(0)
    {
      __DEV_CALLSTACK_FUNC__;
    }

    ~StringStream() = default;

    FORCE_INLINE size_t pos() const
    {
      __DEV_CALLSTACK_FUNC__;
      return m_offset;
    }

    FORCE_INLINE void reset(const std::shared_ptr< buffer_base<char> >& buffer)
    {
      __DEV_CALLSTACK_FUNC__;
      m_offset = 0;
      m_buffer = buffer;
    }

    FORCE_INLINE size_t write(const void* pData, const size_t size)
    {
      __DEV_CALLSTACK_FUNC__;
      if (size > 0)
      {
        m_buffer->realloc(m_offset + size);
        ::memcpy(m_buffer->ptr<char>() + m_offset, pData, size);
        m_offset += size;
      }
      return size;
    }

  private:
    std::shared_ptr<buffer_base<char>> m_buffer;
    size_t m_offset;

    // not implemented
    StringStream(const StringStream& rhs) = delete;
    StringStream& operator= (const StringStream&) = delete;
  };

public:
  /**
   * MnemonicsDecoder constructor
   * @param pattern             mnemonics pattern
   * @param packetInfoProvider  packet's information provider -> allow to request different packet's data to be used within mnemonic
   * @param timePrecisionNs     time precision in nanoseconds to be used to decode timestamps (e.i: can be 1 hours, 24hour, etc.)
   * @param logger              logger instance
   */
  MnemonicsDecoder(const std::string& pattern,
    const std::shared_ptr<IPacketInfoProvider>& packetInfoProvider, const timediff_t timePrecisionNs,
    const std::shared_ptr<ILogger>& logger);

  /**
   * MnemonicsDecoder destructor
   */
  ~MnemonicsDecoder() = default;

  /**
   * Checks if certain mnemonic ispresent in the pattern
   * @param mnemonic  mnemonic to check
   * @return true if mnemonic exists; false - otherwise
   */
  bool hasMnemonic(const std::string& mnemonic) const;

  /**
   * Decodes mnemonic pattern for the specific packet's slice and stores result into output string
   * @param slice    slice to be used for decoding
   * @param output   output string to store decoded data into
   */
  size_t decode(const sPacketSlice& slice, std::string& output);

  /**
   * Decodes mnemonic pattern for the specific packet's slice and stores result into output buffer
   * @param slice     slice to be used for decoding
   * @param buffer    output buffer to store decoded data into
   */
  size_t decode(const sPacketSlice& slice, const std::shared_ptr<buffer_base<char>>& buffer);

private:
  void _analyze();

  size_t _decodeTimeEntity(const sPacketSlice& slice, const char* timeFormat, StringStream& output) const;
  size_t _decodeTime(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeYear(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeMonth(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeDay(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeJDay(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeHour(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeMin(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeSec(const sPacketSlice& slice, StringStream& output) const;

  size_t _decodeNetwork(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeStation(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeChannelName(const sPacketSlice& slice, StringStream& output) const;
  size_t _decodeChannelLocation(const sPacketSlice& slice, StringStream& output) const;

private:
  const std::string m_pattern;
  const std::shared_ptr<IPacketInfoProvider> m_packetInfoProvider;
  const timediff_t m_timePrecisionNs;
  const std::shared_ptr<ILogger> m_logger;
  typedef size_t(MnemonicsDecoder::*DecoderFunc)(const sPacketSlice&, StringStream&) const;
#define DECODER_FUNC(func) reinterpret_cast<DecoderFunc>(&func)
  std::map< std::string, DecoderFunc> m_decoderFuncs;
  struct sOccurrence
  {
    std::string mnemonic;
    uint32_t position;
  };
  std::vector<sOccurrence> m_occurrences;
  StringStream m_decodeStream;
  const std::shared_ptr< buffer_base<char> > m_buffer;
  mutable char m_alignedTimeBuff[16]; //buffer needed for the longest entity ${TIME} (YYYYMMDD_hhmmss) + 1 symbol for '\0'
};

#endif //PathBuilder_h__
