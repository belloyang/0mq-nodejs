#include "IAsyncFilter.h"

IAsyncFilter::IAsyncFilter(const std::string& name, const uint32_t maxQueueSize,
  const std::shared_ptr<ILogger>& logger)
:  IBaseFilter(name, logger)
,  m_maxQueueSize(maxQueueSize)
,  m_bFinishRequested(false)
{
  __DEV_CALLSTACK_FUNC__;
}

IAsyncFilter::~IAsyncFilter()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::request hard stop
  m_bStopRequested = true;
  // stop async workers and wait till done
  this->_stopWorkers(true);
}

void IAsyncFilter::requestStop()
{
  __DEV_CALLSTACK_FUNC__;
  // request filter stop
  m_bStopRequested = true;
  // stop async workers (do not wait till done because it's forced stop, we do not care about output integrity)
  this->_stopWorkers(false);
}

ErrorDataDesc* IAsyncFilter::run(const Config* pConfig)
{
  __DEV_CALLSTACK_FUNC__;
  // create async workers
  this->_createWorkers();
  // init input data queue (workers read from it)
  m_dataQueue.init(m_maxQueueSize);
  // PGWU-420:
  // 1) Input queue can block the main thread when full waiting on any worker to process it and free up the space
  // 2) Output queue can block the workers thread when full waiting on the main thread to process it (free up space)
  // 1 & 2 can cause the "deadlock".
  // We have some extra capacity for output queue so it never blocks any worker:
  //   workers can still wait on data for processing to appear on input queue, but
  //   never wait for the queue to store data processed which gets emptied by the main thread -> no deadlock
  m_results.init(m_maxQueueSize + m_workers.size());
  // start async workers
  this->_startWorkers();
  //tss_harv::fallback to the default functionality
  return IBaseFilter::run(pConfig);
}

void IAsyncFilter::processData(const DataDescPtr data, void* /*userData*/)
{
  __DEV_CALLSTACK_FUNC__;
  // push data to async queue (wait for free space in the queue)
  m_dataQueue.push_back(data, true);
}

ErrorDataDesc* IAsyncFilter::update()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::process results on update (update is called on initial thread)
  this->_processResults();
  //tss_harv::fallback to the default behaviour
  return IBaseFilter::update();
}

ErrorDataDesc* IAsyncFilter::finalize(const sHarvestOpReport* pReport)
{
  __DEV_CALLSTACK_FUNC__;
  m_bFinishRequested = true;
  //tss_harv::stop waiting for data
  m_dataQueue.stop_waiting();
  //tass_harv::finish all the workers (with waiting for finalization)
  this->_finishWorkers(true);
  //tss_harv::process results that might remain in the results queue
  this->_processResults();
  //tss_harv::fallback to the default functionality
  return IBaseFilter::finalize(pReport);
}

void IAsyncFilter::_startWorkers()
{
  __DEV_CALLSTACK_FUNC__;
  for (const auto& worker : m_workers)
  {
    worker->start();
  }
}
void IAsyncFilter::_finishWorkers(const bool wait)
{
  __DEV_CALLSTACK_FUNC__;
  for (const auto& worker : m_workers)
  {
    worker->requestFinish();
  }
  // if wait (wait till each worker is done). It's done in the separate loop as we want to request stop asap in stop#all -> wait#all, not in stop#1 -> wait#1 -> stop#2 -> wait #2 ->....
  if (wait)
  {
    for (const auto& worker : m_workers)
    {
      worker->wait();
    }
  }
}
void IAsyncFilter::_stopWorkers(const bool wait)
{
  __DEV_CALLSTACK_FUNC__;
  // request stop for each worker
  for (const auto& worker : m_workers)
  {
    worker->requestStop();
  }
  // if wait (wait till each worker is done). It's done in the separate loop as we want to request stop asap in stop#all -> wait#all, not in stop#1 -> wait#1 -> stop#2 -> wait #2 ->....
  if (wait)
  {
    for (const auto& worker : m_workers)
    {
      worker->wait();
    }
  }
}

DataDescPtr IAsyncFilter::_workerFunc(IAsyncWorker* pWorker, const DataDescPtr data)
{
  __DEV_CALLSTACK_FUNC__;
  return this->_processDataImpl(data, pWorker);
}

void IAsyncFilter::_processResults()
{
  __DEV_CALLSTACK_FUNC__;
  // process results queue. Do not wait for elements to appear on the queue. Just process ones that have been pushed and let the thread to proceed further
  DataDescPtr data = nullptr;
  while (m_results.pop_front(&data, false))
  {
    if (m_successor != nullptr)
    {
      // pass result down the filters chain
      m_successor->processData(data, nullptr);
    }
  }
}
