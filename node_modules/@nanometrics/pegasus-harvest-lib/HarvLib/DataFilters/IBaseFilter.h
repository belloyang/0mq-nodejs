#ifndef IBaseFilter_h__
#define IBaseFilter_h__

#include "../harvlib_defines.h"

#include "Data/IDataDesc.h"

#include "mem_pool.h"

#include <Logger/ILogger.h>
#include <func_ptr.h>

#include <string>
#include <memory>
#include <vector>

#include <atomic>

class ErrorDataDesc;

/**
 * IBaseFilter - basic class/interface for harvesting filters
 */
class IBaseFilter
{
protected:
  typedef func_ptr<DataDescPtr(const DataDescPtr, void* userData)> HandlerFunc;
  IBaseFilter(const std::string& name, const std::shared_ptr<ILogger>& logger);

public:
  struct Config
  {
    timestamp_t startTime = 0ll; // harvesting start time
    PDB_eVolumeID volumeID = PDB_eVolumeID::VOLUME_NONE;
    sSequenceRange sequenceRange; // data seuqnce range that should be harvested
    sTimespan timeRange; // requested time range for harvesting
  };
  virtual ~IBaseFilter() = default;

  FORCE_INLINE const std::string& getName() const { return m_name; }

/**
 * Sets successor filter (filter that process data is being passed to)
 * @param filter  filter to pass process data to
 */
  FORCE_INLINE void setSuccessor(const std::shared_ptr<IBaseFilter>& filter) { m_successor = filter; }
  FORCE_INLINE const std::shared_ptr<IBaseFilter>& getSuccessor() const { return m_successor; }

  /**
   * Runs filter (does initialization, etc.)
   * @return  error descriptor if any occured; nullptr - on success
   */
  virtual ErrorDataDesc* run(const Config* pConfig);
  /**
   * processes accepted data
   * @param data  data to process
   */
  virtual void processData(const DataDescPtr data, void* userData);
  /**
   * Updates filter (filter step)
   * @return  error descriptor if any occured; nullptr - on success
   */
  virtual ErrorDataDesc* update();
  /**
   * Finalizes filter execution
   * @param data  finalization data
   * @return  error descriptor if any occured; nullptr - on success
   */
  virtual ErrorDataDesc* finalize(const sHarvestOpReport* pReport);

  virtual void requestStop() { m_bStopRequested = true; }

protected:
  DataDescPtr _processDataImpl(const DataDescPtr data, void* userData);
  void _registerDataHandler(const IDataDesc::eType type, const HandlerFunc& handler);
  ErrorDataDesc* _makeError(const char* scope, const eErrorCategory category, const uint32_t errorCode,
    const char* format, ...);

protected:
  std::vector<HandlerFunc> m_dataHandlersMap;
  const std::string m_name;
  const std::shared_ptr<ILogger> m_logger;
  std::shared_ptr<IBaseFilter> m_successor;
  std::atomic<bool> m_bStopRequested;

  mem_pool<ErrorDataDesc(const IBaseFilter*, const eErrorCategory, const uint32_t)> m_errorsPool;

private:
  DataDescPtr NullHandler(const DataDescPtr data, void* /*userData*/) { return data; }
};

#endif //IBaseFilter_h__
