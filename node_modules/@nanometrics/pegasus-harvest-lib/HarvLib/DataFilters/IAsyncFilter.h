#ifndef IAsyncFilter_h__
#define IAsyncFilter_h__

#include "IBaseFilter.h"

#include "async_queue.h"
#include "IAsyncWorker.h"

#include <atomic>
#include <memory>

/**
 * Async filter. Performs data processing on the separate thread.
 */
class IAsyncFilter : public IBaseFilter
{
protected:
  IAsyncFilter(const std::string& name, const uint32_t maxQueueSize, const std::shared_ptr<ILogger>& logger);

public:
  virtual ~IAsyncFilter();

  virtual ErrorDataDesc* run(const Config* pConfig) __OVERRIDES__(IBaseFilter);
  virtual void processData(const DataDescPtr data, void* userData) __OVERRIDES__(IBaseFilter);
  virtual ErrorDataDesc* update() __OVERRIDES__(IBaseFilter);
  virtual ErrorDataDesc* finalize(const sHarvestOpReport* pReport) __OVERRIDES__(IBaseFilter);
  virtual void requestStop() __OVERRIDES__(IBaseFilter);

protected:
  virtual void _createWorkers() = 0;
  void _startWorkers();
  void _finishWorkers(const bool wait);
  void _stopWorkers(const bool wait);
  DataDescPtr _workerFunc(IAsyncWorker* pWorker, const DataDescPtr data);
  void _processResults();

protected:
  const uint32_t m_maxQueueSize;
  //! atomic (thread-safe) flag for finish request (soft stop - awaits till all collected data processed)
  std::atomic<bool> m_bFinishRequested;
  typedef async_queue<DataDescPtr> DataQueue_t;
  DataQueue_t m_dataQueue;
  DataQueue_t m_results;
  std::vector<std::shared_ptr<IAsyncWorker>> m_workers;
};

#endif //IAsyncFilter_h__
