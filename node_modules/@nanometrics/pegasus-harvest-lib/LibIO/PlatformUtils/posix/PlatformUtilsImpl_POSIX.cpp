#include "PlatformUtilsImpl_POSIX.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/utsname.h> //for uname
#if defined(DEV_PLATFORM_LINUX)
  #include <linux/sysctl.h>
  #include <pthread.h>
  #include <sched.h>
#else
  #include <sys/sysctl.h>
  #include <Kernel/mach/thread_policy.h>
  #include <Kernel/mach/thread_act.h>
  #include <cpuid.h>
#endif
#include <unistd.h>
#include <limits.h>
#include <errno.h>
#include <cstring>
#include <cstdio>
#include <algorithm>

namespace
{
  const char PATH_SEPARATOR = '/';
}

PlatformUtilsImpl_POSIX::PlatformUtilsImpl_POSIX(const std::shared_ptr<ILogger>& logger)
  : IPlatformUtilsImpl(logger)
{
  __DEV_CALLSTACK_FUNC__;
  ::umask(0); // required to set 0777 permissions properly
  //retrieve OS and kernel info
  {
    struct utsname unameInfo;
    if (::uname(&unameInfo) == 0)
    {
      m_platformDesc.os = std::string(unameInfo.sysname);
      m_platformDesc.kernel = std::string(unameInfo.release);
    }
    else
    {
      const uint32_t errorId = this->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorId,
          "Failed to run 'uname': %s", this->getErrorString(errorId).c_str());
    }
  }
  
  //get platform
  {
    __TO_DO__("Get platform name!");
    m_platformDesc.platform = "N/A";
  }
  
  //get BIOS info
  {
    __TO_DO__("Get BIOS info");
    m_platformDesc.bios = "N/A";
  }
  
  //get CPU info
  {
#if defined(DEV_PLATFORM_LINUX)
    {
      FILE* cmd = ::popen("grep -m 1 '^model name' /proc/cpuinfo | sed 's/^.*: //'", "r");
      if (cmd != nullptr)
      {
        char buff[512];
        while (!::feof(cmd))
        {
          const int nBytesRead = ::fread(buff, 1, sizeof(buff), cmd);
          if (nBytesRead > 0)
            //build CPU info string (cut off '\n' character at the end)
            m_platformDesc.cpu += std::string(buff, nBytesRead - 1);
        }
        ::fclose(cmd);
      }
    }
#elif defined(DEV_PLATFORM_MACOS)
    {
      const char* var = "machdep.cpu.brand_string";
      size_t len = 0;
      ::sysctlbyname(var, nullptr, &len, nullptr, 0);
      if (len > 0)
      {
        //allocate buffer to keep string
        void* buffer = ::malloc(len);
        ::sysctlbyname(var, buffer, &len, nullptr, 0);
        m_platformDesc.cpu = std::string(reinterpret_cast<const char*>(buffer), len);
        ::free(buffer);
      }
    }
#endif
  }
  
  //get RAM info
  {
    const long int pagesCount = ::sysconf(_SC_PHYS_PAGES);
    const long int pageSize = ::sysconf(_SC_PAGESIZE);
    const uint64_t totalSizeBytes = static_cast<uint64_t>(pagesCount) * pageSize;
    const uint64_t totalSizeGiB = totalSizeBytes / (1024 * 1024 * 1024);
    m_platformDesc.ram = std::to_string(totalSizeGiB) + " GiB";
  }
  
  //get disk info
  {
    __TO_DO__("Get disk info. We cannot use ioctl(/dev/sda, HDIO_GET_IDENTITY, &struct) as it doesn't work for SCSI devices!"
        "Look for enhanced method");
    m_platformDesc.disk = "N/A";
  }
}

bool PlatformUtilsImpl_POSIX::isAbsolutePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::absolute path on Unix starts with '/'
  if (!path.empty() && path[0] == PATH_SEPARATOR)
    return true;

  return false;
}

bool PlatformUtilsImpl_POSIX::isDirExists(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  struct stat info;
  if (::stat(path.c_str(), &info) != 0)
    return false;

  return (info.st_mode & S_IFDIR) != 0;
}

std::string PlatformUtilsImpl_POSIX::getCurrentDirectory() const
{
  __DEV_CALLSTACK_FUNC__;
  char cwd[PATH_MAX + 1];
  if (::getcwd(cwd, NUM_ELEMENTS(cwd)) != NULL)
    return std::string(cwd);
  return "";
}

bool PlatformUtilsImpl_POSIX::makePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const mode_t mode = (S_IRWXU | S_IRWXG | S_IRWXO);
  const int ret = ::mkdir(path.c_str(), mode);
  if (ret == 0)
      return true;

  switch (errno)
  {
    case ENOENT:
    {
      std::string::size_type pos = path.find_last_of(PATH_SEPARATOR);
      if (pos == std::string::npos)
        pos = path.find_last_of('\\');
      if (pos == std::string::npos)
        return false;
      if (!this->makePath(path.substr(0, pos)))
        return false;
      // now, try to create again
      return (::mkdir(path.c_str(), mode) == 0);
    }
    break;

    case EEXIST:
    	return true;

    case EISDIR: // macOS can report this one trying to create existing directory (e.i: root ("/") directory)
    	return true;

    default:
      return false;
  }

  return false;
}

std::string PlatformUtilsImpl_POSIX::join(const std::string& path1, const std::string& path2) const
{
  __DEV_CALLSTACK_FUNC__;
  char outputBuffer[PATH_MAX];
  ::snprintf(outputBuffer, PATH_MAX, "%s%c%s", path1.c_str(), PATH_SEPARATOR, path2.c_str());
  return std::string(outputBuffer);
}

std::string PlatformUtilsImpl_POSIX::normalize(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string ret = path;
  std::replace(ret.begin(), ret.end(), '\\', PATH_SEPARATOR);
  return ret;
}

bool PlatformUtilsImpl_POSIX::isPhysicalDrivePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined (DEV_PLATFORM_LINUX)
    return (::strncmp(path.c_str(), "/dev/", 5) == 0);
#elif defined(DEV_PLATFORM_MACOS)
    return ((::strncmp(path.c_str(), "/dev/disk", 9) == 0) ||
      (::strncmp(path.c_str(), "/dev/rdisk", 10) == 0));
#endif
}

std::string PlatformUtilsImpl_POSIX::fixDevicePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return path;
}

std::string PlatformUtilsImpl_POSIX::mapLogicalPathToPhysical(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_MACOS)
  // if is not physical drive -> return
  if (this->isPhysicalDrivePath(path))
  {
    // fetch disk part (without '/dev/')
    const std::string endPart = path.substr(5);
    // search for "s" (e.i. disk#s#)
    const std::string::size_type sPos = endPart.substr(4).find_last_of("s");
    std::string disk = endPart;
    if (sPos != std::string::npos)
      disk = endPart.substr(0, sPos + 5);
    if (::strncmp(disk.c_str(), "rdisk", 5) == 0)
      return std::string("/dev/") + disk;
    return std::string("/dev/r") + disk;
  }
#endif
  return path;
}

bool PlatformUtilsImpl_POSIX::unmountAll(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!this->isPhysicalDrivePath(path))
    return false;
  //path start with "/dev/"
  const std::string endPart = path.substr(5);
  std::string diskPart = endPart;
  if (diskPart[0] == 'r') //rdisk
    diskPart = diskPart.substr(1);
  // try unmount partitions
  for (int i = 1; i < 4; ++i)
  {
    const std::string drive = std::string("/dev/") + diskPart + "s" + std::to_string(i);
    m_logger->debug(__THIS_FUNC__, "Unmounting %s", drive.c_str());
    const std::string command = std::string("umount -f ") + drive;
    const int ret = ::system(command.c_str()); __UNUSED__(ret); //'system' calls warns unused resulkt -> fake its usage 
  }

  return true;
}

uint32_t PlatformUtilsImpl_POSIX::getLastErrorCode() const
{
  __DEV_CALLSTACK_FUNC__;
  return (uint32_t)errno;
}

std::string PlatformUtilsImpl_POSIX::getErrorString(const uint32_t errorID) const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string(::strerror(errorID));
}

std::string PlatformUtilsImpl_POSIX::getLastErrorString() const
{
  __DEV_CALLSTACK_FUNC__;
  return this->getErrorString(this->getLastErrorCode());
}

const sPlatformDesc_t& PlatformUtilsImpl_POSIX::getPlatformDesc() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_platformDesc;
}

//std::thread::native_handle() actually returns pthread_t
// so pthread_* can be used here to implement missing C++11 std::thread functionality
ThreadHandle_t PlatformUtilsImpl_POSIX::getCurrentThread() const
{
  __DEV_CALLSTACK_FUNC__;
  const pthread_t thread = pthread_self();
  // mask pthread_t into void*
  return static_cast<ThreadHandle_t>(thread);
}

bool PlatformUtilsImpl_POSIX::setThreadAffinityMask(ThreadHandle_t handle, const uint32_t mask) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_LINUX)
  cpu_set_t set;
  ::memset(&set, 0, sizeof(cpu_set_t));
  uint8_t cpu = 0u;
  uint32_t _mask = mask;
  while (_mask > 0) {
    // check if the lowest bit is set -> set current CPU in affinity mask
    if ((_mask & 0x1) != 0) {
      CPU_SET(cpu, &set);
    }
    // shift mask bits and go to the next CPU
    _mask >>= 1;
    ++cpu;
  }
  pthread_t thread = static_cast<pthread_t>(handle);
  const int ret = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &set);
  return (ret == 0);
#else
  pthread_t thread = static_cast<pthread_t>(handle);
  const mach_port_t mach_thread = pthread_mach_thread_np(thread);
  thread_affinity_policy_data_t policy; {
    policy.affinity_tag = mask;
  }
  const kern_return_t result = thread_policy_set(mach_thread, THREAD_AFFINITY_POLICY, (thread_policy_t)&policy, THREAD_AFFINITY_POLICY_COUNT);
  return (result == 0);
#endif
}

uint32_t PlatformUtilsImpl_POSIX::getCurrentProcessorNumber() const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_LINUX)
  return static_cast<uint32_t>(sched_getcpu());
#else //MacOS
  //en.wikipedia.org/wiki/CPUID
  uint32_t cpu_info[4];
  __cpuid(1, cpu_info[0], cpu_info[1], cpu_info[2], cpu_info[3]);
  const uint32_t APIC_BIT_NUMBER = 9;
  if (cpu_info[3]/*EDX*/ & (1 << APIC_BIT_NUMBER))
  {
    return (cpu_info[1]/*EAX*/ >> 24); // maximum of 256 cores
  }
  return 0;
#endif
}
