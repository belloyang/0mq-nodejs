#include "PlatformUtilsImpl_Win32.h"

#include "../../IOContext/win32/FileIOContext_Windows.h"

#include <Windows.h>

// The following group of #include statements needed for the std::string trim methods.
#include <algorithm>
#include <functional>
#include <cctype>
#include <cstdio>

#pragma comment(lib, "wbemuuid.lib")
#define _WIN32_DCOM
#include <iostream>
#include <comdef.h>
#include <Wbemidl.h>

// begin: anonymous namespace
namespace
{
  const char PATH_SEPARATOR = '\\';
  const std::string PHYSICAL_PATH_MASK = "\\\\.\\PHYSICALDRIVE";

  /**
   * @brief Left Trim
   *
   * Trims whitespace from the left end of the provided std::string
   *
   * @param[out] s The std::string to trim
   *
   * @return The modified std::string&
   */
  std::string& ltrim(std::string& s)
  {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::ptr_fun<int, int>(std::isgraph)));
    return s;
  }

  /**
   * @brief Right Trim
   *
   * Trims whitespace from the right end of the provided std::string
   *
   * @param[out] s The std::string to trim
   *
   * @return The modified std::string&
   */
  std::string& rtrim(std::string& s)
  {
    s.erase(std::find_if(s.rbegin(), s.rend(), std::ptr_fun<int, int>(std::isgraph)).base(), s.end());
    return s;
  }

  /**
   * @brief Trim
   *
   * Trims whitespace from both ends of the provided std::string
   *
   * @param[out] s The std::string to trim
   *
   * @return The modified std::string&
   */
  std::string& trim(std::string& s)
  {
    return ltrim(rtrim(s));
  }

}
// end: anonymous namespace

PlatformUtilsImpl_Win32::PlatformUtilsImpl_Win32(const std::shared_ptr<ILogger>& logger)
  : IPlatformUtilsImpl(logger)
{
  __DEV_CALLSTACK_FUNC__;
  //get RAM size
  {
    ULONGLONG physicalMemorySizeKiB = 0ULL;
    if (::GetPhysicallyInstalledSystemMemory(&physicalMemorySizeKiB))
    {
      const uint64_t sizeInGB = static_cast<uint64_t>(physicalMemorySizeKiB) / (1024ULL * 1024ULL);
      m_platformDesc.ram = std::to_string(sizeInGB) + " GiB";
    }
    else
    {
      const uint32_t errorCode = this->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to retrieve physical memory size: %s", this->getErrorString(errorCode).c_str());
    }
  }

  //get platform
  {
    __TO_DO__("Get platform name!");
    m_platformDesc.platform = "N/A";
  }

  //initialize COM interface
  HRESULT hres = ::CoInitializeEx(0, COINIT_MULTITHREADED);
  if (SUCCEEDED(hres))
  {
    // Set general COM security levels 
    hres = ::CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    if (SUCCEEDED(hres))
    {
      // Obtain the initial locator to WMI -------------------------
      IWbemLocator *pLoc = NULL;
      hres = ::CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *)&pLoc);
      if (SUCCEEDED(hres)) 
      {
        // Connect to WMI through the IWbemLocator::ConnectServer method
        IWbemServices *pSvc = NULL;
        // Connect to the root\cimv2 namespace with the current user and obtain pointer pSvc to make IWbemServices calls.
        hres = pLoc->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
        if (SUCCEEDED(hres))
        {
          // Set security levels on the proxy -------------------------
          hres = CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
          if (SUCCEEDED(hres))
          {
            //retrieve OS info (https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-operatingsystem)
            {
              IEnumWbemClassObject* pEnumerator = NULL;
              hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Caption, OSArchitecture, Version FROM Win32_OperatingSystem"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
              if (SUCCEEDED(hres))
              {
                IWbemClassObject *pClsObj = NULL;
                ULONG uReturn = 0;
                while (pEnumerator)
                {
                  HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pClsObj, &uReturn);
                  if (FAILED(hr) || uReturn == 0)
                    break;

                  VARIANT vtProp;
                  //retrieve caption
                  if (SUCCEEDED(pClsObj->Get(L"Caption", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR) {
                    m_platformDesc.os = std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }
                  //retrieve architecture (32/64 bit, etc.)
                  if (SUCCEEDED(pClsObj->Get(L"OSArchitecture", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR) {
                    m_platformDesc.kernel = "Windows " + std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }
                  //retrieve version
                  if (SUCCEEDED(pClsObj->Get(L"Version", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR) {
                    m_platformDesc.kernel += ", v" + std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }

                  //release response object
                  pClsObj->Release();
                }
                //release enumenator
                pEnumerator->Release();
              }
            }

            //retrieve BIOS info (https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-bios)
            {
              IEnumWbemClassObject* pEnumerator = NULL;
              hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Manufacturer, Caption FROM Win32_BIOS"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
              if (SUCCEEDED(hres))
              {
                IWbemClassObject *pClsObj = NULL;
                ULONG uReturn = 0;
                while (pEnumerator)
                {
                  HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pClsObj, &uReturn);
                  if (FAILED(hr) || uReturn == 0)
                    break;

                  VARIANT vtProp;
                  //get manufacturer
                  if (SUCCEEDED(pClsObj->Get(L"Manufacturer", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR) {
                    m_platformDesc.bios = std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }
                  //get caption
                  if (SUCCEEDED(pClsObj->Get(L"Caption", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR) {
                    m_platformDesc.bios += std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }

                  //release response object
                  pClsObj->Release();
                }
                //release enumenator
                pEnumerator->Release();
              }
            }

            //retrieve processor info (https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-processor)
            {
              IEnumWbemClassObject* pEnumerator = NULL;
              hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Name FROM Win32_Processor"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
              if (SUCCEEDED(hres))
              {
                IWbemClassObject *pClsObj = NULL;
                ULONG uReturn = 0;
                while (pEnumerator)
                {
                  HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pClsObj, &uReturn);
                  if (FAILED(hr) || uReturn == 0)
                    break;

                  VARIANT vtProp;
                  //get name
                  if (SUCCEEDED(pClsObj->Get(L"Name", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR)
                  {
                    m_platformDesc.cpu = std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }

                  //release response object
                  pClsObj->Release();
                }
                //release enumenator
                pEnumerator->Release();
              }
            }

            //retrieve disk drive info (https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-diskdrive)
            {
              IEnumWbemClassObject* pEnumerator = NULL;
              hres = pSvc->ExecQuery(bstr_t("WQL"), bstr_t("SELECT Caption, MediaType FROM Win32_DiskDrive"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator);
              if (SUCCEEDED(hres))
              {
                IWbemClassObject *pClsObj = NULL;
                ULONG uReturn = 0;
                while (pEnumerator)
                {
                  HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pClsObj, &uReturn);
                  if (FAILED(hr) || uReturn == 0)
                    break;

                  VARIANT vtProp;
                  //get MediaType
                  if (SUCCEEDED(pClsObj->Get(L"MediaType", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR)
                  {
                    std::string mediaType = std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                    //skip media types other then fixed hard disk
                    if (mediaType != "Fixed hard disk media")
                      continue;
                  }

                  //get caption
                  if (SUCCEEDED(pClsObj->Get(L"Caption", 0, &vtProp, 0, 0)) && vtProp.vt == VT_BSTR)
                  {
                    m_platformDesc.disk = std::string(_bstr_t(vtProp.bstrVal, FALSE));
                    ::VariantClear(&vtProp);
                  }

                  //release response object
                  pClsObj->Release();
                }
                //release enumenator
                pEnumerator->Release();
              }
            }
          }
          //release service
          pSvc->Release();
        }
        //release pLoc
        pLoc->Release();
      }
      else
      {
        _com_error err(hres);
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, (uint32_t)hres,
          "Failed to connect to 'ROOT\\CIMV2' server: %s",
          (const char*)err.Description());
      }
    }
    else
    {
      _com_error err(hres);
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, (uint32_t)hres,
        "Failed to initialize COM secutiry: %s",
        (const char*)err.Description());
    }
  }
  else
  {
    _com_error err(hres);
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, (uint32_t)hres,
      "Failed to initialize COM: %s",
      (const char*)err.Description());
  }

  //uninitialize COM interface
  ::CoUninitialize();
}

PlatformUtilsImpl_Win32::~PlatformUtilsImpl_Win32()
{
  __DEV_CALLSTACK_FUNC__;
}

bool PlatformUtilsImpl_Win32::isAbsolutePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::absolute path on Windows starts with drive letter and ':'
  if (path.find_first_of(':') != std::string::npos)
    return true;

  return false;
}

bool PlatformUtilsImpl_Win32::isDirExists(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const DWORD attributes = ::GetFileAttributesA(path.c_str());
  if (attributes == INVALID_FILE_ATTRIBUTES)
    return false;

  return (attributes & FILE_ATTRIBUTE_DIRECTORY);
}

std::string PlatformUtilsImpl_Win32::getCurrentDirectory() const
{
  __DEV_CALLSTACK_FUNC__;
  char buf[MAX_PATH + 1] = { 0 };
  const DWORD ret = ::GetCurrentDirectoryA(NUM_ELEMENTS(buf), buf);
  if (ret != 0)
    return std::string(buf);

  return "";
}

bool PlatformUtilsImpl_Win32::makePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string::size_type pos = 0;
  do
  {
    pos = path.find_first_of("\\/", pos + 1);
    const std::string rootPath = path.substr(0, pos);
    //tss_libio::check if rootPath is logic drive
    if (!this->isDirExists(rootPath))
    {
      const BOOL bCreated = ::CreateDirectoryA(rootPath.c_str(), NULL);
      if (bCreated == FALSE)
      {
        const uint32_t errorCode = this->getLastErrorCode();
        if (errorCode != ERROR_ALREADY_EXISTS)
        {
          m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode, 
            "Failed to create '%s' - %s", 
            rootPath.c_str(), this->getErrorString(errorCode).c_str());
          return false;
        }
      }
    }
  } while (pos != std::string::npos);

  return true;
}

std::string PlatformUtilsImpl_Win32::join(const std::string& path1, const std::string& path2) const
{
  __DEV_CALLSTACK_FUNC__;
  char outputBuffer[MAX_PATH];
  ::snprintf(outputBuffer, MAX_PATH, "%s%c%s", path1.c_str(), PATH_SEPARATOR, path2.c_str());
  return std::string(outputBuffer);
}

std::string PlatformUtilsImpl_Win32::normalize(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string ret = path;
  std::replace(ret.begin(), ret.end(), '/', PATH_SEPARATOR);
  return ret;
}

bool PlatformUtilsImpl_Win32::isPhysicalDrivePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  if (path.length() < PHYSICAL_PATH_MASK.length())
    return false;
  for (size_t i = 0; i < PHYSICAL_PATH_MASK.length(); i++)
  {
    if (::toupper(path[i]) != PHYSICAL_PATH_MASK[i])
      return false;
  }
  return true;
}

std::string PlatformUtilsImpl_Win32::fixDevicePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  if (::isalpha(path[0]))
    return std::string("\\\\.\\") + path;//e.i: E: -> \\.\E:
  return path;
}

std::string PlatformUtilsImpl_Win32::mapLogicalPathToPhysical(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  std::string ret = path;
  const std::shared_ptr<FileIOContext_Windows> context = std::make_shared<FileIOContext_Windows>(path,
    GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, m_logger);

  //if path is opened -> fetch physical drive number through disk extents
  const HANDLE handle = context->getHandle();
  if (handle != INVALID_HANDLE_VALUE)
  {
    //tss_libio::request disk extents
    VOLUME_DISK_EXTENTS diskExtents; ::memset(&diskExtents, 0, sizeof(diskExtents));
    DWORD bytesReturned = 0;
    if (::DeviceIoControl(handle, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0,
      &diskExtents, sizeof(diskExtents),
      &bytesReturned, NULL))
    {
      ret = PHYSICAL_PATH_MASK + std::to_string(diskExtents.Extents[0].DiskNumber);
    }
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, this->getLastErrorCode(),
      "failed to open %s (%s)",
      path.c_str(), this->getLastErrorString().c_str());
  }

  return ret;
}

bool PlatformUtilsImpl_Win32::unmountAll(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  //this ufncitonality is not needed for Windows for the moment
  return false;
}

uint32_t PlatformUtilsImpl_Win32::getLastErrorCode() const
{
  __DEV_CALLSTACK_FUNC__;
  return (uint32_t)::GetLastError();
}

std::string PlatformUtilsImpl_Win32::getErrorString(const uint32_t errorID) const
{
  __DEV_CALLSTACK_FUNC__;
  if (errorID == 0)
    return std::string("NO ERROR");

  //tss_libio::get error string
  LPSTR messageBuffer = nullptr;
  const size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL, errorID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
  std::string ret(messageBuffer, size);
  // FormatMessageA leaves a <CR><LF> at the end of the string, so it's polite to remove that.
  trim(ret);
  //tss_libio::free message buffer (captured/copied by ret string)
  ::LocalFree(messageBuffer);
  return std::string("Error code ") + std::to_string(errorID) + ": " + ret;
}

std::string PlatformUtilsImpl_Win32::getLastErrorString() const
{
  __DEV_CALLSTACK_FUNC__;
  return this->getErrorString(this->getLastErrorCode());
}

const sPlatformDesc_t& PlatformUtilsImpl_Win32::getPlatformDesc() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_platformDesc;
}

ThreadHandle_t PlatformUtilsImpl_Win32::getCurrentThread() const
{
  __DEV_CALLSTACK_FUNC__;
  return static_cast<ThreadHandle_t>(::GetCurrentThread());
}

bool PlatformUtilsImpl_Win32::setThreadAffinityMask(ThreadHandle_t handle, const uint32_t mask) const
{
  __DEV_CALLSTACK_FUNC__;
  const DWORD_PTR res = ::SetThreadAffinityMask(static_cast<HANDLE>(handle), DWORD_PTR(mask));
  // If the function succeeds, the return value is the thread's previous affinity mask.
  // If the function fails, the return value is zero.To get extended error information, call GetLastError.
  return (res != 0);
}

uint32_t PlatformUtilsImpl_Win32::getCurrentProcessorNumber() const
{
  __DEV_CALLSTACK_FUNC__;
  return static_cast<uint32_t>(::GetCurrentProcessorNumber());
}
