#include "PlatformUtils.h"

#include "../Logger/ConsoleLogger.h"

#if defined(DEV_PLATFORM_WIN32)
  #include "win32/PlatformUtilsImpl_Win32.h"
#elif defined(DEV_PLATFORM_LINUX) || defined(DEV_PLATFORM_MACOS)
  #include "posix/PlatformUtilsImpl_POSIX.h"
#endif

#include <thread>

PlatformUtils* PlatformUtils::s_instance = nullptr;

/*static*/ PlatformUtils* PlatformUtils::getInstance()
{
  __DEV_CALLSTACK_FUNC__;
  if (s_instance == nullptr)
  {
    s_instance = new PlatformUtils();
  }
  __ASSERT__(s_instance != nullptr && "Failed to create PlatformUtils instance");
  return s_instance;
}

PlatformUtils::PlatformUtils()
  : m_impl(nullptr)
  , m_logger(std::make_shared<ConsoleLogger>(512))
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_WIN32)
  m_impl = new PlatformUtilsImpl_Win32(m_logger);
#elif defined(DEV_PLATFORM_LINUX) || defined(DEV_PLATFORM_MACOS)
  m_impl = new PlatformUtilsImpl_POSIX(m_logger);
#endif
}

PlatformUtils::~PlatformUtils()
{
  __DEV_CALLSTACK_FUNC__;
  delete m_impl;
}

bool PlatformUtils::isAbsolutePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->isAbsolutePath(path);
}

bool PlatformUtils::isDirExists(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->isDirExists(path);
}

std::string PlatformUtils::getCurrentDirectory() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getCurrentDirectory();
}

bool PlatformUtils::makePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->makePath(path);
}

std::string PlatformUtils::join(const std::string& path1, const std::string& path2) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->join(path1, path2);
}

std::string PlatformUtils::normalize(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->normalize(path);
}

std::string PlatformUtils::resolvePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const bool bIsAbsolute = m_impl->isAbsolutePath(path);
  if (bIsAbsolute)
    return path;
  
  const std::string curDir = m_impl->getCurrentDirectory();
  return m_impl->join(curDir, path);
}

std::string PlatformUtils::getBaseDir(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string::size_type pos = path.find_last_of("\\/");
  if (pos != std::string::npos)
    return path.substr(0, pos);
  return "";
}

std::string PlatformUtils::getBaseName(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string::size_type pos = path.find_last_of("\\/");
  if (pos != std::string::npos)
    return path.substr(pos + 1);
  return path;
}

std::string PlatformUtils::getFileExtension(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string baseName = this->getBaseName(path);
  const std::string::size_type pos = baseName.find_last_of(".");
  if (pos != std::string::npos)
    return baseName.substr(pos + 1);
  return "";
}

bool PlatformUtils::isPhysicalDrivePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->isPhysicalDrivePath(path);
}

std::string PlatformUtils::fixDevicePath(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->fixDevicePath(path);
}

std::string PlatformUtils::mapLogicalPathToPhysical(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->mapLogicalPathToPhysical(path);
}

bool PlatformUtils::unmountAll(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->unmountAll(path);
}

uint32_t PlatformUtils::getLastErrorCode() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getLastErrorCode();
}

std::string PlatformUtils::getErrorString(const uint32_t errorID) const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getErrorString(errorID);
}

std::string PlatformUtils::getLastErrorString() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getLastErrorString();
}

const sPlatformDesc_t& PlatformUtils::getPlatformDesc() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getPlatformDesc();
}

ThreadHandle_t PlatformUtils::getCurrentThread() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_impl->getCurrentThread();
}

bool PlatformUtils::setThreadAffinityMask(ThreadHandle_t handle, const uint32_t mask) const
{
  __DEV_CALLSTACK_FUNC__;
  // no need to check the mask here.
  // User is responsible for checking last error code (MS-Windows) or errno (Posix).
#if defined(DEV_PLATFORM_STM32)
  __ASSERT__(false && "setThreadAffinityMask is not implemented for STM32 and makes no sense for single-core CPU");
  (void)handle; // unused argument
  (void)mask; // unused argument
  return false;
#else
  return m_impl->setThreadAffinityMask(handle, mask);
#endif
}

uint32_t PlatformUtils::getCurrentProcessorNumber() const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_STM32)
  return 0; //STM32H7 has the single core
#else
  return m_impl->getCurrentProcessorNumber();
#endif
}

uint32_t PlatformUtils::getNumCores() const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_STM32)
  // STM32 H7 has single core
  return 1;
#else
  // C++11 gives portable way to retrieve count of physical CPU cores
  return static_cast<uint32_t>(std::thread::hardware_concurrency());
#endif
}
