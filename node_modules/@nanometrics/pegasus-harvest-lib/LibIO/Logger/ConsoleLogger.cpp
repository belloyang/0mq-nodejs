#include "ConsoleLogger.h"

#include <cstring>
#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <cinttypes>

ConsoleLogger::ConsoleLogger(const size_t maxBufferSize, const uint8_t mask /*= LOGS_ALL*/)
:  ILogger(mask)
,  m_buffer(std::make_shared<buffer_malloc<char>>(maxBufferSize))
{
  __DEV_CALLSTACK_FUNC__;
  m_buffer->clear();
}

ConsoleLogger::ConsoleLogger(const std::shared_ptr<buffer_base<char>>& buffer)
  : ILogger()
  , m_buffer(buffer)
{
  __DEV_CALLSTACK_FUNC__;
}

bool ConsoleLogger::_appendMessage(const size_t offset, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t maxLength = m_buffer->size() - 1; //reserve 1 symbols to insert (\n)
  char* const bufferPtr = m_buffer->ptr<char>();
  //check if buffer has enough space to append message
  if (offset < maxLength)
  {
    const int lenRemains = maxLength - offset;
    const int contentLength = ::vsnprintf(bufferPtr + offset, lenRemains + 1, format, args);
    if (contentLength > 0)
    {
      const int realLength = std::min<int>(contentLength + 1, lenRemains);
      bufferPtr[offset + realLength - 1] = '\n';
      bufferPtr[offset + realLength + 0] = '\0';
      return true;
    }
    else //cannot append the message -> finalize the buffer at this incomplete state (only the header written)
    {
      bufferPtr[offset + 0] = '\n';
      bufferPtr[offset + 1] = '\0';
      return false;
    }
  }
  
  //end up the buffer with \n\0
  bufferPtr[maxLength - 1] = '\n';
  bufferPtr[maxLength + 0] = '\0';
  return false;
}

bool ConsoleLogger::_constructMessage(const char* header, const char* scope, 
    const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t maxLength = m_buffer->size() - 1; //reserve 1 symbol to insert (\n)
  char* const bufferPtr = m_buffer->ptr<char>();
  //construct header
  const int len = ::snprintf(bufferPtr, maxLength, "%s(%s): ", header, scope);
  if (len > 0)
  {
    //append message body to header 
    //intentionally ignoring return value from _appendMessage() as incomplete buffer (only header built) is acceptable for output
    const int realLen = std::min<int>(len, maxLength);
    this->_appendMessage(realLen, format, args);
    return true;
  }
  //even header hasn't been built -> return false
  return false;
}

void ConsoleLogger::_logErrorImpl(const char* scope, const uint32_t category, const uint32_t errorCode, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::make printf thread-safe
#if !defined(DEV_PLATFORM_STM32)
  std::unique_lock<std::mutex> lock(m_mutex);
#endif
  const size_t maxLength = m_buffer->size() - 1; //reserve 1 symbol to insert new line character before null terminator
  char* const bufferPtr = m_buffer->ptr<char>();
  //build header
  const int iRet = ::snprintf(
      bufferPtr,
      maxLength,
      "<<<ERROR(category=%" PRIu32 ", code=%" PRIu32 "(0x%08" PRIX32 "), scope='%s'): ",
      category,
      errorCode,
      errorCode,
      scope
      );
  if (iRet > 0)
  {
    this->_appendMessage(iRet, format, args);
    ::printf("%s", bufferPtr);
  }
}

void ConsoleLogger::_logWarningImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::make printf thread-safe
#if !defined(DEV_PLATFORM_STM32)
  std::unique_lock<std::mutex> lock(m_mutex);
#endif
  if (this->_constructMessage("!!!WARNING", scope, format, args))
    ::printf("%s", m_buffer->ptr<char>());
}

void ConsoleLogger::_logInfoImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::make printf thread-safe
#if !defined(DEV_PLATFORM_STM32)
  std::unique_lock<std::mutex> lock(m_mutex);
#endif
  if (this->_constructMessage("INFO", scope, format, args))
    ::printf("%s", m_buffer->ptr<char>());
}

void ConsoleLogger::_logDebugImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::make printf thread-safe
#if !defined(DEV_PLATFORM_STM32)
  std::unique_lock<std::mutex> lock(m_mutex);
#endif
  if (this->_constructMessage("DEBUG", scope, format, args))
    ::printf("%s", m_buffer->ptr<char>());
}

void ConsoleLogger::_flushImpl()
{
  __DEV_CALLSTACK_FUNC__;
  ::fflush(stdout);
}
