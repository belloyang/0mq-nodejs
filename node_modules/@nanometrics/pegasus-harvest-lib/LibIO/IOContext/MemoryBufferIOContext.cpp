#include "MemoryBufferIOContext.h"

#include <string.h>
#include <algorithm>

MemoryBufferIOContext::MemoryBufferIOContext(const void* pBuffer, uint64_t bufferSize, const std::shared_ptr<ILogger>& logger)
:  IIOContext(logger)
,  m_pBuffer(pBuffer)
,  m_totalSize(bufferSize)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_pBuffer == nullptr)
  {
    m_logger->warning(__THIS_FUNC__, "Init with NULL data. Will be treated as empty buffer");
    m_totalSize = 0;
  }
}

void MemoryBufferIOContext::init(const void* pBuffer, uint64_t bufferSize)
{
  __DEV_CALLSTACK_FUNC__;
  m_pBuffer   = pBuffer;
  m_totalSize = bufferSize;
  if (m_pBuffer == nullptr)
  {
    m_logger->warning(__THIS_FUNC__, "Init with NULL data. Will be treated as empty buffer");
    m_totalSize = 0;
  }
}

size_t MemoryBufferIOContext::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::trunk block size if we exceed file size limits
  const size_t blockSizeToRead = (size_t)std::min<uint64_t>(blockSize, m_totalSize - offset);
  ::memcpy(pOutput, (char*)m_pBuffer + offset, blockSizeToRead);
  return blockSizeToRead;
}

size_t MemoryBufferIOContext::writeBlock(io_offset_t offset, size_t blockSize, const void* pData)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t blockSizeToWrite = (size_t)std::min<uint64_t>(blockSize, m_totalSize - offset);
  ::memcpy((char*)m_pBuffer + offset,  pData, blockSizeToWrite);
  return blockSizeToWrite;
}

void MemoryBufferIOContext::flush()
{
  __DEV_CALLSTACK_FUNC__;
  //do nothing here
}

uint64_t MemoryBufferIOContext::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_totalSize;
}
