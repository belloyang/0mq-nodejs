#ifndef MemoryBufferIOContext_h__
#define MemoryBufferIOContext_h__

#include "IIOContext.h"

/// <summary>
/// Memory Buffer I/O context.
/// This is a memory buffer adaptor that behaves like an I/O context.\n
/// I/O operations use <B>memcpy</B> underneath to copy data to/from underlying buffer captured by this context.
/// </summary>
class MemoryBufferIOContext : public IIOContext
{
public:
  /**
   * Memory buffered I/O context constructor
   * @param pBuffer     pointer to memory buffer to be captured by context
   * @param bufferSize  buffer size (in bytes)
   * @param logger      logger instance
   */
  MemoryBufferIOContext(const void* pBuffer, uint64_t bufferSize, const std::shared_ptr<ILogger>& logger);

  /**
   * Memory buffered I/O context destructor
   */
  virtual ~MemoryBufferIOContext() = default;

  /**
   * (re)initialize an existing memory buffered I/O context. This provides a small optimization
   * for applications that want to avoid re-creating the object with each use.
   * @param pBuffer     pointer to memory buffer to be captured by context
   * @param bufferSize  buffer size (in bytes)
   */
  void init(const void* pBuffer, uint64_t bufferSize);

  virtual size_t readBlock(io_offset_t offset, size_t blockSize, void* pOutput) __OVERRIDES__(IIOContext);
  virtual size_t writeBlock(io_offset_t offset, size_t blockSize, const void* pData) __OVERRIDES__(IIOContext);
  virtual void flush() __OVERRIDES__(IIOContext);
  virtual uint64_t getSize() const __OVERRIDES__(IIOContext);

  DECLARE_NOCOPYABLE(MemoryBufferIOContext);

private:
  const void*  m_pBuffer; // resource is NOT owned (nor managed) by this class
  uint64_t m_totalSize;
};

#endif //MemoryBufferIOContext_h__
