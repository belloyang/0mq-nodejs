#include "FileIOContext_POSIX.h"

#include "../../PlatformUtils/PlatformUtils.h"

#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#if defined(DEV_PLATFORM_LINUX)
  #include <linux/fs.h>
#elif defined(DEV_PLATFORM_MACOS)
  #include <sys/disk.h>
#endif
#include <errno.h>
#include <string.h>
#include <cinttypes>

FileIOContext_POSIX::FileIOContext_POSIX(const std::string& path, const int flags,
    const std::shared_ptr<ILogger>& logger)
:  IIOContext(logger)
,  m_path(path)
,  m_handle(0)
,  m_bIsDiskDevice(false)
,  m_totalSize(0)
{
  __DEV_CALLSTACK_FUNC__;
  const mode_t mode = (S_IRWXU | S_IRWXG | S_IRWXO);
  m_handle = ::open(m_path.c_str(), flags, mode);
  if (m_handle > 0)
  {
    //tss_libio::get block device size
    m_bIsDiskDevice = (::strncmp(m_path.c_str(), "/dev/", 5) == 0);
    if (m_bIsDiskDevice)
    {
#if defined(DEV_PLATFORM_LINUX)
      ::ioctl(m_handle, BLKGETSIZE64, &m_totalSize);
#elif defined(DEV_PLATFORM_MACOS)
      uint64_t nSectors = 0;
      uint32_t sectorSize = 0;
      ::ioctl(m_handle, DKIOCGETBLOCKCOUNT, &nSectors);
      ::ioctl(m_handle, DKIOCGETBLOCKSIZE, &sectorSize);
      m_totalSize = nSectors * sectorSize;
#endif
    }
    else
    {
      m_totalSize = ::lseek(m_handle, 0, SEEK_END);
      ::lseek(m_handle, 0, SEEK_SET);
    }
    m_logger->info(__THIS_FUNC__, "file %s opened (handle=%i, size=%" PRIu64 " bytes, flags=%i)",
        path.c_str(),
        m_handle,
        m_totalSize,
        flags);
  }
  else
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "failed to open %s (%s)",
        path.c_str(),
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
}

FileIOContext_POSIX:: ~FileIOContext_POSIX()
{
  __DEV_CALLSTACK_FUNC__;
  // close file handle
  if (m_handle > 0)
    ::close(m_handle);
}

size_t FileIOContext_POSIX::_checkBlock(io_offset_t offset, size_t blockSize, const void* pData) const
{
  __DEV_CALLSTACK_FUNC__;
  if (pData == nullptr)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_DATA,
        "Data is NULL. I/O cannot be performed");
    return 0;
  }

  if (offset >= m_totalSize)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_RANGE,
        "Out of range[0, %" PRIu64 "] access detected (offset=%" PRId64 ")",
      m_totalSize - 1LLU,
      offset);
    return 0;
  }
  if (offset + blockSize > m_totalSize)
  {
    const size_t availableBlockSize = (size_t)std::min<uint64_t>(blockSize, m_totalSize - offset);
    m_logger->warning(__THIS_FUNC__, "Partial out of range [0, %" PRIu64 "] access detected [%" PRId64 ", %" PRId64 "]. Block size reduced to %lu",
      m_totalSize - 1LLU,
      offset, offset + blockSize - 1LLU,
      (unsigned long)blockSize, (unsigned long)availableBlockSize);
    return availableBlockSize;
  }

  return blockSize;
}

size_t FileIOContext_POSIX::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle <= 0)
    return 0;

  // trunk block size if we exceed file size limits
  const size_t blockSizeToRead = this->_checkBlock(offset, blockSize, pOutput);
  if (blockSizeToRead <= 0)
    return 0;

  ::lseek(m_handle, offset, SEEK_SET);
  const ssize_t bytesRead = ::read(m_handle, pOutput, blockSizeToRead);
  if (bytesRead <= 0)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "failed to read block (offset=%" PRId64 ", size=%lu) from context (size=%" PRIu64 "): %s",
        offset,
        (unsigned long)blockSizeToRead,
        m_totalSize,
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }
#if defined(DEV_PLATFORM_LINUX)
  {
    /* POSIX_FADV_WILLNEED - initiates a nonblocking read of the specified region into the page cache.
     * The amount of data read may be decreased by the kernel depending on virtual memory load.
     * (A few megabytes will usually be fully satisfied, and more is rarely useful.)
     * POSIX_FADV_SEQUENTIAL - the application expects to access the specified data sequentially (with lower offsets read before higher ones).
     */
    const int res = ::posix_fadvise64(m_handle, offset + blockSize, blockSize,
        POSIX_FADV_WILLNEED | POSIX_FADV_SEQUENTIAL);
    if (res != 0)
      m_logger->warning(__THIS_FUNC__, "Failed to call 'posix_fadvise64' - %i", res);
  }
#endif
  return (size_t)bytesRead;
}

size_t FileIOContext_POSIX::writeBlock(io_offset_t offset, size_t blockSize, const void* pData)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle <= 0)
    return 0;

  // If context is expandable -> try to write the entire block; otherwise -> limit to allowable
  const size_t blockSizeToWrite = blockSize;
  if (blockSizeToWrite <= 0)
    return 0;

  ::lseek(m_handle, offset, SEEK_SET);
  const ssize_t bytesWritten = ::write(m_handle, pData, blockSizeToWrite);
  if (bytesWritten <= 0)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "failed to write block (%p, offset=%" PRId64 ", size=%lu) to context (size=%" PRIu64 "): %s",
        pData,
        offset,
        (unsigned long)blockSizeToWrite,
        m_totalSize,
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  //tss_libio::update it's total size
  const io_offset_t fileEndP = offset + bytesWritten;
  m_totalSize = std::max(m_totalSize, (uint64_t)fileEndP);

  return (size_t)bytesWritten;
}

void FileIOContext_POSIX::flush()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle != 0)
    ::fsync(m_handle);
}

uint64_t FileIOContext_POSIX::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_totalSize;
}
