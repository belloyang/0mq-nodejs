#ifndef BufferedIOContext_h__
#define BufferedIOContext_h__

#include "IIOContext.h"

#include "../buffers.h"

#include <memory>

/// <summary>
/// Buffered I/O context.
/// It uses fixed size read/write buffers to minimize access to underlying context (reduce readBlock/writeBLock invocations for it).\n
/// NOTE: If requested block size for read/write operation spans over corresponding cache size - reading/writing is done directly to underlying context.\n
/// NOTE: If writing operation is not sequential (new block to write doesn't commence right after the previous block written) -
///  it provokes write buffer flushing and rebuilds the writing cache.\n
/// </summary>
class BufferedIOContext : public IIOContext
{
public:
  /**
   * Buffered I/O context constructor
   * @param baseContext    base/underlying context that buffered I/O operations are being performed over
   * @param readCacheSize  cache size (in bytes) for read operations
   * @param writeCacheSize cache size (in bytes) for write operations
   * @param logger         logger instance
   */
  BufferedIOContext(const std::shared_ptr<IIOContext>& baseContext, 
      const size_t readCacheSize, const size_t writeCacheSize,
      const std::shared_ptr<ILogger>& logger);

  /**
 * Buffered I/O context constructor
 * @param baseContext base/underlying context that buffered I/O operations are being performed over
 * @param readBuffer  buffer to be used for caching read operations
 * @param writeBuffer buffer to be used for caching write operations
 * @param logger      logger instance
 */
  BufferedIOContext(const std::shared_ptr<IIOContext>& baseContext,
    const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer,
    const std::shared_ptr<ILogger>& logger);

  /**
   * Buffered I/O context destructor
   */
  virtual ~BufferedIOContext();

  virtual size_t readBlock(io_offset_t offset, size_t blockSize, void* pOutput) __OVERRIDES__(IIOContext);
  virtual size_t writeBlock(io_offset_t offset, size_t blockSize, const void* pData) __OVERRIDES__(IIOContext);
  virtual void flush() __OVERRIDES__(IIOContext);
  virtual uint64_t getSize() const __OVERRIDES__(IIOContext);
  
private:
  size_t _flushWriteBuffer();

private:
  //! underlying context
  const std::shared_ptr<IIOContext> m_baseContext;
  //! cache state structure
  struct
  {
    //! buffer
    std::shared_ptr<buffer_base<char>> buffer;
    //! Current offset for cached data
    io_offset_t offset = 0;
    //! Current cached data size
    size_t size = 0;
  } m_readCacheState, m_writeCacheState;
  uint64_t m_totalSize;
};

#endif //BufferedIOContext_h__
