#ifndef SequentialIOContext_h__
#define SequentialIOContext_h__

#include "IIOContext.h"

#include <vector>

/// <summary>
/// Sequential I/O context.
/// It's adaptor that allows to treat multiple contexts as the dense single one, so when first context end is reached
/// - I/O is performed over the next captured context.
/// </summary>
class SequentialIOContext : public IIOContext
{
public:
  /**
   * Sequential I/O context constructor
   * @param contexts    array of underlying context to be captured by this object
   * @param logger    logger instance
   */
  SequentialIOContext(const std::vector< std::shared_ptr<IIOContext> >& contexts,
      const std::shared_ptr<ILogger>& logger);

  /**
   * Sequential I/O context destructor
   */
  virtual ~SequentialIOContext();

  virtual size_t readBlock(io_offset_t offset, size_t blockSize, void* pOutput) __OVERRIDES__(IIOContext);
  virtual size_t writeBlock(io_offset_t offset, size_t blockSize, const void* pData) __OVERRIDES__(IIOContext);
  virtual void flush() __OVERRIDES__(IIOContext);
  virtual uint64_t getSize() const __OVERRIDES__(IIOContext);

private:
  const std::vector< std::shared_ptr<IIOContext> > m_contexts;
  uint64_t m_totalSize;
};

#endif //SequentialIOContext_h__
