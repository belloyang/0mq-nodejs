#include "SequentialIOContext.h"

#include <algorithm>

SequentialIOContext::SequentialIOContext(const std::vector<std::shared_ptr<IIOContext>>& contexts,
    const std::shared_ptr<ILogger>& logger)
:  IIOContext(logger)
,  m_contexts(contexts)
,  m_totalSize(0)
{
  __DEV_CALLSTACK_FUNC__;
  for (size_t i = 0; i < m_contexts.size(); i++)
  {
    m_totalSize += m_contexts[i]->getSize();
  }
}

SequentialIOContext:: ~SequentialIOContext()
{
  __DEV_CALLSTACK_FUNC__;
}

size_t SequentialIOContext::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  size_t bytesToRead = blockSize;
  io_offset_t contextOffset = 0;
  io_offset_t blockOffset = offset;
  char* pOutputPtr = reinterpret_cast<char*>(pOutput);
  for (size_t i = 0; i < m_contexts.size(); i++)
  {
    std::shared_ptr<IIOContext> context = m_contexts.at(i);
    const uint64_t contextSize = context->getSize();
    //tss_libio::check if blockOffset points to context's range
    if (blockOffset <= contextOffset + contextSize)
    {
      const io_offset_t blockOffsetInContext = blockOffset - contextOffset;
      const size_t availableBlockSize = (size_t)std::min<uint64_t>(bytesToRead, contextSize - blockOffsetInContext);
      const size_t bytesRead = context->readBlock(blockOffsetInContext, availableBlockSize, pOutputPtr);
      pOutputPtr += bytesRead;
      bytesToRead -= bytesRead;
      blockOffset += bytesRead;
    }

    //tss_libio::move to the next context
    contextOffset += contextSize;
    if (bytesToRead == 0)
      break;
  }

  return (blockSize - bytesToRead);
}

size_t SequentialIOContext::writeBlock(io_offset_t offset, size_t blockSize, const void* pData)
{
  __DEV_CALLSTACK_FUNC__;
  size_t bytesToWrite = blockSize;
  io_offset_t contextOffset = 0;
  io_offset_t blockOffset = offset;
  const char* pDataPtr = reinterpret_cast<const char*>(pData);
  for (size_t i = 0; i < m_contexts.size(); i++)
  {
    std::shared_ptr<IIOContext> context = m_contexts.at(i);
    const uint64_t contextSize = context->getSize();
    //tss_libio::check if blockOffset points to context's range
    if (blockOffset <= contextOffset + contextSize)
    {
      const io_offset_t blockOffsetInContext = blockOffset - contextOffset;
      const size_t availableBlockSize = (size_t)std::min<uint64_t>(bytesToWrite, contextSize - blockOffsetInContext);
      const size_t bytesWritten = context->writeBlock(blockOffsetInContext,availableBlockSize, pDataPtr);

      pDataPtr += bytesWritten;
      bytesToWrite -= bytesWritten;
      blockOffset += bytesWritten;
    }
    //tss_libio::move to the next context
    contextOffset += contextSize;
    if (bytesToWrite == 0)
      break;
  }

  return (blockSize - bytesToWrite);
}

void SequentialIOContext::flush()
{
  __DEV_CALLSTACK_FUNC__;
  for (auto contextIt = m_contexts.begin(); contextIt != m_contexts.end(); ++contextIt)
    (*contextIt)->flush();
}

uint64_t SequentialIOContext::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::actual size is the size of data underlying
  return m_totalSize;
}
