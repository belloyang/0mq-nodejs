#include "BufferedIOContext.h"

#include <string.h>
#include <algorithm>

BufferedIOContext::BufferedIOContext(const std::shared_ptr<IIOContext>& baseContext, 
    const size_t readCacheSize, const size_t writeCacheSize,
    const std::shared_ptr<ILogger>& logger)
:  IIOContext(logger)
,  m_baseContext(baseContext)
,  m_totalSize(baseContext->getSize())
{
  __DEV_CALLSTACK_FUNC__;
  m_readCacheState.buffer = std::make_shared<buffer_io_aligned_alloc<char>>(readCacheSize);
  m_writeCacheState.buffer = std::make_shared<buffer_io_aligned_alloc<char>>(writeCacheSize);
}

BufferedIOContext::BufferedIOContext(const std::shared_ptr<IIOContext>& baseContext,
  const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer, 
  const std::shared_ptr<ILogger>& logger)
  : IIOContext(logger)
  , m_baseContext(baseContext)
  , m_totalSize(baseContext->getSize())
{
  m_readCacheState.buffer = readBuffer;
  m_writeCacheState.buffer = writeBuffer;
}

BufferedIOContext::~BufferedIOContext()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::flush write buffer
  this->_flushWriteBuffer();
}

size_t BufferedIOContext::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::check if write cache buffer is affected
  //block lower offset <= cache upper offset && block upper offset >= cache lower offset -> covers all overlapping cases
  if (m_writeCacheState.size > 0 &&
     (offset < m_writeCacheState.offset + m_writeCacheState.size) && 
     (offset + blockSize - 1) >= m_writeCacheState.offset)
  {
    //tss_libio::flush write cache before reading. Reading cache either is:
    // 1) discarded by "writeBlock" operation that overlapped reading cache, or
    // 2) doesn't overlap with write cache at at all.
    //so no worries about reading cache to be invalid after this
    this->_flushWriteBuffer();
  }
 
  uint8_t* pOutput_local = reinterpret_cast<uint8_t*>(pOutput);
  //tss_libio::if cache is not big enough to store remaining data -> no need to cache it -> just read directly from underlying context
  if (blockSize >= m_readCacheState.buffer->size())
  {
    return m_baseContext->readBlock(offset, blockSize, pOutput_local);
  }

  size_t dataToRead = blockSize;
  size_t dataRead = 0;
  //tss_libio::check if some data is cached and copy it from cache
  if (offset >= m_readCacheState.offset && offset < m_readCacheState.offset + m_readCacheState.size)
  {
    const io_offset_t inCacheOffset = offset - m_readCacheState.offset;
    const size_t bytesToReadFromCache = std::min<size_t>(m_readCacheState.size - inCacheOffset, dataToRead);
    ::memcpy(pOutput_local, m_readCacheState.buffer->ptr<char>() + inCacheOffset, bytesToReadFromCache);
    dataToRead -= bytesToReadFromCache;
    dataRead += bytesToReadFromCache;
    pOutput_local += bytesToReadFromCache;
  }

  //tss_libio::cache the next data (that spans out of current hash) if not all data read
  if (dataToRead > 0)
  {
    //tss_libio::read data to cache
    m_readCacheState.offset = offset + dataRead;
    m_readCacheState.size = m_baseContext->readBlock(m_readCacheState.offset, m_readCacheState.buffer->size(), m_readCacheState.buffer->ptr());
    if (m_readCacheState.size > 0)
    {
      ::memcpy(pOutput_local, m_readCacheState.buffer->ptr<char>(), dataToRead);
      dataRead += dataToRead;
    }
  }

  return dataRead;
}

size_t BufferedIOContext::writeBlock(io_offset_t offset, size_t blockSize, const void* pData)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::check if read cache buffer is affected
  //block lower offset <= cache upper offset && block upper offset >= cache lower offset -> covers all overlapping cases
  if (m_readCacheState.size > 0 &&
      offset < (m_readCacheState.offset + m_readCacheState.size) && 
     (offset + blockSize - 1) >= m_readCacheState.offset)
  {
    //tss_libio::discard read cache
    m_readCacheState.offset = 0;
    m_readCacheState.size = 0;
  }
  
  const uint8_t* pData_local = reinterpret_cast<const uint8_t*>(pData);
  //tss_libio::if block to write is not smaller then cache size -> flush cache and write the block right away
  if (blockSize >= m_writeCacheState.buffer->size())
  {
    this->_flushWriteBuffer();
    return m_baseContext->writeBlock(offset, blockSize, pData_local);
  }

  //tss_libio::if write cache is empty -> init it for the current block
  if (m_writeCacheState.size == 0)
    m_writeCacheState.offset = offset;
  
  size_t dataToWrite = blockSize;
  size_t dataWritten = 0;
  //tss_libio::check if data can be cached (data is contiguous so can be appended to cache with no gaps)
  //if any gaps occurs, we don't want that data that remains in the gaps to affect underlying context
  if (offset == m_writeCacheState.offset + m_writeCacheState.size)
  {
    const io_offset_t inCacheOffset = (offset - m_writeCacheState.offset);
    const size_t bytesToWriteToCache = std::min<size_t>(m_writeCacheState.buffer->size() - inCacheOffset, blockSize);
    ::memcpy(m_writeCacheState.buffer->ptr<char>() + inCacheOffset, pData_local, bytesToWriteToCache);
    m_writeCacheState.size += bytesToWriteToCache;
    dataToWrite -= bytesToWriteToCache;
    dataWritten += bytesToWriteToCache;
    pData_local += bytesToWriteToCache;
  }
  //tss_libio::check if the block is located completely within cache -> just update the cache
  else if (offset >= m_writeCacheState.offset && 
           offset + blockSize <= m_writeCacheState.offset + m_writeCacheState.size)
  {
    const io_offset_t inCacheOffset = (offset - m_writeCacheState.offset);
    ::memcpy(m_writeCacheState.buffer->ptr<char>() + inCacheOffset, pData_local, dataToWrite);
    dataWritten += dataToWrite;
    pData_local += dataToWrite;
    dataToWrite = 0; // avoid CppCheck warning, used to be 'dataToWrite -= dataToWrite;'
  }
  
  //tss_libio::check if still some data remains (at this stage either cache buffer is filled or gap occurs in consecutive writeBlock calls)
  if (dataToWrite > 0)
  {
    //tss_libio::flush write buffer
    this->_flushWriteBuffer();
    //tss_libio::rebuild cache
    m_writeCacheState.offset = offset + dataWritten;
    ::memcpy(m_writeCacheState.buffer->ptr<char>(), pData_local, dataToWrite);
    m_writeCacheState.size = dataToWrite;
    dataWritten += dataToWrite;
  }
  
  return dataWritten;
}

size_t BufferedIOContext::_flushWriteBuffer()
{
  __DEV_CALLSTACK_FUNC__;
  size_t ret = 0L;
  //tss_libio::if write buffer is not empty -> flush it
  if (m_writeCacheState.size > 0)
  {
    ret = m_baseContext->writeBlock(m_writeCacheState.offset, m_writeCacheState.size, m_writeCacheState.buffer->ptr());
    //tss_libio::discard write buffer
    m_writeCacheState.offset = 0LL;
    m_writeCacheState.size = 0L;
  }
  return ret;
}

void BufferedIOContext::flush()
{
  __DEV_CALLSTACK_FUNC__;
  this->_flushWriteBuffer();
  m_baseContext->flush();
}

uint64_t BufferedIOContext::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_totalSize;
}
