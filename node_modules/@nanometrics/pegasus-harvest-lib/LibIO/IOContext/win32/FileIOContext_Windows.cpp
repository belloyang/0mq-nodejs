#include "FileIOContext_Windows.h"

#include "../../PlatformUtils/PlatformUtils.h"

#include <algorithm> // std::min
#include <cinttypes> // PRIu64
#include <cstring> // memcpy

FileIOContext_Windows::FileIOContext_Windows(const std::string& path,
    const DWORD dwDesiredAccess, const DWORD dwShareMode, const DWORD dwCreationDisposition,
    const std::shared_ptr<ILogger>& logger)
:  IIOContext(logger)
,  m_path(path)
,  m_handle(INVALID_HANDLE_VALUE)
,  m_totalSize(0) // 0 bytes in case of newly created file
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::open file handle
  m_handle = ::CreateFileA(m_path.c_str(),
      dwDesiredAccess,
      dwShareMode,
      NULL,
      dwCreationDisposition,
      FILE_ATTRIBUTE_NORMAL,
      0);
  if (m_handle != INVALID_HANDLE_VALUE)
  {
    //tss_libio::retrieve size, but only if it could possibly be non-zero
    if (dwCreationDisposition == OPEN_ALWAYS || dwCreationDisposition == OPEN_EXISTING)
    {
      m_totalSize = this->_getSize(m_handle);
    }
    m_logger->info(__THIS_FUNC__, "file %s opened (handle=%p, size=%" PRIu64 " bytes)", m_path.c_str(), m_handle, m_totalSize);
  }
  else
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__,eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to open '%s': %s",
      path.c_str(), PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }

#ifdef MEASURE_DISK_READ_TIME
  QueryPerformanceFrequency(&m_frequency);
  m_elapsed.QuadPart = 0;
#endif
}

FileIOContext_Windows::~FileIOContext_Windows()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle != INVALID_HANDLE_VALUE) {
    //tss_libio::close handle
    ::CloseHandle(m_handle);
  }
#ifdef MEASURE_DISK_READ_TIME
  m_logger->debug(__THIS_FUNC__, "m_elapsed=%.0fms", (double)(m_elapsed.QuadPart) / (double)(m_frequency.QuadPart) * 1e3);
#endif
}

uint64_t FileIOContext_Windows::_getSize(HANDLE handle) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::try to retrieve file size as the regular file
  LARGE_INTEGER fileSize;
  if (::GetFileSizeEx(handle, &fileSize) != FALSE)
  {
    return (uint64_t)fileSize.QuadPart;
  }
  else
  {
    //tss_libio::try to retrieve file size as I/O device info
    GET_LENGTH_INFORMATION lenInfo; ::memset(&lenInfo, 0, sizeof(lenInfo));
    DWORD bytesReturned = 0;
    if (::DeviceIoControl(handle, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lenInfo, sizeof(lenInfo),
      &bytesReturned, NULL))
    {
      return (uint64_t)lenInfo.Length.QuadPart;
    }

    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to get file (%s, handle=%p) size: %s",
      m_path.c_str(), handle, 
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return 0;
}

bool FileIOContext_Windows::lock()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bLocked = ::DeviceIoControl(m_handle, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bLocked == TRUE) {
    m_logger->info(__THIS_FUNC__, "'%s' is locked!!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to lock '%s': %s",
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bLocked;
}

bool FileIOContext_Windows::unlock()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bUnLocked = ::DeviceIoControl(m_handle, FSCTL_UNLOCK_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bUnLocked) {
    m_logger->info(__THIS_FUNC__, "'%s' unlocked!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to unlock '%s': %s",
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bUnLocked;
}

bool FileIOContext_Windows::dismount()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bDisMounted = ::DeviceIoControl(m_handle, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bDisMounted) {
    m_logger->info(__THIS_FUNC__, "'%s' dismounted!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to dismount '%s': %s",
      m_path.c_str(), 
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bDisMounted;
}

size_t FileIOContext_Windows::_checkBlock(io_offset_t offset, size_t blockSize, const void* pData) const
{
  __DEV_CALLSTACK_FUNC__;
  if (pData == nullptr)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_DATA,
        "Data is NULL. I/O cannot be performed");
    return 0;
  }

  if (offset >= m_totalSize)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_RANGE,
      "Out of range [0, %" PRIu64 "] access detected (offset=%" PRIu64 ")",
      m_totalSize - 1LLU,
      offset);
    return 0;
  }
  if (offset + blockSize > m_totalSize)
  {
    const size_t availableBlockSize = (size_t)std::min<uint64_t>(blockSize, m_totalSize - offset);
    m_logger->warning(__THIS_FUNC__, "Partial out of range [0, %" PRIu64 "] access detected [%" PRIu64 ", %" PRIu64 "]. Block size (%lu) reduced to %lu",
      m_totalSize - 1LLU,
      offset, offset + blockSize - 1LLU,
      (unsigned long)blockSize, (unsigned long)availableBlockSize);
    return availableBlockSize;
  }

  return blockSize;
}

size_t FileIOContext_Windows::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle == INVALID_HANDLE_VALUE)
    return 0;

  const size_t blockSizeToRead = this->_checkBlock(offset, blockSize, pOutput);
  if (blockSizeToRead <= 0)
    return 0;

  //tss_libio::move file pointer to offset
  LONG distToMoveHigh = (LONG)(offset >> 32);
  if (::SetFilePointer(m_handle, (LONG)offset, &distToMoveHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Cannot seek to %" PRIu64 " position at file '%s': %s",
      offset,
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  //tss_libio::perform read operation
  DWORD bytesRead = 0;

#ifdef MEASURE_DISK_READ_TIME
  LARGE_INTEGER start, finish;
  QueryPerformanceCounter(&start);
  const BOOL bSuccess = ::ReadFile(m_handle, (LPVOID)pOutput, (DWORD)blockSizeToRead, &bytesRead, NULL);
  QueryPerformanceCounter(&finish);
  m_elapsed.QuadPart += (finish.QuadPart - start.QuadPart);
#else
  const BOOL bSuccess = ::ReadFile(m_handle, (LPVOID)pOutput, (DWORD)blockSizeToRead, &bytesRead, NULL);
#endif

  if (bSuccess == FALSE)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to read data from file '%s': %s",
      m_path.c_str(), 
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  if (bytesRead != blockSizeToRead)
  {
    m_logger->warning(__THIS_FUNC__, "Data was read partially (%lu of %lu)",
        (unsigned long)bytesRead,
        (unsigned long)blockSizeToRead);
  }

  return bytesRead;
}

size_t FileIOContext_Windows::writeBlock(io_offset_t offset, size_t blockSize, const void* pData)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle == INVALID_HANDLE_VALUE)
    return 0;

  const size_t blockSizeToWrite = blockSize;
  if (blockSizeToWrite <= 0)
    return 0;

  //tss_libio::move file pointer to offset
  LONG distToMoveHigh = (LONG)(offset >> 32);
  if (::SetFilePointer(m_handle, (LONG)offset, &distToMoveHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Cannot seek to %" PRIu64 " position at file '%s': %s",
      offset, m_path.c_str(), PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  //tss_libio::perform write operation
  DWORD bytesWritten = 0;
  const BOOL bSuccess = ::WriteFile(m_handle, (LPCVOID*)pData, (DWORD)blockSizeToWrite, &bytesWritten, NULL);
  if (bSuccess == FALSE)
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to write data to file (%s)",
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  if (bytesWritten != blockSizeToWrite)
  {
    m_logger->warning(__THIS_FUNC__, "Data was written partially (%lu of %lu)",
        (unsigned long)bytesWritten,
        (unsigned long)blockSizeToWrite);
  }

  //tss_libio::check and update total size
  const io_offset_t fileEndP = offset + bytesWritten;
  m_totalSize = std::max<uint64_t>(m_totalSize, fileEndP);

  return bytesWritten;
}

void FileIOContext_Windows::flush()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle != nullptr)
    ::FlushFileBuffers(m_handle);
}

uint64_t FileIOContext_Windows::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_totalSize;
}
