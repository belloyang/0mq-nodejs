#include "FileIOContext_WindowsAsync.h"

#include "../../PlatformUtils/PlatformUtils.h"

#include <algorithm> // std::min, std::sort
#include <cinttypes> // PRIu64
#include <cstring>   // memcpy
#include <cstdio>    // fopen etc

// enable the following to measure instantaneous read speed
//#define MEASURE_READ_SPEED

//------------------------------------------------------------------------------
// AsyncReadState encapsulates parameters for asynchronous read I/O, and this
// struct is used in pimpl fashion.

struct AsyncReadState
{
  AsyncReadState(const std::shared_ptr<ILogger>& logger);
  ~AsyncReadState();

  // reset in readiness for new asynchronous read operation
  void* reset(io_offset_t offset, size_t sz);

  bool        background; // flag: asynchronous read operation in progress
  OVERLAPPED  overlapped; // overlapped struct for asynchronous read operation
  io_offset_t readOffset; // offset to commence read from
  size_t      readSz;     // size to read
  void*       buf;   // buffer to read data into
  size_t      bufSz; // allocated buffer size
  HANDLE      event; // handle to event to be notified of file i/o completion

private:
  // reallocate internal buffer
  void* _reallocate(size_t sz);

  std::shared_ptr<ILogger> m_logger;

  // not implemented
  AsyncReadState(const AsyncReadState&) = delete;
  AsyncReadState& operator=(const AsyncReadState&) = delete;
};

AsyncReadState::AsyncReadState(const std::shared_ptr<ILogger>& logger)
: background(false)
, overlapped()
, readOffset(0)
, readSz(0)
, buf(nullptr)
, bufSz(0)
, event(INVALID_HANDLE_VALUE)
, m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
  event = ::CreateEvent(NULL, TRUE, FALSE, NULL);
  if (event == NULL) {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to create event: %s",
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  // erase overlapped structure
  ::memset(&overlapped, 0, sizeof(overlapped));
}

AsyncReadState::~AsyncReadState()
{
  __DEV_CALLSTACK_FUNC__;
  if (event != INVALID_HANDLE_VALUE)
    ::CloseHandle(event);
  __aligned_free__(buf);
}

void* AsyncReadState::reset(io_offset_t offset, size_t sz)
{
  __DEV_CALLSTACK_FUNC__;
  // get valid buffer
  void* retBuf = this->_reallocate(sz);
  if (retBuf != nullptr) {
    // prepare overlapped structure
    ::memset(&overlapped, 0, sizeof(overlapped));
    overlapped.Offset = (DWORD)offset;
    overlapped.OffsetHigh = (DWORD)(offset >> 32);
    overlapped.hEvent = event;
    // remember offset & size for read operation
    readOffset = offset;
    readSz = sz;
  }
  // return valid buffer
  return retBuf;
}

void* AsyncReadState::_reallocate(size_t sz)
{
  __DEV_CALLSTACK_FUNC__;
  if (background || sz == 0)
    return 0;
  
  if (bufSz < sz)
  {
    __aligned_free__(buf);
    buf = __io_aligned_alloc__(sz);
    bufSz = sz;
  }
  return buf;
}

//------------------------------------------------------------------------------
// Read speed metric structure
//
// NOTE: Assumes block size unchanged between reads.
struct ReadSpeed
{
  ReadSpeed(io_offset_t _offset, double _speed)
    : offset(_offset)
    , speed(_speed)
  {
  }

  // comparison operator for use with std::sort
  bool operator<(const ReadSpeed& rhs) const { return offset < rhs.offset; }

  io_offset_t offset; // offset for read operation, bytes
  double      speed;  // instantaneous read speed, bytes/second; equivalent to read size / read duration
};

//------------------------------------------------------------------------------

FileIOContext_WindowsAsync::FileIOContext_WindowsAsync(const std::string& path,
  const DWORD dwDesiredAccess, const DWORD dwShareMode, const DWORD dwCreationDisposition,
  const std::shared_ptr<ILogger>& logger)
  : IIOContext(logger)
  , m_path(path)
  , m_handle(INVALID_HANDLE_VALUE)
  , m_totalSize(0)
  , m_readState(new AsyncReadState(logger))
  , m_readSpeed()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::open file handle
  m_handle = ::CreateFileA(m_path.c_str(),
    dwDesiredAccess,
    dwShareMode,
    NULL,
    dwCreationDisposition,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, // FILE_FLAG_OVERLAPPED is needed for asynchronous I/O 
    0);
  if (m_handle != INVALID_HANDLE_VALUE)
  {
    //tss_libio::retrieve size
    m_totalSize = this->_getSize(m_handle);
    m_logger->info(__THIS_FUNC__, "file %s opened (handle=%p, size=%" PRIu64 " bytes)",
      m_path.c_str(),
      m_handle,
      m_totalSize);
  }
  else
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to open %s: %s",
      path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }

#ifdef MEASURE_READ_SPEED
  // initialise time keeping
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency(&frequency);
  m_timerFrequency = (double)(frequency.QuadPart);
#endif
}

FileIOContext_WindowsAsync::~FileIOContext_WindowsAsync()
{
  __DEV_CALLSTACK_FUNC__;
  // wait for lingering background (asynchronous) I/O to complete
  if (m_readState->background) {
    m_logger->debug(__THIS_FUNC__, "wait for background I/O to complete");
    DWORD bytesRead = 0;
    BOOL bSuccess = ::GetOverlappedResult(m_handle, &m_readState->overlapped, &bytesRead, TRUE);
    if (bSuccess == FALSE) {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "call to GetOverlappedResult() failed: %s",
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    }
  }
  // cleanup
  if (m_handle != INVALID_HANDLE_VALUE) {
    //tss_libio::close handle
    ::CloseHandle(m_handle);
  }
  delete m_readState;

#ifdef MEASURE_READ_SPEED
  if (!m_readSpeed.empty()) {
    // sort read speed metrics according to increasing offset
    std::sort(m_readSpeed.begin(), m_readSpeed.end());
    // average the read speeds for reads from the same offset
    std::vector<ReadSpeed> readSpeed;
    io_offset_t prevOffset = m_readSpeed[0].offset;
    double speedTally = m_readSpeed[0].speed;
    size_t n = 1;
    for (size_t i = 1; i < m_readSpeed.size(); ++i) {
      if (m_readSpeed[i].offset == prevOffset) {
        speedTally += m_readSpeed[i].speed;
        ++n;
      }
      else {
        readSpeed.emplace_back(prevOffset, speedTally/n);
        prevOffset = m_readSpeed[i].offset;
        speedTally = m_readSpeed[i].speed;
        n = 1;
      }
    }
    if (m_readSpeed[m_readSpeed.size() - 1].offset != prevOffset) {
      readSpeed.push_back(m_readSpeed[m_readSpeed.size() - 1]);
    }
    // dump read speed metrics to file
    char name[64];
    sprintf(name, "readSpeed_%08p.csv", this);
    FILE* file = fopen(name, "wt");
    fprintf(file, "Offset (bytes),Offset (GB),Read Speed (MB/sec)\n");
    for (size_t i = 0; i < readSpeed.size(); ++i) {
      fprintf(file, "%" PRIu64 ",%.3f,%.3f\n",
        readSpeed[i].offset,        // bytes
        readSpeed[i].offset * 1e-9, // GB
        readSpeed[i].speed * 1e-6   // MB/sec
      );
    }
    fclose(file);
  }
#endif
}

uint64_t FileIOContext_WindowsAsync::_getSize(HANDLE handle) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::try to retrieve file size as the regular file
  LARGE_INTEGER fileSize;
  if (::GetFileSizeEx(handle, &fileSize) != FALSE)
  {
    return (uint64_t)fileSize.QuadPart;
  }
  else
  {
    //tss_libio::try to retrieve file size as I/O device info
    GET_LENGTH_INFORMATION lenInfo; ::memset(&lenInfo, 0, sizeof(lenInfo));
    DWORD bytesReturned = 0;
    if (::DeviceIoControl(handle, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lenInfo, sizeof(lenInfo),
      &bytesReturned, NULL))
      return (uint64_t)lenInfo.Length.QuadPart;

    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to get file (%s, handle=%p) size: %s",
      m_path.c_str(), handle,
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return 0;
}

bool FileIOContext_WindowsAsync::lock()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bLocked = ::DeviceIoControl(m_handle, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bLocked == TRUE) {
    m_logger->info(__THIS_FUNC__, "'%s' is locked!!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to lock '%s': %s", 
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bLocked;
}

bool FileIOContext_WindowsAsync::unlock()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bUnLocked = ::DeviceIoControl(m_handle, FSCTL_UNLOCK_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bUnLocked) {
    m_logger->info(__THIS_FUNC__, "'%s' unlocked!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode, 
      "Failed to unlock '%s': %s", 
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bUnLocked;
}

bool FileIOContext_WindowsAsync::dismount()
{
  __DEV_CALLSTACK_FUNC__;
  DWORD stats = 0;
  const BOOL bDisMounted = ::DeviceIoControl(m_handle, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &stats, NULL);
  if (bDisMounted) {
    m_logger->info(__THIS_FUNC__, "'%s' dismounted!", m_path.c_str());
  }
  else {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to dismount '%s': %s", 
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  return bDisMounted;
}

size_t FileIOContext_WindowsAsync::_checkBlock(io_offset_t offset, size_t blockSize, const void* pData) const
{
  __DEV_CALLSTACK_FUNC__;
  if (pData == nullptr)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_DATA,
        "Data is NULL. I/O cannot be performed");
    return 0;
  }

  if (offset >= m_totalSize)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_INVALID_RANGE,
      "Out of range [0, %" PRIu64 "] access detected (offset=%" PRIu64 ")",
      m_totalSize - 1LLU,
      offset);
    return 0;
  }
  if (offset + blockSize > m_totalSize)
  {
    const size_t availableBlockSize = (size_t)std::min<uint64_t>(blockSize, m_totalSize - offset);
    m_logger->warning(__THIS_FUNC__, "Partial out of range [0, %" PRIu64 "] access detected [%" PRIu64 ", %" PRIu64 "]. Block size (%lu) reduced to %lu",
      m_totalSize - 1LLU,
      offset, offset + blockSize - 1LLU,
      (unsigned long)blockSize, (unsigned long)availableBlockSize);
    return availableBlockSize;
  }

  return blockSize;
}

size_t FileIOContext_WindowsAsync::readBlock(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle == INVALID_HANDLE_VALUE)
    return 0;

  const size_t blockSizeToRead = this->_checkBlock(offset, blockSize, pOutput);
  if (blockSizeToRead <= 0)
    return 0;

  // perform either synchronous read or asynchronous read
  if (!m_readState->background) 
    return this->_readSync(offset, blockSizeToRead, pOutput);
  
  return this->_readAsync(offset, blockSizeToRead, pOutput);
}

size_t FileIOContext_WindowsAsync::_readSync(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  // start with a synchronous read operation
  m_readState->background = false;

#ifdef MEASURE_READ_SPEED
  QueryPerformanceCounter(&m_start);
#endif

  // synchronous read: schedule asynchronous read operation
  m_readState->reset(offset, blockSize);
  BOOL bSuccess = ::ReadFile(m_handle, (LPVOID)pOutput, (DWORD)blockSize, NULL, &m_readState->overlapped);
  if (bSuccess == FALSE && ::GetLastError() != ERROR_IO_PENDING) {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to schedule read operation for file '%s': %s",
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

  // synchronous read: wait for operation to complete (ie. synchronize)
  DWORD bytesRead = 0;
  bSuccess = ::GetOverlappedResult(m_handle, &m_readState->overlapped, &bytesRead, TRUE);
  if (bSuccess == FALSE) {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
      "Failed to read data from file '%s': %s",
      m_path.c_str(),
      PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
    return 0;
  }

#ifdef MEASURE_READ_SPEED
  QueryPerformanceCounter(&m_finish);
  m_readSpeed.emplace_back(
    offset,
    (double)(bytesRead) / (double)(m_finish.QuadPart - m_start.QuadPart) * m_timerFrequency
  );
#endif

  // read ahead: schedule asynchronous read operation
  if (bytesRead == blockSize) 
  {
    this->_scheduleAsyncRead(offset + blockSize, blockSize);
  } else 
  {
    // doesn't make sense to schedule an asynchronous read operation now
    m_logger->warning(__THIS_FUNC__, "Data was read partially (%lu of %lu)",
      (unsigned long)bytesRead,
      (unsigned long)blockSize);
  }

  // finished
  return bytesRead;
}

size_t FileIOContext_WindowsAsync::_readAsync(io_offset_t offset, size_t blockSize, void* pOutput)
{
  __DEV_CALLSTACK_FUNC__;
  // wait for previous operation to complete
  DWORD bytesRead = 0;
  BOOL bSuccess = ::GetOverlappedResult(m_handle, &m_readState->overlapped, &bytesRead, TRUE);
  m_readState->background = false; // background operation finished

  // silently handle error or unexpected offset/blockSize
  if (bSuccess == FALSE || offset != m_readState->readOffset || blockSize != m_readState->readSz)
    return this->_readSync(offset, blockSize, pOutput);

#ifdef MEASURE_READ_SPEED
  QueryPerformanceCounter(&m_finish);
  m_readSpeed.emplace_back(
    offset,
    (double)(bytesRead) / (double)(m_finish.QuadPart - m_start.QuadPart) * m_timerFrequency
  );
#endif

  // load result of previous operation
  ::memcpy(pOutput, m_readState->buf, bytesRead);

  // read ahead: schedule asynchronous read operation
  if (bytesRead == blockSize)
  {
    this->_scheduleAsyncRead(offset + blockSize, blockSize);
  } else 
  {
    // doesn't make sense to schedule an asynchronous read operation now
    m_logger->warning(__THIS_FUNC__, "Data was read partially (%lu of %lu)",
      (unsigned long)bytesRead,
      (unsigned long)blockSize);
  }

  // finished
  return bytesRead;
}

void FileIOContext_WindowsAsync::_scheduleAsyncRead(io_offset_t offset, size_t blockSize)
{
  __DEV_CALLSTACK_FUNC__;
#ifdef MEASURE_READ_SPEED
  QueryPerformanceCounter(&m_start);
#endif
  void* pOutput = m_readState->reset(offset, blockSize); // NOTE: ReadFile() validates 'pOutput' before use
  BOOL bSuccess = ::ReadFile(m_handle, (LPVOID)pOutput, (DWORD)blockSize, NULL, &m_readState->overlapped);
  if (bSuccess == FALSE && ::GetLastError() != ERROR_IO_PENDING) {
    // silently discard read ahead errors
    m_readState->background = false;
  }
  else {
    m_readState->background = true;
  }
}

size_t FileIOContext_WindowsAsync::writeBlock(io_offset_t /*offset*/, size_t /*blockSize*/, const void* /*pData*/)
{
  __DEV_CALLSTACK_FUNC__;
  // not supported
  __TO_DO__("Add write support to class FileIOContext_WindowsAsync if required.");
  return 0;
}

void FileIOContext_WindowsAsync::flush()
{
  __DEV_CALLSTACK_FUNC__;
  // not supported
  __TO_DO__("Add write support to class FileIOContext_WindowsAsync if required.");
}

uint64_t FileIOContext_WindowsAsync::getSize() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_totalSize;
}
