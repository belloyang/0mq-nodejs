#ifndef ReadAheadIOContext_h__
#define ReadAheadIOContext_h__

#include "IIOContext.h"

#if !defined(DEV_PLATFORM_STM32)
#include <thread>
#include <mutex>
#include <atomic>
#include <condition_variable>

/// <summary>
/// Represents Context to perform sequential reading/caching of the next block after requested.
/// Should be wrapped with BufferedIOContext to avoid re-reading for the same blocks 
/// Buffered I/O context falls down to this context only when new block should be read -> this context has a buffer only for 'further' data (data read ahead)
/// For random access this context doesn't give any improvements.
/// </summary>
class ReadAheadIOContext : public IIOContext
{
public:
  /**
   * ReadAheadIOContext constructor
   * @param baseContext    root/main I/O context to be wrapped by this one. Usually low-level I/O (POSIX, WIndows, etc.)
   * @param logger    logger instance
   */
  ReadAheadIOContext(const std::shared_ptr<IIOContext>& baseContext,
      const std::shared_ptr<ILogger>& logger);

  /**
   * ReadAheadIOContext destructor
   */
  virtual ~ReadAheadIOContext();
  
  virtual size_t readBlock(io_offset_t offset, size_t blockSize, void* pOutput) __OVERRIDES__(IIOContext);
  virtual size_t writeBlock(io_offset_t offset, size_t blockSize, const void* pData) __OVERRIDES__(IIOContext);
  virtual void flush() __OVERRIDES__(IIOContext);
  virtual uint64_t getSize() const __OVERRIDES__(IIOContext);
  
  DECLARE_NOCOPYABLE(ReadAheadIOContext);

private:
  size_t _checkBlock(io_offset_t offset, size_t blockSize) const;
  //read ahead thread (thread that reads the data right after the block requested by 'readBlock' call)
  void _readAheadThread();
  //requests non-blocking reading of the next block after the one requested by readBlock call
  void _readAhead(const io_offset_t offset, const size_t blockSize);

private:
  const std::shared_ptr<IIOContext> m_baseContext;
  uint64_t m_totalSize;

  struct sReadAheadState
  {
    struct {
      io_offset_t offset;
      size_t size;
    } actual, requested; //ahead data ranges (when actual == requested -> data is read completely into buffer). readAhead does spurious wakeup check using this condition
    struct {
      void* data;
      size_t size;
    } completed_buffer, pending_buffer;
    enum : uint8_t {
      IO_READY = 0, // NOTE: '0' necessary for initialization (see ReadAheadIOContext constructor)
      IO_PENDING,
      IO_ERROR
    } ioStatus;
  } m_state; //read ahead state (uses 'm_mutex' for multithread arbitration)

  std::mutex m_mutex;
  std::mutex m_ioMutex; //mutex used for I/O protection only
  std::condition_variable m_readAheadEvent; //event that is triggered when ahead data should be read
  
  std::condition_variable m_aheadDataRead; //event that is triggered once ahead data is read
  
  std::atomic<bool> m_bFinishRequested; //finish requested flag
  std::atomic<bool> m_bFinished; //context usage finished flag
  std::condition_variable m_readAheadThreadFinished; //event that is triggered when read ahead thread is finished
};

#endif //!defined(DEV_PLATFORM_STM32)

#endif //ReadAheadIOContext_h__
