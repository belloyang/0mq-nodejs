#include "zip_utils.h"
#include <algorithm>

namespace zip_utils
{
  const uint32_t LOCAL_FILE_SIGNATURE = 0x04034b50u;
  const uint32_t DATA_DESCRIPTOR_SIGNATURE = 0x08074b50u;
  enum GeneralPurposeFlags : uint8_t
  {
    ENCRYPTED = 0x1
  };

  #pragma pack(push, 1)
  struct LocalFileHeader
  {
    uint32_t signature = 0u; // Local file header signature = 0x04034b50 (read as a little-endian number)
    uint16_t version = 0u; // Version needed to extract (minimum)
    uint16_t flags = 0u; //   General purpose bit flag
    uint16_t compressionMethod = 0u; // Compression method
    uint16_t modificationTime = 0u; // File last modification time
    uint16_t modificationDate = 0u; // File last modification date
    uint32_t crc32 = 0u; // CRC32 hash sum
    uint32_t compressedSize = 0u; // Compressed size
    uint32_t uncompressedSize = 0u; // Uncompressed size
    uint16_t fileNameLength = 0u; // File name length
    uint16_t extraFieldLength = 0u; // Extra field length
    //uint8_t file_name[fileNameLength]
    //uint8_t extra_field[extraFieldLength]
  };
  #pragma pack(pop)

  uint32_t parse(const std::shared_ptr<IIOContext>& context, const std::shared_ptr<ILogger>& logger,
      std::vector<FileInfo>& outputInfo)
  {
    __DEV_CALLSTACK_FUNC__;
    outputInfo.clear();
    const uint64_t fileSize = context->getSize();
    io_offset_t headerOffset = 0ull;
    uint32_t nFiles = 0u;
    do
    {
      // check boundaries
      if (headerOffset + sizeof(LocalFileHeader) > fileSize)
      {
        break;
      }

      // read header
      struct LocalFileHeader header;
      context->readBlock(headerOffset, sizeof(header), &header);
      // check if it's zipped (local) file header
      if (header.signature != LOCAL_FILE_SIGNATURE)
      {
        break;
      }

      // read file name
      char fileName[64] = {0};
      context->readBlock(headerOffset + sizeof(header), std::min<size_t>(NUM_ELEMENTS(fileName), header.fileNameLength), fileName);

      // no compression check
      if ((header.compressionMethod != 0) ||
          (header.compressedSize != header.uncompressedSize))
      {
        logger->warning(__THIS_FUNC__, "File '%s' is compressed (not supported yet). Will be skipped!", fileName);
      }
      // no encryption check
      else if (header.flags & GeneralPurposeFlags::ENCRYPTED)
      {
        logger->warning(__THIS_FUNC__, "File '%s' is encrypted (not supported yet). Will be skipped!", fileName);
      }
      else
      {
        FileInfo fileInfo;
        fileInfo.name = std::string(fileName);
        // calculate data offset in context (casting to uint32_t should be fine due to file size)
        fileInfo.offset = static_cast<uint32_t>(headerOffset + (sizeof(header) + header.fileNameLength + header.extraFieldLength));
        fileInfo.length = header.uncompressedSize;
        fileInfo.crc32 = header.crc32;
        outputInfo.emplace_back(fileInfo);
        nFiles++;
      }
      headerOffset += sizeof(header) + header.fileNameLength + header.extraFieldLength + header.compressedSize;
    }
    while (true);
    // return amount of files found in zip file
    return nFiles;
  }
} // namespace
