#include "fat32_utils.h"

#include "fat32_headers.h"

#include "../IOContext/io_contexts.h"
#include "../PlatformUtils/PlatformUtils.h"

#include <cstring> // memcpy
#include <algorithm>
#include <cinttypes>

namespace fat32_utils
{
  //http://read.pudn.com/downloads77/ebook/294884/FAT32%20Spec%20%28SDA%20Contribution%29.pdf
  //https://www.pjrc.com/tech/8051/ide/fat32.html
  //https://github.com/pbatard/rufus/

  static const uint8_t BOOT_SIGNATURE[2] = { 0x55, 0xAA };

  namespace fat32
  {
    uint32_t get_fat_begin_lba(const uint32_t lba_begin, const sBootEntry_FAT32& bootEntry)
    {
      __DEV_CALLSTACK_FUNC__;
      return lba_begin + bootEntry.BPB_RsvdSecCnt;
    }

    uint32_t get_cluster_begin_lba(const uint32_t lba_begin, const sBootEntry_FAT32& bootEntry)
    {
      __DEV_CALLSTACK_FUNC__;
      return lba_begin + bootEntry.BPB_RsvdSecCnt + (bootEntry.BPB_NumFATs *  bootEntry.BPB_FATSz32);
    }

    uint32_t get_lba(const uint32_t lba_begin, const sBootEntry_FAT32& bootEntry, const uint32_t cluster_number)
    {
      __DEV_CALLSTACK_FUNC__;
      const uint32_t cluster_begin_lba = get_cluster_begin_lba(lba_begin, bootEntry);
      return cluster_begin_lba + (cluster_number - 2) * bootEntry.BPB_SecPerClus;
    }

    uint32_t get_root_dir_lba(const uint32_t lba_begin, const sBootEntry_FAT32& bootEntry)
    {
      __DEV_CALLSTACK_FUNC__;
      return get_lba(lba_begin, bootEntry, bootEntry.BPB_RootClus);
    }

    /*
     * Proper computation of FAT size
     * See: http://www.syslinux.org/archives/2016-February/024850.html
     * and subsequent replies.
     */
    uint32_t calculate_fat_size(const sBootEntry_FAT32& bootEntry)
    {
      __DEV_CALLSTACK_FUNC__;
      const uint32_t FatElementSize = 4;
      const uint32_t ReservedClusCnt = 2;
      const uint32_t numerator = bootEntry.BPB_TotSec32 - bootEntry.BPB_RsvdSecCnt + ReservedClusCnt * bootEntry.BPB_SecPerClus;
      const uint32_t denominator = bootEntry.BPB_SecPerClus * bootEntry.BPB_BytsPerSec / FatElementSize + bootEntry.BPB_NumFATs;
      const uint32_t fatSz = numerator / denominator + 1;	// +1 to ensure we are rounded up
      return fatSz;
    }
  }

  void unpack_CHS(const CHSAddress_t& chs, uint8_t& head, uint8_t& sector, uint16_t& cylinder)
  {
    __DEV_CALLSTACK_FUNC__;
    head = chs.bytes.head;
    sector = (chs.bytes.sector & 0x3F); //0-5 bits
    const uint16_t cylinder_high = (uint16_t)(chs.bytes.sector >> 6); //6-7 bits for cylinder high
    const uint16_t cylinder_low = (uint16_t)chs.bytes.cylinder;
    cylinder = (cylinder_high << 8) | cylinder_low;
  }

  void pack_CHS(const uint8_t head, const uint8_t sector, const uint16_t cylinder, CHSAddress_t& ret)
  {
    __DEV_CALLSTACK_FUNC__;
    ret.bytes.head = head;
    ret.bytes.sector = ((cylinder & 0xFF00) >> 2) | sector; //2 high bits of cylinder | sector)
    ret.bytes.cylinder = (uint8_t)(cylinder & 0x00FF); //low 8 bits of cylinder
  }

  uint32_t CHS_to_LBA(const CHSAddress_t& chs, uint16_t headsPerCylinder, uint16_t sectorsPerTrack)
  {
    __DEV_CALLSTACK_FUNC__;
    uint8_t head = 0, sector = 0;
    uint16_t cylinder = 0;
    //unpack head, sector & cylinder from CHS bytes (3 bytes)
    unpack_CHS(chs, head, sector, cylinder);
    //calculate lba
    const uint32_t lba = (cylinder * headsPerCylinder + head) * sectorsPerTrack + (sector - 1);
    return lba;
  }

  CHSAddress_t LBA_to_CHS(uint32_t lbaAddress, uint16_t headsPerCylinder, uint16_t sectorsPerTrack)
  {
    __DEV_CALLSTACK_FUNC__;
    //calculate head, sector and cylinder indices
    const uint8_t head = (lbaAddress / sectorsPerTrack) % headsPerCylinder;
    const uint8_t sector = (lbaAddress % sectorsPerTrack) + 1;
    const uint16_t cylinder = lbaAddress / (headsPerCylinder * sectorsPerTrack);
    //pack result to CHS
    CHSAddress_t ret = CHSAddress_t{ {0, 0, 0} };
    pack_CHS(head, sector, cylinder, ret);
    return ret;
  }

  bool write_FAT32_Partition(const std::shared_ptr<IIOContext>& context, const std::string& volumeLabel,
    const uint32_t sizeInMiB, const std::shared_ptr<ILogger>& logger)
  {
    __DEV_CALLSTACK_FUNC__;
    char label[MAX_VOLUME_LABEL_LENGTH] = { 0 }; // volume label
    {
      const size_t labelLen = volumeLabel.length();
      if (labelLen > MAX_VOLUME_LABEL_LENGTH)
      {
        logger->warning(__THIS_FUNC__, "FAT32 volume label '%s' exceeds max %" PRIu32 " length. Will be truncated!",
          volumeLabel.c_str(),
          static_cast<uint32_t>(MAX_VOLUME_LABEL_LENGTH));
      }
      //tss_harv::fill up label with spaces
      ::memset(label, ' ', MAX_VOLUME_LABEL_LENGTH);
      //tss_harv::copy volume label argument to label
      ::memcpy(label, volumeLabel.c_str(), std::min<size_t>(MAX_VOLUME_LABEL_LENGTH, labelLen));
    }
    const uint32_t BytesPerSect = 512;
    const uint32_t SectorPerMiB = (1024 * 1024 / BytesPerSect);

    //tss_psflib::create FAT32 LBA partition with specified size in MiB
    sClassicalGenericMBR mbr; ::memset(&mbr, 0, sizeof(mbr));
    {
      mbr.part0.status = sPartitionEntry::STATUS_INACTIVE;
      mbr.part0.partition_id = ePartitionID_t::PARTITION_ID_FAT32X_LBA;
      //The size of the advanced format sector was chosen because it matches the x86 page size and the NTFS cluster size." (Windows Internals, 6th Edition, 2012, Part 2, page 126)]
      //The point for technicians or forensics investigators working with Windows 7 OS hard disks (on either current or future models) being that they now have a much larger sized reserved space (1,048,576 bytes vs. 32,256 bytes)
      //they must deal with (https://thestarman.pcministry.com/asm/mbr/W7MBR.htm) -> 1MiB alignment (offset) is chosen
      mbr.part0.lba_begin = SectorPerMiB * 1; //1MiB offset
      mbr.part0.n_sectors = SectorPerMiB * sizeInMiB;
      //tss_psflib::set signature (0x55, 0xAA)
      ::memcpy(mbr.signature, BOOT_SIGNATURE, sizeof(BOOT_SIGNATURE));
    }

    //tss_psflib::init partition#0 Master Boot Record (MBR)
    sBootEntry_FAT32 bootEntry32; ::memset(&bootEntry32, 0, sizeof(bootEntry32));
    {
      const uint8_t jmpBoot[3] = { 0xEB, 0x58, 0x90 }; //NOP opstring sequence since DOS2.0
      const char oemName[8] = { 'M', 'S', 'D', 'O', 'S', '5', '.', '0' }; //MSDOS5.1 or any other recognizable names recommended
      const char fileSysType[8] = { 'F', 'A', 'T', '3', '2', ' ', ' ', ' ' };

      ::memcpy(bootEntry32.BS_jmp_boot, jmpBoot, sizeof(jmpBoot));
      ::memcpy(bootEntry32.BS_OEMName, oemName, sizeof(oemName));
      bootEntry32.BPB_BytsPerSec = BytesPerSect;
      bootEntry32.BPB_SecPerClus = 1;
      bootEntry32.BPB_RsvdSecCnt = 32;
      bootEntry32.BPB_NumFATs = 2;
      bootEntry32.BPB_Media = eBootEntryMediaType_t::MEDIA_TYPE_HDD;
      bootEntry32.BPB_SecPerTrk = 63;
      bootEntry32.BPB_NumHeads = 255;
      bootEntry32.BPB_HiddSec = SectorPerMiB * 1;
      bootEntry32.BPB_TotSec32 = SectorPerMiB * sizeInMiB;
      bootEntry32.BPB_FATSz32 = fat32::calculate_fat_size(bootEntry32);
      bootEntry32.BPB_RootClus = 0x2;  /* Cluster where the root directory can be found */
      bootEntry32.BPB_FSInfo = 1; //usually 1
      bootEntry32.BPB_BkBootSec = 6;
      bootEntry32.BS_DrvNum = 0x80;
      bootEntry32.BS_BootSig = 0x29; //indicates the following 3 fields are not empty
      bootEntry32.BS_VolID = 402653184;
      ::memcpy(bootEntry32.BS_VolLab, label, MAX_VOLUME_LABEL_LENGTH);
      ::memcpy(bootEntry32.BS_FileSysType, fileSysType, sizeof(fileSysType));
      ::memcpy(bootEntry32.BS_signature, BOOT_SIGNATURE, sizeof(BOOT_SIGNATURE));
    }

    const uint32_t UserAreaSize = bootEntry32.BPB_TotSec32 - bootEntry32.BPB_RsvdSecCnt - (bootEntry32.BPB_NumFATs * bootEntry32.BPB_FATSz32);
    const uint32_t ClusterCount = UserAreaSize / bootEntry32.BPB_SecPerClus;

    //size checks
    {
      if (ClusterCount > 0x0FFFFFFF)
      {
        logger->error(__THIS_FUNC__,
          eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_WRITING_FAILED,
          "This drive has more than 2^28 clusters, try to specify a larger cluster size");
        return false;
      }
      if (ClusterCount < 65536)
      {
        logger->error(__THIS_FUNC__,
          eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_WRITING_FAILED,
          "FAT32 must have at least 65536 clusters, try to specify a smaller cluster size");
        return false;
      }
      const uint32_t FatNeeded = (ClusterCount * 4 + (BytesPerSect - 1)) / BytesPerSect;
      if (FatNeeded > bootEntry32.BPB_FATSz32)
      {
        logger->error(__THIS_FUNC__,
          eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_WRITING_FAILED,
          "This drive is too big for large FAT32 format");
        return false;
      }
    }

    //burst data
    {
      const uint32_t SystemAreaSize = bootEntry32.BPB_RsvdSecCnt + (bootEntry32.BPB_NumFATs * bootEntry32.BPB_FATSz32) + bootEntry32.BPB_SecPerClus;
#if defined(DEV_PLATFORM_STM32)
      __TO_DO__("Do some experiments to decide the better burst sectors count with respect to heap size!");
      const uint32_t BurstSizeSectors = 2; // We do not have much luxury to afford very big burst block on MCU
#else
      const uint32_t BurstSizeSectors = 128; // Zero in blocks of 64K typically
#endif //defined(DEV_PLATFORM_STM32)
      uint8_t* pZeroSect = reinterpret_cast<uint8_t*>(::calloc(BytesPerSect, BurstSizeSectors));
      const uint32_t BurstSizeBytes = BurstSizeSectors * BytesPerSect;
      for (uint32_t i = 0; i < (SystemAreaSize + BurstSizeSectors - 1); i += BurstSizeSectors)
      {
        if (context->writeBlock((i + mbr.part0.lba_begin) * BytesPerSect, BurstSizeBytes, pZeroSect) != BurstSizeBytes)
        {
          logger->error(__THIS_FUNC__,
            eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_WRITING_FAILED,
            "This drive is too big for large FAT32 format");
          ::free(pZeroSect);
          return false;
        }
      }
      ::free(pZeroSect);
      context->flush();
    }

    //constructing and dumping FSInfo and dumping boot entry
    {
      sFSInfo_FAT32 fsInfo; ::memset(&fsInfo, 0, sizeof(fsInfo));
      {
        fsInfo.FSI_LeadSig = 0x41615252; //lead signature is used to validate the beginning of the FSInfo structure in the sector
        fsInfo.FSI_StrucSig = 0x61417272; //additional signature validating the integrity of the FSInfo structure.
        fsInfo.FSI_TrailSig = 0xaa550000; //trail signature used to validate the integrity of the data in the sector containing the FSInfo structure
        fsInfo.FSI_Free_Count = (UserAreaSize / bootEntry32.BPB_SecPerClus) - 1;
        fsInfo.FSI_Nxt_Free = 3; // clusters 0-1 reserved, we used cluster 2 for the root dir
      }
      // Now we should write the boot sector and fsinfo twice, once at 0 and once at the backup boot sect position
      for (int i = 0; i < 2; i++)
      {
        const uint32_t SectorStart = (i == 0) ? 0 : bootEntry32.BPB_BkBootSec;
        if (context->writeBlock((SectorStart + mbr.part0.lba_begin) * BytesPerSect, sizeof(bootEntry32), &bootEntry32) != sizeof(bootEntry32))
        {
          const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
          logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
            "Failed to write FAT32 boot sector!!!: %s",
            PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
          return false;
        }
        if (context->writeBlock((SectorStart + mbr.part0.lba_begin + 1) * BytesPerSect, sizeof(fsInfo), &fsInfo) != sizeof(fsInfo))
        {
          const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
          logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
            "Failed to write FSInfo!!!: %s",
            PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
          return false;
        }
      }
      context->flush();
    }

    //write Fats
    {
      //first sector of FAT
      uint32_t pFirstSectOfFat[BytesPerSect / sizeof(uint32_t)] = { 0 };
      {
        pFirstSectOfFat[0] = 0x0ffffff8; // Reserved cluster 1 media id in low byte
        pFirstSectOfFat[1] = 0x0fffffff; // Reserved cluster 2 EOC
        pFirstSectOfFat[2] = 0x0fffffff; // end of cluster chain for root dir
      }
      // Write the first fat sector in the right places
      for (uint32_t i = 0; i < bootEntry32.BPB_NumFATs; i++)
      {
        const uint32_t SectorStart = bootEntry32.BPB_RsvdSecCnt + (i * bootEntry32.BPB_FATSz32);
        //write_sectors(hLogicalVolume, BytesPerSect, SectorStart, 1, pFirstSectOfFat);
        if (context->writeBlock((SectorStart + mbr.part0.lba_begin) * BytesPerSect, sizeof(pFirstSectOfFat), pFirstSectOfFat) != sizeof(pFirstSectOfFat))
        {
          const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
          logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
            "Failed to write FAT sector!!!: %s",
            PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
          return false;
        }
      }
      context->flush();
    }

    //construct and flush RootDirectory entry
    {
      sDirectoryEntry dirEntry; ::memset(&dirEntry, 0, sizeof(dirEntry));
      {
        ::memcpy(dirEntry.header.whole, label, MAX_VOLUME_LABEL_LENGTH);
        dirEntry.fileAttributes = sDirectoryEntry::eFileAttributes::ATTR_ARCHIVE | sDirectoryEntry::eFileAttributes::ATTR_VOLUME_ID; // attributes for volume label
      }
      if (context->writeBlock(fat32::get_root_dir_lba(mbr.part0.lba_begin, bootEntry32) * BytesPerSect, sizeof(dirEntry), &dirEntry) != sizeof(dirEntry))
      {
        const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
        logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
          "Failed to write Root Directory Entry!!!: %s",
          PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
        return false;
      }
      context->flush();
    }

    //tss_psflib::dump MBR (do this at the end to avoid semi-broken state for formatting command)
    {
      if (context->writeBlock(0, sizeof(mbr), &mbr) != sizeof(mbr))
      {
        const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
        logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
          "Failed to write Master Boot Record (MBR)!!!: %s",
          PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
        return false;
      }
      context->flush();
    }

    return true;
  }

  bool verify_MBR(const sClassicalGenericMBR& mbr)
  {
    __DEV_CALLSTACK_FUNC__;
    //verify signature
    return (::memcmp(mbr.signature, BOOT_SIGNATURE, sizeof(BOOT_SIGNATURE)) == 0);
  }

  bool verify_BootEntry(const sBootEntry_FAT32& entry)
  {
    __DEV_CALLSTACK_FUNC__;
    //verify signature
    return (::memcmp(entry.BS_signature, BOOT_SIGNATURE, sizeof(BOOT_SIGNATURE)) == 0);
  }

  bool isDirtyFlagSet(const sBootEntry_FAT32& entry)
  {
    __DEV_CALLSTACK_FUNC__;
    return ((entry.BS_Reserved1 & 0x01) != 0); // check lowest bit ('dirty flag')
  }

  void clearDirtyFlag(sBootEntry_FAT32& entry)
  {
    __DEV_CALLSTACK_FUNC__;
    entry.BS_Reserved1 &= 0xFE; // discard lowest bit ('dirty flag')
  }

} //namespace fat32_utils
