#ifndef fat32_headers_h__
#define fat32_headers_h__

#include "../libio_defines.h"

//https://en.wikipedia.org/wiki/Master_boot_record#PTE
//https://www.easeus.com/resource/fat32-disk-structure.htm
//https://www.pjrc.com/tech/8051/ide/fat32.html
//https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system

// enforce compact byte packing for all subsequent unions and structures in this file
#pragma pack(push, 1)

#define MAX_VOLUME_LABEL_LENGTH 11 // equivalent to 8+3 DOS file name length

//! used/common partition ID
typedef enum : uint8_t
{
  PARTITION_ID_FAT32      = 0x0B, /*!< FAT32 partition (CHS) */
  PARTITION_ID_FAT32X_LBA = 0x0C, /*!< FAT32X partition (LBA) */
  PARTITION_ID_FAT16X_LBA = 0x0E  /*!< FAT16X partition (LBA) */
} ePartitionID_t;

//! used/common media types
typedef enum : uint8_t
{
  MEDIA_TYPE_FLOPPY = 0xF0, /*!< floppy disk media type */
  MEDIA_TYPE_HDD    = 0xF8, /*!< HDD disk media type (covers USB stick as well) */
} eBootEntryMediaType_t;

//! Cylinder-Head-Sector address structure
typedef union
{
  uint8_t data[3]; //! packed data
  struct sBytes
  {
    uint8_t head; //! [7 to 0] bits
    uint8_t sector; //! bits [5 to 0] for sector; bits [7 to 6] for cylinder high bits (8 & 9 bites)
    uint8_t cylinder; //! bits [7 to 0] for cylinder low byte
  } bytes;
} CHSAddress_t;

//! boot entry structure (FAT32)
typedef struct
{
  uint8_t BS_jmp_boot[3];  /* Assembly instruction to jump to boot code */
  uint8_t BS_OEMName[8];   /* OEM Name in ASCII */
  uint16_t BPB_BytsPerSec;   /* Bytes per sector. Allowed values include 512,1024, 2048, and 4096 */
  uint8_t BPB_SecPerClus;   /* Sectors per cluster (data unit). Allowed values are powers of 2, but the cluster size must be 32KB  or smaller */
  uint16_t BPB_RsvdSecCnt;  /* Size in sectors of the reserved area */
  uint8_t BPB_NumFATs;   /* Number of FATs */
  uint16_t BPB_RootEntCnt;  /* Maximum number of files in the root directory for FAT12 and FAT16. This is 0 for FAT32 */
  uint16_t BPB_TotSec16;   /* 16-bit value of number of sectors in file system */
  uint8_t BPB_Media; /* Media type. eBootEntryMediaType_t */
  uint16_t BPB_FATSz16;  /* 16-bit size in sectors of each FAT for FAT12 and FAT16. For FAT32, this field is 0 */
  uint16_t BPB_SecPerTrk;   /* Sectors per track of storage device */
  uint16_t BPB_NumHeads;  /* Number of heads in storage device */
  uint32_t BPB_HiddSec;  /* Number of sectors before the start of partition */
  uint32_t BPB_TotSec32;  /* 32-bit value of number of sectors in file system.  Either this value or the 16-bit value above must be  0 */
  uint32_t BPB_FATSz32;  /* 32-bit size in sectors of one FAT */
  uint16_t BPB_ExtFlags;  /* A flag for FAT */
  uint16_t BPB_FSVer;  /* The major and minor version number */
  uint32_t BPB_RootClus;  /* Cluster where the root directory can be found */
  uint16_t BPB_FSInfo;  /* Sector where FSINFO structure can be found */
  uint16_t BPB_BkBootSec;  /* Sector where backup copy of boot sector is located */
  uint8_t BPB_Reserved[12];  /* Reserved */
  uint8_t BS_DrvNum;  /* BIOS INT13h drive number */
  uint8_t BS_Reserved1;  /* Should always be 0 for FAT32, but in reality is the volume dirty bit */
  uint8_t BS_BootSig;  /* Extended boot signature to identify if the next three values are valid */
  uint32_t BS_VolID;    /* Volume serial number */
  uint8_t BS_VolLab[MAX_VOLUME_LABEL_LENGTH];  /* Volume label in ASCII. User defines when creating the file system */
  uint8_t BS_FileSysType[8];  /* File system type label in ASCII */
  uint8_t BS_executable_code[420]; /* Executable Code */
  uint8_t BS_signature[2]; /* Boot Record Signature (55hAAh) */
} sBootEntry_FAT32;

//! Partition entry structure
typedef struct
{
  typedef enum : uint8_t
  {
    STATUS_INACTIVE = 0x00,
    STATUS_ACTIVE   = 0x80,
  } ePartitionStatus;
  uint8_t status; //! Boot indicator - 0x80 = active, 0x00 - inactive
  CHSAddress_t start_sector_address; //! partition start
  uint8_t partition_id; //! Partition ID (example ID=1 for FAT12) (system_indicator)
  CHSAddress_t end_sector_address; //! partition end
  uint32_t lba_begin; //! Number of sectors before the beginning of this partition (sectors_before)
  uint32_t n_sectors; //! Number of sectors in this partition (number_of_sectors)
} sPartitionEntry;

//! Classical generic master boot record structure
typedef struct
{
  uint8_t boot_strap_area[446];
  sPartitionEntry part0;
  sPartitionEntry part1;
  sPartitionEntry part2;
  sPartitionEntry part3;
  uint8_t signature[2]; //! should be { 0x55, 0xAA };
} sClassicalGenericMBR;

//! Compact time representation for FAT16. NOTE: little endian assumed.
typedef struct
{
  uint16_t sec  : 5; //! bits 0-4, seconds/2, 0-29, ie. 2 second resolution - see 'createFine' member in 'sDirectoryEntry'
  uint16_t min  : 6; //! bits 5-10, minutes, 0-59
  uint16_t hour : 5; //! bits 11-15, hours, 0-23
} sPackedTime;

//! Compact date representation for FAT16. NOTE: little endian assumed.
typedef struct
{
  uint16_t day   : 5; //! bits 0-4, day, 1-31
  uint16_t month : 4; //! bits 5-8, month, 1-12
  uint16_t year  : 7; //! bits 9-15, year-1980, 0-127
} sPackedDate;

//! 32-byte directory entry structure for FAT16. Used for the root folder that holds the volume label.
typedef struct
{
  union
  {
    struct sDetails
    {
      uint8_t fileName[8]; //! short file name, right pad with spaces
      uint8_t fileExt[3];  //! short file extension, right pad with spaces
	} details;
    uint8_t whole[11];     //! 8+3 file name
  } header;
  enum eFileAttributes : uint8_t
  {
    ATTR_READ_ONLY = 0x01,
    ATTR_HIDDEN    = 0x02,
    ATTR_SYSTEM    = 0x04,
    ATTR_VOLUME_ID = 0x08,
    ATTR_DIRECTORY = 0x10,
    ATTR_ARCHIVE   = 0x20,
    ATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID
  };
  uint8_t fileAttributes; //! file attributes (read only, hidden, etc)
  uint8_t userAttributes; //! weird stuff, platform specific
  uint8_t createFine;     //! creation time, 10-millisecond part, 0-199, ie. just shy of 2 second span
  sPackedTime createTime; //! creation time
  sPackedDate createDate; //! creation date
  sPackedDate accessDate; //! last access date
  uint16_t accessRights;  //! access rights bitmap
  sPackedTime modifyTime; //! last modification time
  sPackedDate modifyDate; //! last modification date
  uint16_t startFileClusters; //! start of file in clusters
  uint32_t fileSizeBytes; //! set to 0 for volume label
  uint8_t UNUSED[480]; //the rest of the data to fill it up to 512 bytes*/
} sDirectoryEntry;

typedef struct
{
  uint32_t FSI_LeadSig; // 0 4 Value = 0x41615252. This lead signature is used to validate the beginning of the FSInfo structure in the sector.
  uint8_t FSI_Reserved1[480];// 4 480 Reserved. Must be set to 0.
  uint32_t FSI_StrucSig;// 484 4 Value = 0x61417272. An additional signature validating the integrity of the FSInfo structure.
  uint32_t FSI_Free_Count;// 488 4 Contains the last known free cluster count on the volume.
  //The value 0xFFFFFFFF indicates the free count is not known.
  //The contents of this field must be validated at volume mount (and subsequently maintained in memory by the file system driver implementation).
  //It is recommended that this field contain an accurate count of the number of free clusters at volume dismount (during controlled dismount/shutdown).
  uint32_t FSI_Nxt_Free;// 492 4 Contains the cluster number of the first available (free) cluster on the volume. The value 0xFFFFFFFF indicates that there exists
  //no information about the first available (free) cluster. The contents of this field must be validated at volume mount.
  //It is recommended that this field be appropriately updated at volume dismount (during controlled dismount/shutdown).
  uint8_t FSI_Reserved2[12];// 496 12 Reserved. Must be set to 0.
  uint32_t FSI_TrailSig;// 508 4 Value = 0xAA550000. This trail signature is used to validate the integrity of the data in the sector containing the FSInfo structure.
} sFSInfo_FAT32;

#pragma pack(pop) // #pragma pack(push, 1)

#endif //fat32_headers_h__
