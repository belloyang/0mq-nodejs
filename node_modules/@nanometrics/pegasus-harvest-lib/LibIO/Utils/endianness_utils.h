#ifndef endianness_utils_h__
#define endianness_utils_h__

#include "../libio_defines.h"

namespace endianness_utils
{
  #if defined(_MSC_VER)
    #define __byte_swap16 _byteswap_ushort
    #define __byte_swap32 _byteswap_ulong
    #define __byte_swap64 _byteswap_uint64
  #else
    #define __byte_swap16 __builtin_bswap16
    #define __byte_swap32 __builtin_bswap32
    #define __byte_swap64 __builtin_bswap64
  #endif

  FORCE_INLINE bool is_big_endian()
  {
    volatile uint8_t bytes[2] = { 0x00, 0x01 };
    volatile uint16_t val = *(uint16_t*)(bytes);
    return (val == 0x0001);
  }

  FORCE_INLINE bool is_little_endian()
  {
    volatile uint8_t bytes[2] = { 0x00, 0x01 };
    volatile uint16_t val = *(uint16_t*)(bytes);
    return (val == 0x0100);
  }

  template <typename T> T swap(T in);

  template <> FORCE_INLINE int8_t  swap(int8_t value)  { return value; }
  template <> FORCE_INLINE uint8_t swap(uint8_t value) { return value; }

  template <> FORCE_INLINE int16_t  swap(int16_t value)  { return __byte_swap16(value); }
  template <> FORCE_INLINE uint16_t swap(uint16_t value) { return __byte_swap16(value); }

  template <> FORCE_INLINE int32_t  swap(int32_t value)  { return __byte_swap32(value); }
  template <> FORCE_INLINE uint32_t swap(uint32_t value) { return __byte_swap32(value); }

  template <> FORCE_INLINE int64_t  swap(int64_t value)  { return __byte_swap64(value); }
  template <> FORCE_INLINE uint64_t swap(uint64_t value) { return __byte_swap64(value); }

  template <> FORCE_INLINE float swap(float value)
  {
    float ret = 0.f;
    uint32_t* inPtr  = reinterpret_cast<uint32_t*>(&value);
    uint32_t* outPtr = reinterpret_cast<uint32_t*>(&ret);
    *outPtr = swap<uint32_t>(*inPtr);
    return ret;
  }
  template <> FORCE_INLINE double swap(double value)
  {
    double ret = 0.0;
    uint64_t* inPtr  = reinterpret_cast<uint64_t*>(&value);
    uint64_t* outPtr = reinterpret_cast<uint64_t*>(&ret);
    *outPtr = swap<uint64_t>(*inPtr);
    return ret;
  }
}

#endif // endianness_utils_h__
