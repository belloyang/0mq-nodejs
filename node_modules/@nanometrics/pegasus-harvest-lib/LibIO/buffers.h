#ifndef buffers_h__
#define buffers_h__

#include "libio_defines.h"
#include <cstring> // memset, memcpy

/// <summary>
/// Base class for different buffer types.
/// NOTE!: Child/derived classes are responsible for resource management (allocation, freeing, etc.)
/// </summary>
template <class T>
class buffer_base
{
protected:
  buffer_base() : m_ptr(nullptr)
  {
    __DEV_CALLSTACK_FUNC__;
    m_size.nElements = 0;
    m_size.allocated = m_size.used = 0LL;
  }

public:
  virtual ~buffer_base() {}

  FORCE_INLINE size_t size() const { return m_size.used; }
  FORCE_INLINE uint32_t count() const { return m_size.nElements; }

  template <typename TRet = T>
  FORCE_INLINE TRet* ptr() { return reinterpret_cast<TRet*>(m_ptr); }
  template <typename TRet = T>
  FORCE_INLINE const TRet* ptr() const { return reinterpret_cast<const TRet*>(m_ptr); }

  template <typename TRet = T>
  FORCE_INLINE TRet& at(const uint32_t index) { return (reinterpret_cast<TRet*>(m_ptr))[index]; }
  template <typename TRet = T>
  FORCE_INLINE const TRet& at(const uint32_t index) const { return (reinterpret_cast<const TRet*>(m_ptr))[index]; }

  FORCE_INLINE operator void*() { return m_ptr; }
  FORCE_INLINE operator const void*() const { return m_ptr; }

  FORCE_INLINE operator T*() { return m_ptr; }
  FORCE_INLINE operator const T*() const { return m_ptr; }

  FORCE_INLINE void clear() { ::memset(m_ptr, 0, m_size.allocated); }

  FORCE_INLINE bool empty() const { return (m_ptr == nullptr); }

  virtual void realloc(const uint32_t nElements) = 0;

protected:
  T* m_ptr;
  struct {
    uint32_t nElements;
    size_t allocated;
    size_t used;
  } m_size;

private:
  // not implemented
  buffer_base(const buffer_base&) = delete;
  buffer_base& operator=(const buffer_base&) = delete;
};

/// <summary>
/// Wrapper class for 'malloc'-allocated buffer
/// </summary>
template <class T>
class buffer_malloc : public buffer_base<T>
{
public:
  buffer_malloc(const uint32_t nElements) : buffer_base<T>()
  {
    __DEV_CALLSTACK_FUNC__;
    if (nElements > 0) {
      const size_t newSize = nElements * sizeof(T);
      this->m_ptr = reinterpret_cast<T*>(::malloc(newSize));
      this->m_size.allocated = this->m_size.used = newSize;
      this->m_size.nElements = nElements;
    }
  }

  virtual ~buffer_malloc()
  {
    __DEV_CALLSTACK_FUNC__;
    ::free(this->m_ptr);
  }

  virtual void realloc(const uint32_t nElements) __OVERRIDES__(buffer_base<T>)
  {
    __DEV_CALLSTACK_FUNC__;
    const size_t newSize = sizeof(T) * nElements;
    if (this->m_size.allocated < newSize) {
      this->m_ptr = reinterpret_cast<T*>(::realloc(this->m_ptr, newSize));
      this->m_size.allocated = newSize;
    }
    this->m_size.nElements = nElements;
    this->m_size.used = newSize;
  }

private:
  // not implemented
  buffer_malloc(const buffer_malloc&) = delete;
  buffer_malloc& operator=(const buffer_malloc&) = delete;
};

/// <summary>
/// Wrapper class for pre-allocated buffer
/// </summary>
template <class T>
class buffer_preallocated : public buffer_base<T>
{
public:
  buffer_preallocated(T* pData, const size_t nElements) : buffer_base<T>()
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pData != nullptr && nElements > 0 && "preallocated buffer is invalid!");
    const size_t newSize = nElements * sizeof(T);
    this->m_ptr = pData;
    this->m_size.allocated = this->m_size.used = newSize;
    this->m_size.nElements = nElements;
  }

  virtual void realloc(const uint32_t nElements) __OVERRIDES__(buffer_base<T>)
  {
    __DEV_CALLSTACK_FUNC__;
    const size_t newSize = sizeof(T) * nElements;
    __ASSERT__(this->m_size.allocated >= newSize && "cannot reallocate preallocated buffer with bigger size!");
    this->m_size.used = newSize;
    this->m_size.nElements = nElements;
  }

  virtual ~buffer_preallocated()
  {
    __DEV_CALLSTACK_FUNC__;
    //this buffer doesn't own the data -> do not clear it
  }

private:
  // not implemented
  buffer_preallocated(const buffer_preallocated&) = delete;
  buffer_preallocated& operator=(const buffer_preallocated&) = delete;
};

/// <summary>
/// Wrapper class for 'memaligned' allocations. Supports memory address and size alignments as template arguments.
/// </summary>
template <class T, size_t MemAlign, size_t SizeAlign>
class buffer_aligned_alloc : public buffer_base<T>
{
public:
  buffer_aligned_alloc(const uint32_t nElements) : buffer_base<T>()
  {
    __DEV_CALLSTACK_FUNC__;
    __STATIC_ASSERT__(MemAlign > 0 && SizeAlign > 0, "MemAlign & SizeAlign should be > 0");
    if (nElements > 0) {
      const size_t newSize = ((nElements * sizeof(T) - 1) / SizeAlign + 1) * SizeAlign;
      this->m_ptr = reinterpret_cast<T*>(__aligned_alloc__(MemAlign, newSize));
      this->m_size.allocated = this->m_size.used = newSize;
      this->m_size.nElements = nElements;
    }
  }

  virtual ~buffer_aligned_alloc()
  {
    __DEV_CALLSTACK_FUNC__;
    __aligned_free__(this->m_ptr);
  }

  virtual void realloc(const uint32_t nElements) __OVERRIDES__(buffer_base<T>)
  {
    __DEV_CALLSTACK_FUNC__;
    __STATIC_ASSERT__(MemAlign > 0 && SizeAlign > 0, "MemAlign & SizeAlign should be > 0");
    const size_t newSize = ((nElements * sizeof(T) - 1) / SizeAlign + 1) * SizeAlign;
    if (this->m_size.allocated < newSize) {
      __aligned_free__(this->m_ptr);
      this->m_ptr = reinterpret_cast<T*>(__aligned_alloc__(MemAlign, newSize));
      this->m_size.allocated = newSize;
    }
    this->m_size.nElements = nElements;
    this->m_size.used = newSize;
  }

private:
  // not implemented
  buffer_aligned_alloc(const buffer_aligned_alloc&) = delete;
  buffer_aligned_alloc& operator=(const buffer_aligned_alloc&) = delete;
};

/// <summary>
/// Some extension over buffer_aligned_alloc to behave like pointer.
/// This class is used for buffers that are the subjects of I/O operations that require alignment for raw I/O.
/// </summary>
template <class T, size_t MemAlign, size_t SizeAlign>
class aligned_ptr : public buffer_aligned_alloc<T, MemAlign, SizeAlign>
{
public:
  //c-tor
  aligned_ptr() : buffer_aligned_alloc<T, MemAlign, SizeAlign>(1)
  {
    __DEV_CALLSTACK_FUNC__;
    this->clear();
  }

  //d-ctor
  virtual ~aligned_ptr()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  //move-constructor (C++11)
  aligned_ptr(aligned_ptr&& rhs)
  {
    __DEV_CALLSTACK_FUNC__;
    if (this->m_ptr != rhs.m_ptr) {
      __aligned_free__(this->m_ptr);
    }
    this->m_size = rhs.m_size;
    this->m_ptr = rhs.m_ptr;
    rhs.size = 0;
    rhs.m_ptr = nullptr;
  }

  FORCE_INLINE T& operator* () { return *this->m_ptr; }
  FORCE_INLINE T* operator->() { return this->m_ptr;  }
  FORCE_INLINE T* operator& () { return this->m_ptr;  }

  FORCE_INLINE const T& operator* () const { return *this->m_ptr; }
  FORCE_INLINE const T* operator->() const { return this->m_ptr;  }
  FORCE_INLINE const T* operator& () const { return this->m_ptr;  }

  FORCE_INLINE void* load(const T* ptr) { return ::memcpy(this->m_ptr, ptr, sizeof(T)); }

private:
  // not implemented
  aligned_ptr(const aligned_ptr&) = delete;
  aligned_ptr& operator=(const aligned_ptr&) = delete;
};

template <class T>  using io_aligned_ptr = aligned_ptr<T, __IO_MEM_ALIGNMENT__, __IO_SIZE_ALIGNMENT__>;
template <class T>  using buffer_io_aligned_alloc = buffer_aligned_alloc<T, __IO_MEM_ALIGNMENT__, __IO_SIZE_ALIGNMENT__>;

#endif //buffers_h__
