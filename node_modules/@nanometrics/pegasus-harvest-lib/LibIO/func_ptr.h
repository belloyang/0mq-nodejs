#ifndef func_ptr_h__
#define func_ptr_h__

#include "../shared_defines.h"
#include <memory>

template <typename> class func_ptr; //no definition

template <typename TRet, typename ...Args>
class func_ptr<TRet(Args...)>
{
private:
  class ICallable 
  {
  public:
    virtual ~ICallable() = default;
    virtual TRet invoke(Args...) = 0;
  };

  //! callable static function
  class StaticCallable : public ICallable
  {
  public:
    typedef TRet(*StaticFunc)(Args...);
    StaticCallable(StaticFunc func)
    : m_func(func)
    {
      __DEV_CALLSTACK_FUNC__;
    }
    ~StaticCallable()
    {
      __DEV_CALLSTACK_FUNC__;
    }
    virtual TRet invoke(Args... args) __OVERRIDES__(ICallable)
    {
      __DEV_CALLSTACK_FUNC__;
      return m_func(args...);
    }
  private:
    StaticFunc m_func;
  };

  // callable member function
  template <class TClass>
  class MemFuncCallable : public ICallable
  {
  public:
    typedef TRet(TClass::*MemFunc)(Args...);
    MemFuncCallable(TClass* obj, MemFunc func)
      : m_obj(obj)
      , m_func(func)
    {
      __DEV_CALLSTACK_FUNC__;
    }
    ~MemFuncCallable()
    {
      __DEV_CALLSTACK_FUNC__;
    }
    virtual TRet invoke(Args... args) __OVERRIDES__(ICallable)
    {
      __DEV_CALLSTACK_FUNC__;
      return (m_obj->*m_func)(args...);
    }
  private:
    TClass* m_obj; //shallow copy is fine here. Class doesn't own the object
    MemFunc m_func;
  };

public:
  func_ptr(TRet(*func)(Args...))
  : m_callable(new StaticCallable(func))
  {
    __DEV_CALLSTACK_FUNC__;
  }

  template <typename TObj>
  func_ptr(TRet(TObj::*func)(Args...), TObj* obj)
    : m_callable(new MemFuncCallable<TObj>(obj, func))
  {
    __DEV_CALLSTACK_FUNC__;
  }

  func_ptr(const func_ptr& rhs)
    : m_callable(rhs.m_callable)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  func_ptr& operator=(const func_ptr& rhs)
  {
    __DEV_CALLSTACK_FUNC__;
    this->m_callable = rhs.m_callable;
    return (*this);
  }

  ~func_ptr()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  TRet operator()(Args... args) const 
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_callable != nullptr && "callable is nullptr!");
    return m_callable->invoke(args...);
  }

private:
  std::shared_ptr<ICallable> m_callable;
};

#endif //func_ptr_h__
