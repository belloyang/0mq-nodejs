#include "CRCHasher.h"

#include <algorithm>
#include <cinttypes>

CRCHasher::CRCHasher(const uint32_t chunkSize, const std::shared_ptr<ICRCDriver>& driver,
    const std::shared_ptr<ILogger>& logger)
:  IHasher("CRCHasher", logger)
,  m_driver(driver)
,  m_buffer(std::make_shared<buffer_io_aligned_alloc<char>>(chunkSize))
{
  __DEV_CALLSTACK_FUNC__;
}

CRCHasher::CRCHasher(const std::shared_ptr<ICRCDriver>& driver, const std::shared_ptr<buffer_base<char>>& buffer,
  const std::shared_ptr<ILogger>& logger)
  : IHasher("CRCHasher", logger)
  , m_driver(driver)
  , m_buffer(buffer)
{
  __DEV_CALLSTACK_FUNC__;
}

int CRCHasher::getHash32(const std::shared_ptr<IIOContext>& ioContext, Hash32_t& hash) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::calculate
  uint32_t iRet = 0;
  const uint64_t totalSize = ioContext->getSize();
  io_offset_t offset = 0;
  //tss_libio::if CRC can be calculated in 1 iteration -> do it
  if (totalSize <= m_buffer->size())
  {
    const size_t bytesRead = ioContext->readBlock(offset, (size_t)totalSize, m_buffer->ptr());
    if (bytesRead != totalSize)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_READING_FAILED,
        "Failed to read %lu bytes (offset=%" PRIu64 ", size=%" PRIu64,
        (unsigned long)totalSize,
        offset,
        totalSize);
      return iRet;
    }
    iRet = m_driver->calculate(m_buffer->ptr(), bytesRead);
  }
  else
  {
    //tss_libio::calculate CRC for the first chunk
    const size_t bytesRead = ioContext->readBlock(0, (size_t)m_buffer->size(), m_buffer->ptr());
    iRet = m_driver->calculate(m_buffer->ptr(), bytesRead);
    offset += bytesRead;
    //tss_libio::accumulate CRC
    while (offset < totalSize)
    {
      const size_t bytesToRead = (size_t)std::min<uint64_t>(m_buffer->size(), totalSize - offset);
      const size_t bytesReadLocal = ioContext->readBlock(offset, bytesToRead, m_buffer->ptr());
      if (bytesReadLocal != bytesToRead)
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_INTEGRITY_CHECK_FAILED,
          "Failed to read %lu bytes (offset=%" PRIu64 ", size=%" PRIu64 ")",
          (unsigned long)bytesReadLocal,
          offset,
          totalSize);
        break;
      }
      //tss_libio::accumulate result
      iRet = m_driver->accumulate(m_buffer->ptr(), bytesReadLocal);
      offset += bytesReadLocal;
    }
  }

  hash.value = m_driver->finalize(iRet);
  return HASH_SIZE_BYTES;
}
