#ifndef IHasher_h__
#define IHasher_h__

#include "../libio_defines.h"

#include "../Logger/ILogger.h"
#include "../IOContext/IIOContext.h"

#include <cstddef>
#include <string>
#include <memory>

/// <summary>
/// Basic interface for Hasher abstraction, assuming 32 bit hash value
/// </summary>
class IHasher
{
protected:
  /**
   * Protected IHasher constructor.
   * @param name    hasher's (hashing algorithm) name
   * @param logger  logger instance
   */
  IHasher(const std::string& name, const std::shared_ptr<ILogger>& logger);
  
public:
  enum 
  {
    HASH_SIZE_BYTES = sizeof(Hash32_t)
  };

  /**
   * IHasher destructor.
   */
  virtual ~IHasher() = default;

  /**
   * Hasher name getter
   * @return  hasher name
   */
  FORCE_INLINE const std::string& getName() const { return m_name; }

  /**
   * Calculates hash value for I/O context
   * @param ioContext    I/O context instance to calculate hash value for
   * @param hash         reference to hash value to compute from ioContext.
   * @return        size of calculated hash in bytes. 0 - failure, HASH_SIZE_BYTES - success
   */
  virtual int getHash32(const std::shared_ptr<IIOContext>& ioContext, Hash32_t& hash) const = 0;

  /**
   * Checks I/O context integrity
   * @param ioContext    I/O context instance to calculate hash value for
   * @param hashExpect   expected hash value
   * @return        Returns if actual I/O context hash matches expected hash (both hash size and hash value match)
   */
  virtual bool checkIntegrity(const std::shared_ptr<IIOContext>& ioContext, Hash32_t hashExpect) const;

protected:
  //! Hasher name
  const std::string m_name;
  //! Logger instance
  std::shared_ptr<ILogger> m_logger;
};

#endif //IHasher_h__
