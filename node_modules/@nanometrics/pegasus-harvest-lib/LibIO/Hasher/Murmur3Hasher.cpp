#include "Murmur3Hasher.h"

#include <algorithm> // std::min
#include <cinttypes>

FORCE_INLINE uint32_t rotl32 ( uint32_t x, uint8_t r )
{
  return (x << r) | (x >> (32u - r));
}

// Finalization mix - force all bits of a hash block to avalanche
FORCE_INLINE uint32_t fmix32(uint32_t h)
{
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;
  return h;
}

/*static*/ Hash32_t Murmur3Hasher::x86_32(const void* pData, const uint32_t len, const uint32_t seed)
{
  const uint8_t* data = reinterpret_cast<const uint8_t*>(pData);
  const int nblocks = len >> 2;
  uint32_t h1 = seed;
  const uint32_t c1 = 0xcc9e2d51;
  const uint32_t c2 = 0x1b873593;

  //----------
  // body (read 4 bytes long blocks)
  const uint32_t* blocks = reinterpret_cast<const uint32_t*>(data + (nblocks << 2)); //data + nblocks * 4
  for (int i = -nblocks; i; i++)
  {
    uint32_t k1 = blocks[i];
    k1 *= c1;
    k1 = rotl32(k1, 15);
    k1 *= c2;
    h1 ^= k1;
    h1 = rotl32(h1,13);
    h1 = h1 * 5 + 0xe6546b64;
  }

  //----------
  // read remaining tail (<= 3 bytes)
  const uint8_t* tail = reinterpret_cast<const uint8_t*>(data + (nblocks << 2)); //data + nblocks * 4
  uint32_t k1 = 0;
  switch(len & 3)
  {
  case 3: k1 ^= tail[2] << 16;
  // fall through
  // no break
  case 2: k1 ^= tail[1] << 8;
  // fall through
  // no break
  case 1: k1 ^= tail[0]; k1 *= c1; k1 = rotl32(k1, 15); k1 *= c2; h1 ^= k1;
  };

  //----------
  // finalization
  h1 ^= len;
  h1 = fmix32(h1);
  Hash32_t ret = {0};
  ret.value = h1;
  return ret;
}

void Murmur3Hasher::x86_32(const std::shared_ptr<IIOContext>& ioContext, uint32_t& out) const
{
  __DEV_CALLSTACK_FUNC__;
  //const uint8_t * data = (const uint8_t*)key;
  const uint64_t len = ioContext->getSize();

  uint32_t h1 = m_seed;
  const uint32_t c1 = 0xcc9e2d51;
  const uint32_t c2 = 0x1b873593;

  // body
  //const size_t offset = nBlocks << 2; ///nBlocks * 4
  //const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);
  __ATTR_IO__ uint32_t kVal = 0; //getblock32(blocks, i);
  io_offset_t offset = 0;
  while (offset < len)
  {
    const size_t bytesToRead = (size_t)std::min<uint64_t>(m_buffer->size(), len - offset);
    const size_t bytesRead = ioContext->readBlock(offset, bytesToRead, m_buffer->ptr());
    if (bytesRead != bytesToRead)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eLibIOErrorCode::LIBIO_ERROR_IO_READING_FAILED,
        "Failed to read %lu bytes at %" PRIu64 " (context size=%" PRIu64 "))",
        (unsigned long)bytesToRead,
        offset,
        len);
      break;
    }
    const size_t nBlocks = bytesRead >> 2; //(bytes read / 4)
    uint32_t* pData = m_buffer->ptr<uint32_t>();
    for (size_t i = 0; i < nBlocks; i++)
    {
      kVal = pData[i];
      kVal *= c1;
      kVal = rotl32(kVal, 15);
      kVal *= c2;

      h1 ^= kVal;
      h1 = rotl32(h1, 13);
      h1 = h1 * 5 + 0xe6546b64;
    }

    // tail
    //const uint8_t * tail = (const uint8_t*)(data + nblocks*4);
    const uint8_t* tail = reinterpret_cast<uint8_t*>(m_buffer->ptr()) + (nBlocks << 2);
    uint32_t k1 = 0;
    switch (bytesRead & 3)
    {
      case 3: k1 ^= tail[2] << 16;
      // fall through
      // no break
      case 2: k1 ^= tail[1] << 8;
      // fall through
      // no break
      case 1: k1 ^= tail[0];
      // fall through
      // no break
      k1 *= c1; k1 = rotl32(k1,15); k1 *= c2; h1 ^= k1;
    }
    offset += bytesRead;
  }

  // finalization
  h1 ^= len;
  h1 = fmix32(h1);

  out = h1;
}

Murmur3Hasher::Murmur3Hasher(const size_t chunkSize, const uint32_t seed, const std::shared_ptr<ILogger>& logger)
:  IHasher("Murmur3", logger)
,  m_seed(seed)
,  m_buffer(std::make_shared<buffer_io_aligned_alloc<char>>(chunkSize))
{
  __DEV_CALLSTACK_FUNC__;
  // check chunk size. It should be divisible by 4 to read blocks (4 bytes long) and tail properly
  __ASSERT__(chunkSize % 4 == 0 && "chunk size should be divisible by 4");
}

Murmur3Hasher::Murmur3Hasher(const size_t chunkSize, const std::shared_ptr<ILogger>& logger)
  : IHasher("Murmur3", logger)
  , m_seed(LIBIO_MURMUR3_SEED_DEFAULT)
  , m_buffer(std::make_shared<buffer_io_aligned_alloc<char>>(chunkSize))
{
  __DEV_CALLSTACK_FUNC__;
}

Murmur3Hasher::Murmur3Hasher(const std::shared_ptr<buffer_base<char>>& buffer, const std::shared_ptr<ILogger>& logger)
  : IHasher("Murmur3", logger)
  , m_seed(LIBIO_MURMUR3_SEED_DEFAULT)
  , m_buffer(buffer)
{
  __DEV_CALLSTACK_FUNC__;
}

int Murmur3Hasher::getHash32(const std::shared_ptr<IIOContext>& ioContext, Hash32_t& hash) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_libio::calculate
  this->x86_32(ioContext, hash.value);
  return HASH_SIZE_BYTES;
}
