#ifndef ring_buffer_h__
#define ring_buffer_h__

/**
 * This file declares the following template classes:
 *   ring_buffer:       Ring buffer in the style of STL
 *   ring_buffer_basic: Reduced functionality ring buffer, possibly suitable
 *                      for performance-demanding applications
 */

#include "libio_defines.h"
#include "buffers.h"

#include <memory>

/**
 * This template class name follows C++ STL naming style just to make it feel
 * like STL containers extension that provides ring-buffered container with
 * static length.
 */
template <class T>
class ring_buffer
{
public:
  /**
   * ring_buffer c-tor
   * @param buffer  underlying buffer to be used by this ring_buffer proxy
   */
  ring_buffer(const std::shared_ptr<buffer_base<T>>& buffer) :
    m_buffer(buffer),
	m_capacity(buffer->count()),
	m_size(0u),
    m_head(0u)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(buffer->count() > 0 && "Zero-sized buffer cannot be used to store data");
  }

  /**
   * ring_buffer destructor
   */
  ~ring_buffer()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  FORCE_INLINE uint32_t size() const { return m_size; }
  FORCE_INLINE bool empty() const { return (m_size == 0u); }
  FORCE_INLINE bool full() const { return (m_size == m_capacity); }

  void clear()
  {
	__DEV_CALLSTACK_FUNC__;
	m_head = m_size = 0u;
  }

  /**
   * Accesses the element by index relative to head
   * @param index   element index (relative to the head)
   * @return  element (non-modifiable)
   */
  FORCE_INLINE const T& operator[](uint32_t index) const
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(index < m_size && "index out of bounds");
    return m_buffer->at((m_head + index) % m_capacity);
  }
  /**
   * Accesses the element by index relative to head
   * @param index   element index (relative to the head)
   * @return  element (modifiable)
   */
  FORCE_INLINE T& operator[](uint32_t index)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(index < m_size && "index out of bounds");
    return m_buffer->at((m_head + index) % m_capacity);
  }

  /**
   * Pushes value to the back of the buffer (tail) and adjusts tail respectively
   * @param val value to push
   */
  void push_back(const T& val)
  {
    __DEV_CALLSTACK_FUNC__;
    const uint32_t tail = (m_head + m_size) % m_capacity;
    m_buffer->at(tail) = val;
    if (m_size < m_capacity)
    {
      m_size++;
    }
    else // advance the head as the current head was overwritten by the new tail due to wrap-around
    {
      m_head = (m_head + 1U) % m_capacity;
    }
  }

private:
  const std::shared_ptr<buffer_base<T>> m_buffer;
  const uint32_t m_capacity;
  uint32_t m_size;
  uint32_t m_head;

  // not implemented
  ring_buffer(const ring_buffer&) = delete;
  ring_buffer& operator=(const ring_buffer&) = delete;
};

/**
 * An alternate template class providing reduced functionality and power-of-2
 * indexing. This may be preferred for performance reasons.
 */
template<class T, uint32_t BIT_DEPTH>
class ring_buffer_basic
{
public:
  enum : uint32_t
  {
    RING_CAPACITY = (1U << BIT_DEPTH),
    RING_MASK     = (RING_CAPACITY - 1U),
  };

  /**
   * ring_buffer_basic constructor
   */
  ring_buffer_basic() :
    m_size(0U),
    m_head(0U),
    m_tail((m_head - 1U) & RING_MASK)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  /**
   * ring_buffer_basic destructor
   */
  ~ring_buffer_basic()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  /**
   * Check if ring buffer is empty
   */
  FORCE_INLINE bool empty() const
  {
    __DEV_CALLSTACK_FUNC__;
    return (m_size == 0U);
  }

  /**
   * Push one element to back of ring buffer
   * @param element   element to be pushed
   */
  FORCE_INLINE void push_back(const T& element)
  {
    __DEV_CALLSTACK_FUNC__;
    m_tail = (m_tail + 1U) & RING_MASK;
    m_buffer[m_tail] = element;
    if (m_size < RING_CAPACITY)
    {
      m_size++;
    }
    else // advance the head as the current head was overwritten by the new tail due to wrap-around
    {
      m_head = (m_head + 1U) & RING_MASK;
    }
  }

  /**
   * Pop (and discard) one element from front of ring buffer
   */
  FORCE_INLINE void pop_front()
  {
    __DEV_CALLSTACK_FUNC__;
    if (m_size > 0U)
    {
      m_head = (m_head + 1U) & RING_MASK;
      m_size--;
    }
  }

  /**
   * Const access to element at front of ring buffer
   * @return  element (non-modifiable)
   */
  FORCE_INLINE const T& front() const
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_size > 0 && "ring buffer is empty");
    return m_buffer[m_head];
  }

  /**
   * Non-const access to element at front of ring buffer
   * @return  element (modifiable)
   */
  FORCE_INLINE T& front()
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(m_size > 0 && "ring buffer is empty");
    return m_buffer[m_head];
  }

private:
  T m_buffer[RING_CAPACITY];
  uint32_t m_size;
  uint32_t m_head;
  uint32_t m_tail;
};

#endif //ring_buffer_h__
