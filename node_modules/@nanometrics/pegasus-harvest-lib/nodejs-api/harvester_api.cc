#include "harvester_api.h"
#include "nodejs_utils.h"

#include <Logger/loggers.h>
#include <Hasher/hashers.h>

#include <Operations/operations.h>
#include <Utils/json_utils.h>
#include <Client/PlatformBasedClient.h>
#include <PlatformUtils/PlatformUtils.h>

#include "src/TasksManager.h"
#include "src/AsyncTask_Format.h"
#include "src/AsyncTask_HarvestData.h"
#include "src/AsyncTask_HarvestSOH.h"
#include "src/AsyncTask_HarvestTimingSOH.h"
#include "src/AsyncTask_HarvestLogs.h"
#include "src/AsyncTask_LoadHistory.h"
#include "src/AsyncTask_FlushHistory.h"
#include "src/AsyncTask_ListDevices.h"
#include "src/AsyncTask_GetVolumeInfo.h"
#include "src/AsyncTask_GetDigitizerInfo.h"
#include "src/AsyncTask_ReadVolume.h"

#include <algorithm>
#include <stdexcept>

// create top-level logger (severe logs only by default)
static const std::shared_ptr<ILogger> s_logger = std::make_shared<ConsoleLogger>(1024, ILogger::eLogScope::LOGS_SEVERE);
static TasksManager TASKS_MANAGER(s_logger);

static struct
{
  std::string name = "UNKNOWN"; //client name
} s_clientInfo;

EXPORT_FUNC void reset()
{
  __DEV_CALLSTACK_FUNC__;
  TASKS_MANAGER.reset();
}

EXPORT_FUNC void set_client_info(const char* name)
{
  __DEV_CALLSTACK_FUNC__;
  if (name != nullptr)
  {
    const size_t maxNameLength = sizeof(MsgHarvestLog::Header::sPlatformDesc_t::harvester);
    const size_t nameLength = ::strlen(name);
    if (nameLength > maxNameLength) {
      s_logger->warning(__THIS_FUNC__, "Client name is too long. Will be truncated to %u symbols",
        (uint32_t)maxNameLength);
    }
    s_clientInfo.name = std::string(name, std::min<size_t>(nameLength, maxNameLength));
  }
  else
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY,
      eHarvAPIErrorCode::HARVAPI_ERROR_INVALID_ARGUMENT,
      "Client name is null!");
  }
}

EXPORT_FUNC void set_logs_mask(int mask) {
  __DEV_CALLSTACK_FUNC__;
  const uint8_t _mask = static_cast<uint8_t>(mask);
  s_logger->setMask(_mask);
  PlatformUtils::getInstance()->getLogger()->setMask(_mask);
}

EXPORT_FUNC uint32_t list()
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_ListDevices>(std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
    if (executionId == OP_INVALID_EXECUTION_ID)
      s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
        "list() failed to start");
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t format(const char* libPath, const char* configPath)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_Format>(libPath, (configPath != nullptr) ? std::string(configPath) : "", 
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
    if (executionId == OP_INVALID_EXECUTION_ID)
      s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
        "list() failed to start");
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}


EXPORT_FUNC uint32_t get_digitizer_info(const char* path)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_GetDigitizerInfo>(path,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
    if (executionId == OP_INVALID_EXECUTION_ID)
      s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
        "get_digitizer_info(%s) failed to start", path);
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t harvest_data(const char* libPath, const char* paramsJSON, const float updateStep)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_HarvestData>(libPath, std::string(paramsJSON), updateStep,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger,
      std::make_shared<PlatformBasedClient>(s_clientInfo.name, s_logger)
    ));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t harvest_soh(const char* libPath, const char* paramsJSON, const uint32_t channelsMask, const float updateStep)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try 
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_HarvestSOH>(libPath, std::string(paramsJSON), channelsMask, updateStep,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger,
      std::make_shared<PlatformBasedClient>(s_clientInfo.name, s_logger)));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t harvest_timing_soh(const char* libPath, const char* paramsJSON, const float updateStep)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_HarvestTimingSOH>(libPath, std::string(paramsJSON), updateStep,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger,
      std::make_shared<PlatformBasedClient>(s_clientInfo.name, s_logger)));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t harvest_logs(const char* libPath, const char* paramsJSON, const float updateStep)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_HarvestLogs>(libPath, std::string(paramsJSON), updateStep, 
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger,
      std::make_shared<PlatformBasedClient>(s_clientInfo.name, s_logger)));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t load_harvesting_history(const char* libPath)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_LoadHistory>(libPath, 
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t flush_harvesting_history(const char* libPath)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_FlushHistory>(libPath,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t get_volume_info(const char* libPath, const uint32_t volumeId)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_GetVolumeInfo>(libPath, volumeId,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC uint32_t read_volume(const char* libPath, const uint32_t volumeId)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t executionId = OP_INVALID_EXECUTION_ID;
  try
  {
    executionId = TASKS_MANAGER.run(std::make_shared<AsyncTask_ReadVolume>(libPath, volumeId,
      std::make_shared<Murmur3Hasher>(__IO_SIZE_ALIGNMENT__, s_logger), s_logger));
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return executionId;
}

EXPORT_FUNC const char* get_op_responses(const uint32_t executionId, const uint32_t nResponsesMax)
{
  __DEV_CALLSTACK_FUNC__;
  try
  {
    rapidjson::MemoryPoolAllocator<> allocator;
    //tss_harv::created output JSON object
    rapidjson::Value outputJSON(rapidjson::Type::kObjectType);
    outputJSON.AddMember("operation", "get-op-responses", allocator);
    //tss_harv::create responses array object
    rapidjson::Value responsesArrJSON(rapidjson::Type::kArrayType);
    //tss_harv::check If the task is still running and fetch it's responses
    const std::shared_ptr<IAsyncTask> task = TASKS_MANAGER.getTask(executionId);
    //tss_harv::if task not found -> it's either not started or completed -> return null
    if (task == nullptr)
      return nullptr;

    //load responses
    IAsyncTask::ResponsesArray responses;
    const uint32_t nResponses = task->loadResponses(responses);
    if (nResponses > 0)
    {
      //tss_harv::calculate amount of responses to load
      const uint32_t nResponsesToLoad = (nResponsesMax == 0) ? nResponses : std::min<uint32_t>(nResponses, nResponsesMax);
      for (uint32_t i = nResponses - nResponsesToLoad; i < nResponses; i++)
      {
        const std::string& responseString = responses.at(i);
        //tss_harv::add response JSON to array
        responsesArrJSON.PushBack(json_utils::str(responseString, allocator), allocator);
      }
    }
    //tss_harv::added responses array to output object
    outputJSON.AddMember("responses", responsesArrJSON, allocator);

    //tss_harv::static var to keep the result (this result is exposed outside but NodeJS doesn't allow to destroy underlying C-string -> keep this buffer static)
    static std::string ret = "";
    ret = json_utils::to_string(outputJSON);

    //tss_harv::check if the task is not running anymore -> delete it
    if (!task->isRunning())
    {
      TASKS_MANAGER.deleteTask(executionId);
    }

    return ret.c_str();
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
  return nullptr;
}

EXPORT_FUNC bool stop_operation(const uint32_t executionId)
{
  __DEV_CALLSTACK_FUNC__;
  try
  {
    const std::shared_ptr<IAsyncTask> task = TASKS_MANAGER.getTask(executionId);
    if (task != nullptr)
      return task->stop();
  }
  catch (const std::exception& e)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    s_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }

  return false;
}
