#include "AsyncTask_GetDigitizerInfo.h"

#include "JSONLogger.h"
#include <Utils/json_utils.h>
#include "../nodejs_utils.h"

class GetDigitizerInfo_Delegate : public Operation_GetDigitizerInfo::IDelegate
{
public:
  GetDigitizerInfo_Delegate(IAsyncTask* pTask)
    : m_pTask(pTask)
    , m_psfInfo(rapidjson::kObjectType)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
  }
  
  virtual ~GetDigitizerInfo_Delegate() = default;

  virtual void onPSFInfoLoaded(IOperation* pOperation, const sPSFLibraryHeader_t& header, const std::vector<sVolumeInfo>& volumes) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_psfInfo.AddMember("creation_time", nodejs_utils::timestamp_to_nodejstime(header.creationTime), m_allocator);
    m_psfInfo.AddMember("version", header.psfVersion, m_allocator);
    rapidjson::Value volumesJSON(rapidjson::kArrayType);
    for (auto& volume : volumes)
    {
      rapidjson::Value volumeJSON(rapidjson::kObjectType);
      volumeJSON.AddMember("id", volume.uniqueId, m_allocator);
      volumeJSON.AddMember("label", json_utils::str_s(volume.label, NUM_ELEMENTS(volume.label), m_allocator), m_allocator);
      volumesJSON.PushBack(volumeJSON, m_allocator);
    }
    m_psfInfo.AddMember("volumes", volumesJSON, m_allocator);
  }

  virtual void onInfoLoaded(IOperation* /*pOperation*/, const MsgDigitizerStart* pStart) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const MsgDigitizerStart::Header* const pHeader = pStart->getHeader();
    //tss_nodejsapi::build data JSON object
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("serial", json_utils::str_s(pHeader->serial, NUM_ELEMENTS(pHeader->serial), m_allocator), m_allocator);
      dataObj.AddMember("firmware", json_utils::str_s(pHeader->firmware, NUM_ELEMENTS(pHeader->firmware), m_allocator), m_allocator);
      dataObj.AddMember("bin", json_utils::str_s(pHeader->bin, NUM_ELEMENTS(pHeader->bin), m_allocator), m_allocator);
      dataObj.AddMember("network", json_utils::str_s(pHeader->network, NUM_ELEMENTS(pHeader->network), m_allocator), m_allocator);
      dataObj.AddMember("station", json_utils::str_s(pHeader->station, NUM_ELEMENTS(pHeader->station), m_allocator), m_allocator);
      //adding channels info
      {
        rapidjson::Value channelsArr(rapidjson::Type::kArrayType);
        for (uint32_t i = 0; i < pHeader->n_channels; ++i)
        {
          const MsgDigitizerStart::Header::sChannel& channel = pHeader->channels[i];
          rapidjson::Value channelObj(rapidjson::Type::kObjectType);
          channelObj.AddMember("name", json_utils::str_s(channel.name, NUM_ELEMENTS(channel.name), m_allocator), m_allocator);
          channelObj.AddMember("location", json_utils::str_s(channel.location, NUM_ELEMENTS(channel.location), m_allocator), m_allocator);
          channelsArr.PushBack(channelObj, m_allocator);
        }
        dataObj.AddMember("channels", channelsArr, m_allocator);
      }
    }
    // append PSF info
    dataObj.AddMember("psf", m_psfInfo, m_allocator);
    //tss_harvnodejs::push response
    m_pTask->pushResponseData(dataObj);
  }
  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus status) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_pTask->pushCompletionData(status);
  }

private:
  IAsyncTask* m_pTask;
  rapidjson::MemoryPoolAllocator<> m_allocator;
  rapidjson::Value m_psfInfo;
};

AsyncTask_GetDigitizerInfo::AsyncTask_GetDigitizerInfo(const std::string& libPath,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("get_digitizer_info", hasher, std::make_shared<JSONLogger>(this, logger))
, m_libPath(libPath)
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_GetDigitizerInfo::_runImpl(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  m_operation = std::make_shared<Operation_GetDigitizerInfo>(m_libPath, std::make_shared<GetDigitizerInfo_Delegate>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_GetDigitizerInfo::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
    return m_operation->stop();
  return false;
}
