#include "ProgressDelegate_Harvest.h"

#include <cmath>

ProgressDelegate_Harvest::ProgressDelegate_Harvest(IAsyncTask* pTask, const std::shared_ptr<IContext>& context,
  const float step)
: IProgressDelegate()
, m_pTask(pTask)
, m_context(context)
, m_notificationStep(step)
, m_lastNotifiedValue(0.f)
, m_nReportsSent(0u)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
}

void ProgressDelegate_Harvest::onProgress(const IOperation* pOperation, const sHarvestProgress& progressData)
{
  __DEV_CALLSTACK_FUNC__;
  const float newProgress = progressData.progress;
  //tss_harv::check if notification step exceeds or completed (all elements processed)
  if ((m_nReportsSent == 0u) || (::fabs(newProgress - m_lastNotifiedValue) >= m_notificationStep) ||
    (progressData.nElementsProcessed == progressData.nElementsTotal))
  {
    m_nReportsSent++;
    m_lastNotifiedValue = newProgress;
    //tss_harv::build JSON response  
    rapidjson::Value responseObj(rapidjson::Type::kObjectType);
    responseObj.AddMember("operation", json_utils::str_ref(pOperation->getName()), m_allocator);
    responseObj.AddMember("type", "response", m_allocator);
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("progress", progressData.progress, m_allocator);
      dataObj.AddMember("num_files", progressData.nFilesGenerated, m_allocator);
      dataObj.AddMember("duration_ms", progressData.durationMs, m_allocator);
      dataObj.AddMember("num_elements_total", progressData.nElementsTotal, m_allocator);
      dataObj.AddMember("num_elements_processed", progressData.nElementsProcessed, m_allocator);
      dataObj.AddMember("num_bytes_processed", progressData.nBytesProcessed, m_allocator);
      dataObj.AddMember("speed", progressData.speedMiBpSec, m_allocator);
    }
    responseObj.AddMember("data", dataObj, m_allocator);
    //tss_harvnodejs::push response
    m_pTask->setProgressResponse(responseObj);
  }
}

void ProgressDelegate_Harvest::onOpReport(const IOperation* /*pOperation*/, const sHarvestOpReport& reportData, 
  const MsgHarvestLog::Header& harvestHeader)
{
  __DEV_CALLSTACK_FUNC__;
  // push history to execution context if any data harvested
  if (harvestHeader.timespan_actual.time_lower != harvestHeader.timespan_actual.time_upper)
  {
    m_context->pushHistory(harvestHeader);
  }
  // setn completion response
  m_pTask->pushCompletionData(reportData.status);
}
