#include "JSONLogger.h"

JSONLogger::JSONLogger(IAsyncTask* task, const std::shared_ptr<ILogger>& fallbackLogger)
  : ILogger()
  , m_task(task)
  , m_fallbackLogger(fallbackLogger)
  , m_buffer(new buffer_malloc<char>(512))
{
  __DEV_CALLSTACK_FUNC__;
}

void JSONLogger::_logErrorImpl(const char* scope, const uint32_t category, const uint32_t errorCode, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  #ifdef __GNUC__
  {
    // Clone arguments for reuse by different call to vsprintf.
    va_list args_copy;
    va_copy(args_copy, args);
    ::vsnprintf(m_buffer->ptr<char>(), m_buffer->size(), format, args_copy);
    va_end(args_copy);
  }
  #else 
    ::vsnprintf(m_buffer->ptr<char>(), m_buffer->size(), format, args);
  #endif
  
  rapidjson::Value dataObj(rapidjson::kObjectType);
  {
    dataObj.AddMember("category", category, m_allocator);
    dataObj.AddMember("error_code", errorCode, m_allocator);
    dataObj.AddMember("scope", json_utils::str_ref(scope), m_allocator);
    dataObj.AddMember("description", json_utils::str_ref(m_buffer->ptr<char>()), m_allocator);
  }
  //tss_harvlib::push error JSON to task's responses queue
  m_task->pushErrorData(dataObj);
  // replicate error in fallback logger
  m_fallbackLogger->error_v(scope, category, errorCode, format, args);
}

void JSONLogger::_logWarningImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  // warnings do not go as JSON response
  m_fallbackLogger->warning_v(scope, format, args);
}

void JSONLogger::_logInfoImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  // info logs do not go to JSON response
  m_fallbackLogger->info_v(scope, format, args);
}

void JSONLogger::_logDebugImpl(const char* scope, const char* format, va_list args)
{
  __DEV_CALLSTACK_FUNC__;
  // debug logs do not go to JSON response
  m_fallbackLogger->debug_v(scope, format, args);
}

void JSONLogger::_flushImpl()
{
  __DEV_CALLSTACK_FUNC__;
  m_fallbackLogger->flush();
}
