#include "TasksManager.h"

#include <DataTypes/HarvestLog/MsgHarvestLog.h>

#include <mutex>

class Context : public IContext
{
public:
  Context()
  {
    __DEV_CALLSTACK_FUNC__;
    m_history.reserve(4); // serverve space for 4 history records (logs, seismic, soh, timing soh)
  };
  virtual ~Context() {};

  virtual uint32_t fetchHistory(std::vector<MsgHarvestLog::Header>& output) __OVERRIDES__(IContext)
  {
    __DEV_CALLSTACK_FUNC__;
    std::lock_guard<std::mutex> lock(m_historyMutex);
    // copy to output and erase. Do not use move, swap, etc. to preserve reserved capacity
    output = m_history;
    m_history.clear();
    return static_cast<uint32_t>(output.size());
  }

  virtual void pushHistory(const MsgHarvestLog::Header& history) __OVERRIDES__(IContext)
  {
    __DEV_CALLSTACK_FUNC__;
    std::lock_guard<std::mutex> lock(m_historyMutex);
    m_history.emplace_back(history);
  }

private:
  std::mutex m_historyMutex;
  std::vector<MsgHarvestLog::Header> m_history;
};

TasksManager::TasksManager(const std::shared_ptr<ILogger>& logger)
  : m_logger(logger)
  , m_context(std::make_shared<Context>())
  , m_nTasks(0)
{
  __DEV_CALLSTACK_FUNC__;
}

void TasksManager::reset()
{
  __DEV_CALLSTACK_FUNC__;
  // recreate context to lose all the history, etc.
  m_context = std::make_shared<Context>();
}

uint32_t TasksManager::run(const std::shared_ptr<IAsyncTask>& task)
{
  __DEV_CALLSTACK_FUNC__;
  if (task != nullptr)
  {
    //tss_harv::set task ID to differentiate it (task id = amount of successful commands run ever)
    uint32_t nextTaskId = m_nTasks + 1;
    task->setId(nextTaskId);
    //run operation
    task->run(m_context);
	// task started successfully, so remember it (exception safety)
    m_tasks.push_back(task);
    m_nTasks = nextTaskId;
    //tss_harv::return executed task ID
    return m_nTasks;
  }

  return OP_INVALID_EXECUTION_ID;
}

std::shared_ptr<IAsyncTask> TasksManager::getTask(const uint32_t exectuionId) const
{
  __DEV_CALLSTACK_FUNC__;
  for (TasksQueue::const_iterator taskIt = m_tasks.begin(); taskIt != m_tasks.end(); ++taskIt)
  {
    if ((*taskIt)->getId() == exectuionId)
      return (*taskIt);
  }

  return nullptr;
}

bool TasksManager::deleteTask(const uint32_t executionId)
{
  __DEV_CALLSTACK_FUNC__;
  for (TasksQueue::iterator it = m_tasks.begin(); it != m_tasks.end(); ++it)
  {
    if ((*it)->getId() == executionId)
    {
      m_tasks.erase(it);
      return true;
    }
  }

  return false;
}
