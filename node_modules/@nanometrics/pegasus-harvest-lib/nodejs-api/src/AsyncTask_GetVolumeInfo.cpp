#include "AsyncTask_GetVolumeInfo.h"
#include "../nodejs_utils.h"
#include "JSONLogger.h"
#include <Utils/json_utils.h>

class GetVolumeInfo_Delegate : public Operation_GetVolumeInfo::IDelegate
{
public:
  GetVolumeInfo_Delegate(IAsyncTask* pTask)
  : m_pTask(pTask)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
  }
  virtual ~GetVolumeInfo_Delegate() = default;

  virtual void onInfoLoaded(IOperation* /*pOperation*/, const sVolumeInfo& info) __OVERRIDES__(Operation_GetVolumeInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //tss_nodejsapi::build data JSON object
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("unique_id", info.uniqueId, m_allocator);
      dataObj.AddMember("label", json_utils::str_s(info.label, NUM_ELEMENTS(info.label), m_allocator), m_allocator);
      dataObj.AddMember("size_in_chapters", info.sizeInChapters, m_allocator);
      dataObj.AddMember("start_chapter", info.startChapter, m_allocator);
      dataObj.AddMember("time_valid", info.bTimeValid, m_allocator);
      if (info.bTimeValid)
      {
        dataObj.AddMember("time_lower", nodejs_utils::timestamp_to_nodejstime(info.lowerTime), m_allocator);
        dataObj.AddMember("time_upper", nodejs_utils::timestamp_to_nodejstime(info.upperTime), m_allocator);
      }
    }
    //tss_harvnodejs::push response
    m_pTask->pushResponseData(dataObj);
  }
  virtual void onSectionLoaded(IOperation* /*pOperation*/, const uint32_t /*sectionIndex*/, const PSFSection* /*pSection*/) __OVERRIDES__(Operation_GetVolumeInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //do nothing here. NodeJS API doesn't need sections' info for the moment
  }
  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus status) __OVERRIDES__(Operation_GetVolumeInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_pTask->pushCompletionData(status);
  }

private:
  IAsyncTask* m_pTask;
  rapidjson::MemoryPoolAllocator<> m_allocator;
};

AsyncTask_GetVolumeInfo::AsyncTask_GetVolumeInfo(const std::string& libPath, const uint32_t volumeId,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("get_volume_info", hasher, std::make_shared<JSONLogger>(this, logger))
, m_libPath(libPath)
, m_volumeId(volumeId)
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_GetVolumeInfo::_runImpl(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  m_operation = std::make_shared<Operation_GetVolumeInfo>(m_libPath, m_volumeId, 0/*no sections info needed*/,
    std::make_shared<GetVolumeInfo_Delegate>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_GetVolumeInfo::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
    return m_operation->stop();
  return false;
}
