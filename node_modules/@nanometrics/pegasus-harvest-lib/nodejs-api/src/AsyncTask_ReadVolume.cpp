#include "AsyncTask_ReadVolume.h"

#include "JSONLogger.h"
#include "JSONTransformer_NodeJS.h"
#include <Utils/JSONSerializer.h>

class ProcessorDelegate_JSON : public IProcessorDelegate
{
public:
  ProcessorDelegate_JSON(IAsyncTask* task)
  : m_pTask(task)
  , m_serializer(std::make_shared<JSONTransformer_NodeJS>())
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~ProcessorDelegate_JSON() = default;
  
private:
  virtual void onPSFRead(const PSFDataElement* dataElement) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    rapidjson::Value json = std::move(m_serializer.serialize(dataElement));
    m_pTask->pushResponseData(json);
  }

  virtual void onCompleted(const eOperationStatus status) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    // push completion response
    m_pTask->pushCompletionData(status);
  }

private:
  IAsyncTask* m_pTask;
  JSONSerializer m_serializer;
};

AsyncTask_ReadVolume::AsyncTask_ReadVolume(const std::string& libPath, const uint32_t volumeId,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("read_volume", hasher, std::make_shared<JSONLogger>(this, logger))
, m_libPath(libPath)
, m_volumeId(volumeId)
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_ReadVolume::_runImpl(const std::shared_ptr<IContext>& /*context*/)
{
  __DEV_CALLSTACK_FUNC__;
  m_operation = std::make_shared<Operation_ReadVolume>(m_libPath, m_volumeId, std::make_shared<ProcessorDelegate_JSON>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_ReadVolume::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
  {
    return m_operation->stop();
  }
  return false;
}
