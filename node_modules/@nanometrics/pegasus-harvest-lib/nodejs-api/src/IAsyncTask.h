#ifndef IAsyncTask_h__
#define IAsyncTask_h__

#include "../harvester_api_defines.h"

#include "IContext.h"

#include <Logger/ILogger.h>
#include <Hasher/IHasher.h>

#include <Utils/json_utils.h>
#include <Utils/harvester_utils.h>

#include <memory>
#include <vector>
#include <string>

#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>

class IAsyncTask
{
public:
  typedef std::vector< std::string > ResponsesArray;
  IAsyncTask(const std::string& name,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger);
  virtual ~IAsyncTask();

  void run(const std::shared_ptr<IContext>& context);
  bool stop();

  FORCE_INLINE const std::string& getName() const { return m_name; }

  FORCE_INLINE void setId(const uint32_t id) { m_executionId = id; }
  FORCE_INLINE uint32_t getId() const { return m_executionId; }
  FORCE_INLINE bool isRunning() const { return m_bIsRunning; }

  void pushCompletionData(const eOperationStatus status);
  void setProgressResponse(const rapidjson::Value& responseObj);
  void pushResponseData(rapidjson::Value& dataObj);
  void pushErrorData(rapidjson::Value& dataObj);

  uint32_t loadResponses(ResponsesArray& output);

protected:
  void _pushResponse(const rapidjson::Value& responseObj);
  //wait till the operation finishes
  void _wait();
  void _runThread(const std::shared_ptr<IContext>& context);
  void _finalizeThread();

private:
  virtual void _runImpl(const std::shared_ptr<IContext>& context) = 0;
  virtual bool _stopImpl() = 0;

protected:
  const std::string m_name;
  const std::shared_ptr<IHasher> m_hasher;
  const std::shared_ptr<ILogger> m_logger;
  uint32_t m_executionId; //operation execution ID
  rapidjson::MemoryPoolAllocator<> m_jsonAllocator;
  std::mutex m_mutex; //mutex
  ResponsesArray m_responses; //operation responses
  std::string m_latestProgressResponse;
  std::atomic<bool> m_bIsRunning; //operation running flag
  std::condition_variable m_opFinishedEvent; //operation finished event
};

#endif //IAsyncTask_h__
