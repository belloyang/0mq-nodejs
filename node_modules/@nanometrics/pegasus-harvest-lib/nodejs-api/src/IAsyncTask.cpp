#include "IAsyncTask.h"

#include <stdexcept>

IAsyncTask::IAsyncTask(const std::string& name,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: m_name(name)
, m_hasher(hasher)
, m_logger(logger)
, m_executionId(0)
, m_bIsRunning(false)
{
  __DEV_CALLSTACK_FUNC__;
}

IAsyncTask::~IAsyncTask()
{
  __DEV_CALLSTACK_FUNC__;
  this->_wait();
}

void IAsyncTask::run(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  m_bIsRunning = true;
  std::thread t(&IAsyncTask::_runThread, this, std::ref(context));
  t.detach();
}

void IAsyncTask::_runThread(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  try
  {
    //run specific operation flow
    this->_runImpl(context);
    //finalize thread
    this->_finalizeThread();
  }
  catch (const std::exception& e)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: '%s'", e.what());
  }
  catch (...)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_OPERATION_FAILED,
      "Exception caught: UNKNOWN");
  }
}

void IAsyncTask::_finalizeThread()
{
  __DEV_CALLSTACK_FUNC__;
  m_mutex.lock();
  m_bIsRunning = false;
  m_mutex.unlock();
  m_opFinishedEvent.notify_all();
}

bool IAsyncTask::stop()
{
  __DEV_CALLSTACK_FUNC__;
  return this->_stopImpl();
}

void IAsyncTask::pushCompletionData(const eOperationStatus status)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::MemoryPoolAllocator<> allocator;
  rapidjson::Value responseObj(rapidjson::Type::kObjectType);
  {
    responseObj.AddMember("operation", json_utils::str(m_name, allocator), allocator);
    responseObj.AddMember("type", "completion", allocator);
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("status", status, allocator);
    }
    responseObj.AddMember("data", dataObj, allocator);
  }
  //tss_harvnodejs::push response
  this->_pushResponse(responseObj);
}

void IAsyncTask::pushResponseData(rapidjson::Value& dataObj)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::MemoryPoolAllocator<> allocator;
  rapidjson::Value responseObj(rapidjson::Type::kObjectType);
  {
    responseObj.AddMember("operation", json_utils::str(m_name, allocator), allocator);
    responseObj.AddMember("type", "response", allocator);
    responseObj.AddMember("data", dataObj, allocator);
  }
  //tss_harvnodejs::push response
  this->_pushResponse(responseObj);
}

void IAsyncTask::pushErrorData(rapidjson::Value& dataObj)
{
  __DEV_CALLSTACK_FUNC__;
  rapidjson::MemoryPoolAllocator<> allocator;
  rapidjson::Value responseObj(rapidjson::kObjectType);
  {
    responseObj.AddMember("operation", json_utils::str(m_name, allocator), allocator);
    responseObj.AddMember("type", "error", allocator);
    responseObj.AddMember("data", dataObj, allocator);
  }
  //tss_harvnodejs::push response
  this->_pushResponse(responseObj);
}

void IAsyncTask::setProgressResponse(const rapidjson::Value& responseObj)
{
  __DEV_CALLSTACK_FUNC__;
  std::lock_guard<std::mutex> lock(m_mutex);
  m_latestProgressResponse = json_utils::to_string(responseObj);
}

void IAsyncTask::_pushResponse(const rapidjson::Value& responseObj)
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& responseString = json_utils::to_string(responseObj);
  std::lock_guard<std::mutex> lockGuard(m_mutex);
  m_responses.push_back(responseString);
}

uint32_t IAsyncTask::loadResponses(ResponsesArray& output)
{
  __DEV_CALLSTACK_FUNC__;
  std::lock_guard<std::mutex> lock(m_mutex);
  output.clear();
  std::swap(output, m_responses);
  if (!m_latestProgressResponse.empty())
  {
    output.insert(output.begin(), m_latestProgressResponse);
    m_latestProgressResponse.clear();
  }
  return static_cast<uint32_t>(output.size());
}

void IAsyncTask::_wait()
{
  __DEV_CALLSTACK_FUNC__;
  std::unique_lock<std::mutex> lock(m_mutex);
  while (m_bIsRunning)
  {
    m_opFinishedEvent.wait(lock);
  }
}
