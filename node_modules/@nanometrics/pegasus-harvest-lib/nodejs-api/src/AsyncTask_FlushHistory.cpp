#define _USE_MATH_DEFINES

#include "AsyncTask_FlushHistory.h"
#include "../nodejs_utils.h"
#include "JSONLogger.h"
#include <Utils/json_utils.h>

class FlushHistory_Delegate : public Operation_FlushHarvestingHistory::IDelegate
{
public:
  FlushHistory_Delegate(IAsyncTask* pTask)
  : m_pTask(pTask)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
  }
  virtual ~FlushHistory_Delegate() = default;

  virtual void onHistoryWritten(IOperation* pOperation, const MsgHarvestLog::Header& header) __OVERRIDES__(Operation_FlushHarvestingHistory::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //tss_nodejsapi::build data JSON object
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("start", nodejs_utils::timestamp_to_nodejstime(header.start), m_allocator);
      dataObj.AddMember("duration", header.duration, m_allocator); //duration is already in milliseconds
      dataObj.AddMember("length", header.length, m_allocator);
      dataObj.AddMember("volume_id", header.volume_id, m_allocator);
      dataObj.AddMember("lower", header.lower, m_allocator);
      dataObj.AddMember("upper", header.upper, m_allocator);
      rapidjson::Value timespanTarget(rapidjson::Type::kObjectType);
      {
        timespanTarget.AddMember("valid", header.timespan_target.valid, m_allocator);
        timespanTarget.AddMember("time_lower", nodejs_utils::timestamp_to_nodejstime(header.timespan_target.time_lower), m_allocator);
        timespanTarget.AddMember("time_upper", nodejs_utils::timestamp_to_nodejstime(header.timespan_target.time_upper), m_allocator);
      }
      dataObj.AddMember("timespan_target", timespanTarget, m_allocator);
      rapidjson::Value timespanActual(rapidjson::Type::kObjectType);
      {
        timespanActual.AddMember("valid", header.timespan_actual.valid, m_allocator);
        timespanActual.AddMember("time_lower", nodejs_utils::timestamp_to_nodejstime(header.timespan_actual.time_lower), m_allocator);
        timespanActual.AddMember("time_upper", nodejs_utils::timestamp_to_nodejstime(header.timespan_actual.time_upper), m_allocator);
      }
      dataObj.AddMember("timespan_actual", timespanActual, m_allocator);

      rapidjson::Value platformDesc(rapidjson::Type::kObjectType);
      {
        const MsgHarvestLog::Header::sPlatformDesc_t& desc = header.platform_desc;
        platformDesc.AddMember("harvester", json_utils::str_s(desc.harvester, NUM_ELEMENTS(desc.harvester), m_allocator), m_allocator);
        platformDesc.AddMember("os", json_utils::str_s(desc.os, NUM_ELEMENTS(desc.os), m_allocator), m_allocator);
        platformDesc.AddMember("kernel", json_utils::str_s(desc.kernel, NUM_ELEMENTS(desc.kernel), m_allocator), m_allocator);
        platformDesc.AddMember("platform", json_utils::str_s(desc.platform, NUM_ELEMENTS(desc.platform), m_allocator), m_allocator);
        platformDesc.AddMember("bios", json_utils::str_s(desc.bios, NUM_ELEMENTS(desc.bios), m_allocator), m_allocator);
        platformDesc.AddMember("cpu", json_utils::str_s(desc.cpu, NUM_ELEMENTS(desc.cpu), m_allocator), m_allocator);
        platformDesc.AddMember("ram", json_utils::str_s(desc.ram, NUM_ELEMENTS(desc.ram), m_allocator), m_allocator);
        platformDesc.AddMember("disk", json_utils::str_s(desc.disk, NUM_ELEMENTS(desc.disk), m_allocator), m_allocator);
      }
      dataObj.AddMember("platform_desc", platformDesc, m_allocator);

    }
    //tss_harvnodejs::push response
    m_pTask->pushResponseData(dataObj);
  }
  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus status) __OVERRIDES__(Operation_FlushHarvestingHistory::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_pTask->pushCompletionData(status);
  }

private:
  IAsyncTask* m_pTask;
  rapidjson::MemoryPoolAllocator<> m_allocator;
};

AsyncTask_FlushHistory::AsyncTask_FlushHistory(const std::string& libPath,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("flush_history", hasher, std::make_shared<JSONLogger>(this, logger))
, m_libPath(libPath)
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_FlushHistory::_runImpl(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  // load collected history from execution context
  std::vector<MsgHarvestLog::Header> history;
  context->fetchHistory(history);
  // create history flush operation
  m_operation = std::make_shared<Operation_FlushHarvestingHistory>(m_libPath, history, std::make_shared<FlushHistory_Delegate>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_FlushHistory::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
    return m_operation->stop();
  return false;
}
