#include "AsyncTask_LoadHistory.h"

#include "JSONLogger.h"
#include "JSONTransformer_NodeJS.h"
#include <Utils/JSONSerializer.h>

class LoadHistory_Delegate : public IProcessorDelegate
{
public:
  LoadHistory_Delegate(IAsyncTask* pTask)
  : m_pTask(pTask)
  , m_serializer(std::make_shared<JSONTransformer_NodeJS>())
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
  }
  virtual ~LoadHistory_Delegate() = default;

  virtual void onPSFRead(const PSFDataElement* dataElement) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    if (dataElement->isInstanceOf(PDB_eMessageType_t::MSG_HARVEST_LOG_V0))
    {
      rapidjson::Value dataObj = m_serializer.serialize(dataElement);
      m_pTask->pushResponseData(dataObj["message"]);
    }
  }

  virtual void onCompleted(const eOperationStatus status) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_pTask->pushCompletionData(status); 
  }

private:
  IAsyncTask* m_pTask;
  JSONSerializer m_serializer;
};

AsyncTask_LoadHistory::AsyncTask_LoadHistory(const std::string& libPath,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("load_history", hasher, std::make_shared<JSONLogger>(this, logger))
, m_libPath(libPath)
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_LoadHistory::_runImpl(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  // read HARVEST_LOG volume
  m_operation = std::make_shared<Operation_ReadVolume>(m_libPath, PDB_eVolumeID::VOLUME_HARVEST_LOG,
    std::make_shared<LoadHistory_Delegate>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_LoadHistory::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
    return m_operation->stop();
  return false;
}
