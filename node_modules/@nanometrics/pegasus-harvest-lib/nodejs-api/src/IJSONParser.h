#ifndef IJSONParser_h__
#define IJSONParser_h__

#include "../harvester_api_defines.h"

#include <Utils/json_utils.h>

#include <Logger/ILogger.h>

#include <string>
#include <map>
#include <memory>

template <class T> class IJSONParser
{
public:
  typedef bool(IJSONParser::*ParseFunctor)(const rapidjson::Value& value, T& output) const;
  #define PARSE_FUNCTOR(functor) reinterpret_cast<ParseFunctor>(&functor)
  
  IJSONParser(const std::shared_ptr<ILogger>& logger)
  : m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  
  virtual ~IJSONParser() = default;
  
  bool parse(const std::string& json, T& output) const
  {
    __DEV_CALLSTACK_FUNC__;
    m_logger->debug(__THIS_FUNC__, "Parsing '%s'", json.c_str());
    rapidjson::Document doc;
    doc.Parse<0>(json.c_str());
    if (doc.HasParseError())
    {
      this->m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_INVALID_ARGUMENT,
        "Failed to parse '%s' (error: %d)", json.c_str(), static_cast<int>(doc.GetParseError()));
      return false;
    }
    // parse each field
    for (auto memberIt = doc.MemberBegin(); memberIt != doc.MemberEnd(); ++memberIt)
    {
      const std::string fieldName = memberIt->name.GetString();
      const rapidjson::Value& fieldVal = memberIt->value;
      const bool bParsed = this->_parseField(fieldName, fieldVal, output);
      if (!bParsed)
      {
        this->m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvAPIErrorCode::HARVAPI_ERROR_INVALID_ARGUMENT,
          "Failed to parse field '%s'", fieldName.c_str());
        return false;
      }
    }
    return true;
  }

protected:
  void _registerFunctor(const std::string& name, const ParseFunctor functor)
  {
    __DEV_CALLSTACK_FUNC__;
    m_parseFunctors.insert(std::make_pair(name, functor));
  }

private:
  bool _parseField(const std::string& name, const rapidjson::Value& value, T& output) const
  {
    __DEV_CALLSTACK_FUNC__;
    const auto& functorIt = this->m_parseFunctors.find(name);
    __ASSERT__(functorIt != this->m_parseFunctors.end() && "parse functor not found!");
    if (functorIt != this->m_parseFunctors.end())
    {
      const ParseFunctor functor = functorIt->second;
      return (this->*functor)(value, output);
    }
    return false;
  }

protected:
  const std::shared_ptr<ILogger> m_logger;
  std::map<std::string, ParseFunctor> m_parseFunctors;
};

#endif //IJSONParser_h__
