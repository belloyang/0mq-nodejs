#include "AsyncTask_ListDevices.h"

#include <Logger/ChainedLogger.h>
#include "JSONLogger.h"
#include <Utils/json_utils.h>

class ListDevices_Delegate : public Operation_ListDevices::IDelegate
{
public:
  ListDevices_Delegate(IAsyncTask* pTask)
  : m_pTask(pTask)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(pTask != nullptr && "pTask cannot be nullptr here!");
  }
  virtual ~ListDevices_Delegate() = default;

  virtual void onDeviceFound(IOperation* /*pOperation*/, const sPSFDeviceInfo_t& device) __OVERRIDES__(Operation_ListDevices::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //tss_nodejsapi::build data JSON object
    rapidjson::Value dataObj(rapidjson::Type::kObjectType);
    {
      dataObj.AddMember("path", json_utils::str_s((const char*)device.deviceName, NUM_ELEMENTS(device.deviceName), m_allocator), m_allocator);
      dataObj.AddMember("system_path", json_utils::str_s((const char*)device.devicePath, NUM_ELEMENTS(device.devicePath), m_allocator), m_allocator);
    }
    //tss_harvnodejs::push response
    m_pTask->pushResponseData(dataObj);
  }
  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus status) __OVERRIDES__(Operation_ListDevices::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_pTask->pushCompletionData(status);
  }

private:
  IAsyncTask* m_pTask;
  rapidjson::MemoryPoolAllocator<> m_allocator;
};

AsyncTask_ListDevices::AsyncTask_ListDevices(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
: IAsyncTask("list_devices", hasher, std::make_shared<JSONLogger>(this, logger))
, m_operation(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
}

void AsyncTask_ListDevices::_runImpl(const std::shared_ptr<IContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  m_operation = std::make_shared<Operation_ListDevices>(std::make_shared<ListDevices_Delegate>(this));
  //tss_harv::execute operation
  m_operation->execute(m_hasher, m_logger);
  //tss_harv::destroy operation
  m_operation = nullptr;
}

bool AsyncTask_ListDevices::_stopImpl()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_operation != nullptr)
    return m_operation->stop();
  return false;
}
