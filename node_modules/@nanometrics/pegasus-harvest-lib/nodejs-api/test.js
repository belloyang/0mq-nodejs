"use strict";
exports.__esModule = true;
var harvester_api_1 = require("../harvester_api");
var models_1 = require("./models");
var path = require("path");
var OUTPUT_ROOT = "Output";
var report_status_map = {
    0: 'COMPLETED',
    1: 'ABORTED',
    2: 'FAILED'
};
function do_harvest_data(libPath) {
    var params = {
        range: {
            lower: {
                time_microsecs: 0,
                sequence_number: 0
            },
            upper: {
                time_microsecs: models_1.UpperLimit.timestamp,
                sequence_number: models_1.UpperLimit.sequence_number
            }
        },
        output_path: path.join(OUTPUT_ROOT, models_1.HarvestSubDirectory.seismicData),
        output_pattern: models_1.OutputPatterns.SDS,
        hours_per_file: 24
    };
    var opId = harvester_api_1.HarvesterAPIs.harvest_data(libPath, params, 0.05);
    console.log("'harvest_data' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'do_harvest_data' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function flush_history(libPath) {
    var opId = harvester_api_1.HarvesterAPIs.flush_harvesting_history(libPath);
    console.log("'flush_history' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'flush_history' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function do_harvest_soh(libPath) {
    var params = {
        range: {
            lower: {
                time_microsecs: 0
            },
            upper: {
                time_microsecs: models_1.UpperLimit.timestamp
            }
        },
        output_path: path.join(OUTPUT_ROOT, models_1.HarvestSubDirectory.soh),
        output_pattern: models_1.OutputPatterns.SDS,
        hours_per_file: 24
    };
    var opId = harvester_api_1.HarvesterAPIs.harvest_soh(libPath, params, models_1.PDBSohChannelID.ALL_CHANNELS, 0.05);
    console.log("'harvest_soh' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'do_harvest_soh' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function do_format(libPath) {
    var opId = harvester_api_1.HarvesterAPIs.format(libPath, "");
    console.log("'format' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'format' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function do_harvest_timing_soh(libPath) {
    var params = {
        range: {
            lower: {
                time_microsecs: 0
            },
            upper: {
                time_microsecs: models_1.UpperLimit.timestamp
            }
        },
        output_path: path.join(OUTPUT_ROOT, models_1.HarvestSubDirectory.timingSoh),
        output_pattern: models_1.OutputPatterns.SDS,
        hours_per_file: 24
    };
    var opId = harvester_api_1.HarvesterAPIs.harvest_timing_soh(libPath, params, 0.05);
    console.log("'harvest_timing_soh' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'do_harvest_timing_soh' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function do_harvest_logs(libPath) {
    var params = {
        range: {
            lower: {
                time_microsecs: 0
            },
            upper: {
                time_microsecs: models_1.UpperLimit.timestamp
            }
        },
        output_path: path.join(OUTPUT_ROOT, models_1.HarvestSubDirectory.forensicLogs),
        output_pattern: models_1.OutputPatterns.SDS,
        hours_per_file: 24
    };
    var opId = harvester_api_1.HarvesterAPIs.harvest_logs(libPath, params, 0.05);
    console.log("'harvest_logs' operation id: " + opId);
    //schedule harvesting operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Processing response: " + responseString);
                //parse response JSON string into JSON object
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'do_harvest_logs' completed with the code: " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function show_history(libPath) {
    var opId = harvester_api_1.HarvesterAPIs.load_harvesting_history(libPath);
    console.log("'load-harvesting-history' operation id: " + opId);
    //schedule harvesting history operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("History JSON: " + responseString);
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'show_history' finished with status " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function get_info(libPath) {
    var opId = harvester_api_1.HarvesterAPIs.get_digitizer_info(libPath);
    console.log("'get_info' operation id: " + opId);
    //schedule harvesting history operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Digitizer info JSON: " + responseString);
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'get_info' finished with status " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function get_volume_info(libPath, volumeId) {
    var opId = harvester_api_1.HarvesterAPIs.get_volume_info(libPath, volumeId);
    console.log("'get-volume-info' operation id: " + opId);
    //schedule volume info history operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                console.log("Volume info JSON: " + responseString);
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'get_volume_info' finished with status " + report_status_map[response.data.status]);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
function do_read_volume(libPath, volumeId) {
    var opId = harvester_api_1.HarvesterAPIs.read_volume(libPath, volumeId);
    console.log("'read_volume' operation id: " + opId);
    //schedule volume info history operation handler
    var handle = setInterval(function () {
        //get responses for harvester operation using its id (opId)
        var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
        if (responsesString != null) {
            //parse responses string into JSON object
            var responsesJSON = JSON.parse(responsesString);
            //iterate through "data" array in responses JSON
            for (var i = 0; i < responsesJSON.responses.length; i++) {
                var responseString = responsesJSON.responses[i];
                var response = JSON.parse(responseString);
                if (response && response.type == models_1.HarvesterOpResponseType.response) {
                    var message = response.data;
                    console.log("'read_volume' received PDB message " + message.pdb_message_type + ": " + JSON.stringify(message));
                }
                else if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                    console.log("'read_volume' finished with status " + report_status_map[response.data.status]);
                }
                else {
                    console.log("'read_volume' responded with: " + responseString);
                }
            }
        }
        else {
            clearInterval(handle);
        }
    }, 1000 /*1 sec update interval*/);
}
//set client info
harvester_api_1.HarvesterAPIs.set_client_info("Test Application v0.0.1");
harvester_api_1.HarvesterAPIs.set_logs_mask(15); //b1111 to enable all the logs
var opId = harvester_api_1.HarvesterAPIs.list();
console.log("'list' operation id: " + opId);
var detected_devices = [];
//schedule harvesting operation handler
var handle = setInterval(function () {
    //get responses for harvester operation using its id (opId)
    var responsesString = harvester_api_1.HarvesterAPIs.get_op_responses(opId, 0);
    if (responsesString != null) {
        //parse responses string into JSON object
        var responsesJSON = JSON.parse(responsesString);
        //iterate through "data" array in responses JSON
        for (var i = 0; i < responsesJSON.responses.length; i++) {
            var responseString = responsesJSON.responses[i];
            console.log("Processing response: " + responseString);
            //parse response JSON string into JSON object
            var response = JSON.parse(responseString);
            if (response && response.type == models_1.HarvesterOpResponseType.response && response.data) {
                var libPath = response.data.system_path;
                console.debug("Detected " + libPath);
                detected_devices.push(libPath);
            }
            else if (response && response.type == models_1.HarvesterOpResponseType.completion) {
                var status_1 = report_status_map[response.data.status];
                console.log("'list' finished (status: " + status_1 + ", devices: " + JSON.stringify(detected_devices));
                detected_devices.forEach(function (libPath) {
                    console.log("Processing '" + libPath + "'");
                    //do_format(libPath); // uncomment this line If you really need this test
                    get_info(libPath);
                    show_history(libPath);
                    get_volume_info(libPath, models_1.PDBVolumeID.VOLUME_SENSOR_TIME_SERIES);
                    do_harvest_data(libPath);
                    do_harvest_soh(libPath);
                    do_harvest_timing_soh(libPath);
                    do_harvest_logs(libPath);
                    do_read_volume(libPath, models_1.PDBVolumeID.VOLUME_OPERATION_LOG);
                });
            }
        }
    }
    else {
        clearInterval(handle);
    }
}, 1000 /*1 sec update interval*/);
