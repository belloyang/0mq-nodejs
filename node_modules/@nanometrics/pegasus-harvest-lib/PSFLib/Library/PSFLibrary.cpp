#include "PSFLibrary.h"
#include "PSFVolume.h"
#include "../Utils/psf_utils.h"

#include <Utils/fat32_utils.h>
#include <IOContext/io_contexts.h>
#include <PlatformUtils/PlatformUtils.h>

#include <numeric> //std::accumulate
#include <algorithm> //std::sort
#include <cmath> //std::ceil

#include <cstring> // memcpy
#include <sstream>
#include <cinttypes> // PRIu64
#include <ctime>

PSFLibrary::PSFLibrary(const std::shared_ptr<IIOContext>& ioContext,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
:  IPSFEntity(hasher, logger)
,  m_ioContext(ioContext)
{
  __DEV_CALLSTACK_FUNC__;
  // copy magic word
  ::memcpy(m_header->magic, PSF_LIBRARY_MAGIC_CONST, sizeof(PSF_LIBRARY_MAGIC_CONST));
  this->_updateHash();
}

/*static*/ PSFLibrary* PSFLibrary::create(
    const std::shared_ptr<IIOContext>& deviceContext,
    const std::shared_ptr<IHasher>& hasher,
    const std::shared_ptr<ILogger>& logger,
    const std::shared_ptr<buffer_base<char>>& readBuffer,
    const std::shared_ptr<buffer_base<char>>& writeBuffer)
{
  __DEV_CALLSTACK_FUNC__;
  const uint64_t deviceContextSize = deviceContext->getSize();
  // check device context size
  if (deviceContextSize == 0)
  {
    logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
      "Failed to open library context");
    return nullptr;
  }

  io_offset_t libraryOnDiskOffset = 0LL;
  // detect FAT32 partition size
  {
    // read Master Boot Record
    sClassicalGenericMBR mbr;
    if (deviceContext->readBlock(0, sizeof(mbr), &mbr) != sizeof(mbr))
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to read MBR from device: %s",
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      return nullptr;
    }
    // verify MBR
    if (!fat32_utils::verify_MBR(mbr))
    {
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
        "MBR record is invalid. Make sure the device is formatted!");
      return nullptr;
    }
    // verify that we have FAT32 partition here
    if (mbr.part0.partition_id != ePartitionID_t::PARTITION_ID_FAT32X_LBA)
    {
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
        "Partition#0 is not FAT32. Make sure the device is formatted!");
      return nullptr;
    }
    // read FAT32 boot entry for partition#0
    const io_offset_t part0Offset = static_cast<io_offset_t>(mbr.part0.lba_begin) * 512LL;
    sBootEntry_FAT32 bootEntry;
    if (deviceContext->readBlock(part0Offset, sizeof(bootEntry), &bootEntry) != sizeof(bootEntry))
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Failed to read partition#0 info (boot record) from device: %s",
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      return nullptr;
    }
    // verify partition#0 boot entry
    if (!fat32_utils::verify_BootEntry(bootEntry))
    {
      logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
        "Partition#0 boot entry is invalid. Make sure the device is formatted!");
      return nullptr;
    }

    // check and clear dirty flag (for STM32 platform only).
    // To do this on Linux - we need to dismount drive, lower flag, remount, but after remounting - Linux system raises this flag again
    // For Windows - we are not concerned as it handles this flag raising and lowering on FAT32 partition access (writing), which is not
    // a common case (harvesting operation only writes harvesting log to PSF part that is out of FAT32)
#if defined(DEV_PLATFORM_STM32)
    {
      const bool bIsDirty = fat32_utils::isDirtyFlagSet(bootEntry);
      if (bIsDirty)
      {
        fat32_utils::clearDirtyFlag(bootEntry);
        if (deviceContext->writeBlock(part0Offset, sizeof(bootEntry), &bootEntry) == sizeof(bootEntry))
        {
          logger->debug(__THIS_FUNC__, "FAT32 'dirty flag' has been cleared");
        }
        else
        {
          logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_WRITING_FAILED,
            "FAT32: failed to clear 'dirty flag'");
        }
      }
    }
#endif //#if defined(DEV_PLATFORM_STM32)
    const uint64_t fat32SizeBytes = static_cast<uint64_t>(bootEntry.BPB_TotSec32) * 512LL;
    libraryOnDiskOffset = part0Offset + fat32SizeBytes;
    logger->debug(__THIS_FUNC__, "FAT32 (LBA) partition detected (size = ~%.2f MiB)",
      static_cast<double>(fat32SizeBytes) / (1024.0 * 1024.0));
  }

  //tss_psflib::partial context for PSF library (skip offset)
  const std::shared_ptr<IIOContext> partialContext = std::make_shared<PartialIOContext>(deviceContext,
    libraryOnDiskOffset, deviceContextSize - libraryOnDiskOffset, logger);
  if (readBuffer == nullptr && writeBuffer == nullptr)
  {
    return new PSFLibrary(partialContext, hasher, logger);
  }
  else if (readBuffer != nullptr && writeBuffer != nullptr)
  {
    logger->debug(__THIS_FUNC__, "Buffer info:\n"
        "    read bufferSzHint = %" PRIu32 " Bytes (%.3f MiBytes)\n"
        "    write bufferSzHint = %" PRIu32 " Bytes (%.3f MiBytes)",
        static_cast<uint32_t>(readBuffer->size()), (double)readBuffer->size() / 1024.0 / 1024.0,
        static_cast<uint32_t>(writeBuffer->size()), (double)writeBuffer->size() / 1024.0 / 1024.0);
    // create Buffered context over File I/O to optimize read operations
    const std::shared_ptr<IIOContext> bufferedContext = std::make_shared<BufferedIOContext>(partialContext, readBuffer, writeBuffer, logger);
    return new PSFLibrary(bufferedContext, hasher, logger);
  }
  logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
      "read/write buffers must be both defined or both not defined");
  return nullptr;
}

/*static*/ PSFLibrary* PSFLibrary::create(const std::shared_ptr<IIOContext>& deviceContext,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const size_t bufferSzHint)
{
  __DEV_CALLSTACK_FUNC__;
  const std::shared_ptr<buffer_base<char>> readBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  const std::shared_ptr<buffer_base<char>> writeBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  return PSFLibrary::create(deviceContext, hasher, logger, readBuffer, writeBuffer);
}

#if !defined(DEV_PLATFORM_STM32)
/*static*/ PSFLibrary* PSFLibrary::create(const std::string& path,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const bool async,
  const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer)
{
  __DEV_CALLSTACK_FUNC__;
  logger->debug(__THIS_FUNC__, "Creating '%s' library", path.c_str());
#if defined(DEV_PLATFORM_WIN32)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_Windows>(path,
      GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING, logger);
#elif defined(DEV_PLATFORM_LINUX)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(path, O_RDWR | O_LARGEFILE, logger);
#elif defined(DEV_PLATFORM_MACOS)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(path, O_RDWR, logger);
#endif
  // create read ahead decorator context for all platforms
  if (async)
  {
    const std::shared_ptr<IIOContext> context = std::make_shared<ReadAheadIOContext>(deviceContext, logger);
    return PSFLibrary::create(context, hasher, logger, readBuffer, writeBuffer);
  }
  // create the library over the final context
  return PSFLibrary::create(deviceContext, hasher, logger, readBuffer, writeBuffer);
}

/*static*/ PSFLibrary* PSFLibrary::create(const std::string& path,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const bool async,
  const size_t bufferSzHint)
{
  __DEV_CALLSTACK_FUNC__;
  const std::shared_ptr<buffer_base<char>> readBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  const std::shared_ptr<buffer_base<char>> writeBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  return PSFLibrary::create(path, hasher, logger, async, readBuffer, writeBuffer);
}
#endif


/*static*/ PSFLibrary* PSFLibrary::create(const std::shared_ptr<IIODriver>& driver,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer)
{
  __DEV_CALLSTACK_FUNC__;
  logger->debug(__THIS_FUNC__, "Creating library for STM32 platform (buffered)");
  // create driver based context
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<DriverBasedIOContext>(driver, logger);
  // create library
  return PSFLibrary::create(deviceContext, hasher, logger, readBuffer, writeBuffer);
}

/*static*/ PSFLibrary* PSFLibrary::create(const std::shared_ptr<IIODriver>& driver,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
{
  __DEV_CALLSTACK_FUNC__;
  logger->debug(__THIS_FUNC__, "Creating library for STM32 platform (unbuffered)");
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<DriverBasedIOContext>(driver, logger);
  return PSFLibrary::create(deviceContext, hasher, logger, nullptr, nullptr);
}

/*static*/ PSFLibrary* PSFLibrary::create(const std::shared_ptr<IIODriver>& driver,
  const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const size_t bufferSzHint)
{
  __DEV_CALLSTACK_FUNC__;
  const std::shared_ptr<buffer_base<char>> readBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  const std::shared_ptr<buffer_base<char>> writeBuffer = std::make_shared<buffer_io_aligned_alloc<char>>(bufferSzHint);
  return PSFLibrary::create(driver, hasher, logger, readBuffer, writeBuffer);
}

bool PSFLibrary::restore()
{
  __DEV_CALLSTACK_FUNC__;
  m_bIsValid = this->_loadFromContext(m_ioContext, 0);
  return m_bIsValid;
}

bool PSFLibrary::format(const std::vector<sPSFVolumeConfig_t>& volumesConfigs, const std::shared_ptr<ITimer>& timer)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(timer != nullptr && "timer cannot be nullptr here");
  // "destroy" PSF library (write empty header)
  {
    m_header.clear();
    const size_t bytesWritten = m_ioContext->writeBlock(0, m_header.size(), m_header.ptr());
    if (bytesWritten != m_header.size())
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_WRITING_FAILED,
        "Failed to destroy library header!");
      return false;
    }
  }

  // create volumes infos from volumes configurations
  std::vector<sVolumeInfo> volumesToCreate;
  {
    volumesToCreate.reserve(volumesConfigs.size());
    // calculate total volumes weight/ratio
    const double totalPercent = std::accumulate(volumesConfigs.begin(), volumesConfigs.end(), 0.0,
      [](double sum, const sPSFVolumeConfig_t& config) {
        return config.sizePercent + sum;
      });
    // check if the total weight sums up to 1.0 and produce a warning if not
    if (std::abs(100.0 - totalPercent) > 0.000001) //we are using 6 digits for volume percent -> use it as epsilon
    {
      m_logger->warning(__THIS_FUNC__, "Total volumes percent (%.6f%%) is not equal 100.0%%. Sizes will be adjusted proportionally!",
        totalPercent);
    }

    // sort volumes by percentage (from low to high)
    // This ensures that the smallest volumes will be sized by rounding to next highest number of chapters. The largest volume will ultimately get whatever remains
    std::vector<sPSFVolumeConfig_t> sortedConfigs = volumesConfigs;
    std::sort(sortedConfigs.begin(), sortedConfigs.end(),
      [](const sPSFVolumeConfig_t& config1, const sPSFVolumeConfig_t& config2) {
        return config1.sizePercent < config2.sizePercent;
      });

    uint32_t nChaptersUsed = 0;
    // get total available size in chapters
    const uint64_t librarySizeInBytes = m_ioContext->getSize();
    const uint32_t nChaptersTotal = static_cast<uint32_t>(librarySizeInBytes / PSF_CHAPTER_SIZE_BYTES);
    const uint32_t nVolumes = static_cast<uint32_t>(volumesConfigs.size());
    // get total amount of chapters for data = total - 1 (library header) - nVolumes (for each volume header)
    const uint32_t nDataChapters = nChaptersTotal - 1 - nVolumes;
    // go over the configuration and create the volume info structure
    for (uint32_t volumeIdx = 0; volumeIdx < nVolumes; volumeIdx++)
    {
      const sPSFVolumeConfig_t& config = sortedConfigs[volumeIdx];
      sVolumeInfo info; ::memset(&info, 0, sizeof(sVolumeInfo));
      // set volume ID
      info.uniqueId = config.id;
      // copy volume label
      ::memcpy(info.label, config.label, sizeof(VolumeLabel_t));
      // calculate volume size in chapters
      if (volumeIdx == nVolumes - 1) //the very last volume just gets all the chapters that remain
      {
        // the last volume just takes up the remaining chapters (-1 for PSF library header)
        info.sizeInChapters = nChaptersTotal - nChaptersUsed - 1;
      }
      else
      {
        // calculate chapters count based on percent
        const double normalizedPercent = config.sizePercent / totalPercent;
        // calculate data chapters count based on percent + 1 chapter (rounded up) for volume header
        info.sizeInChapters = static_cast<uint32_t>(std::ceil(normalizedPercent * nDataChapters)) + 1;
      }
      nChaptersUsed += info.sizeInChapters;
      // add volume info (to front)
      volumesToCreate.emplace_back(info);
    }
    // simple check to make sure ALL the chapters have been used for volumes (-1 - for library header)
    __ASSERT__(nChaptersUsed == (nChaptersTotal - 1) && "Sanity check failed. Some chapters remains unused!");
  }

  // initialize PSF library header
  ::memcpy(m_header->magic, PSF_LIBRARY_MAGIC_CONST, sizeof(PSF_LIBRARY_MAGIC_CONST));
  m_header->psfVersion = PSF_VERSION;
  m_header->creationTime = timer->now();
  // advance to 1 chapter as header keeps 1st chapter
  uint32_t volumeChapter = 1, volumeIndex = 0;
  //create volumes
  for (const auto& volumeInfo : volumesToCreate)
  {
    const uint32_t createdVolumeSizeInChapters = this->_createVolumeAt(volumeInfo, volumeChapter);
    if (createdVolumeSizeInChapters > 0)
    {
      m_header->volumeOffsetsInChapters[volumeIndex] = volumeChapter;
      volumeChapter += createdVolumeSizeInChapters;
      volumeIndex++;
    }
    else
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
        "Failed to create volume (start = %" PRIu32 " chapter, size = %" PRIu32 " chapters)",
        volumeChapter,
        volumeInfo.sizeInChapters);
    }
  }
  // write actual amount of created volumes
  m_header->nVolumes = volumeIndex;

  // calculate hash and write the header to context
  {
    this->_updateHash();
    const size_t bytesWritten = m_ioContext->writeBlock(0, m_header.size(), m_header.ptr());
    m_bIsValid = (bytesWritten == m_header.size());
  }
  //flush all the changes to context
  m_ioContext->flush();

  if (m_bIsValid)
  {
    tm lowerTime; psf_utils::gmtime_from_timestamp(m_header->creationTime, &lowerTime);
    char timeBuf[32] = {0};
    std::strftime(timeBuf, sizeof(timeBuf), "%a, %d.%m.%Y %H:%M:%S", &lowerTime);
    m_logger->info(__THIS_FUNC__, "PSF library formatted:\n"
        "   version=%" PRIu32 "\n"
        "   timestamp=%s",
        m_header->psfVersion,
        timeBuf);
  }

  return m_bIsValid;
}

bool PSFLibrary::listVolumes(std::vector<sVolumeInfo>& out) const
{
  __DEV_CALLSTACK_FUNC__;
  if (m_header->nVolumes <= 0)
  {
    return false;
  }
  // start from clean slate
  out.clear();
  // list each volume
  for (uint32_t i = 0; i < m_header->nVolumes; ++i)
  {
    const PSFVolume* const volume = this->getVolume(i);
    if (volume != nullptr)
    {
      const sPSFVolumeHeader_t* const volumeHeader = volume->getHeader();
      sVolumeInfo info;
      ::memcpy(info.label, volumeHeader->label, sizeof(VolumeLabel_t));
      info.uniqueId = volumeHeader->uniqueId;
      info.sizeInChapters = volumeHeader->sizeInChapters;
      info.index = i;
      info.startChapter = m_header->volumeOffsetsInChapters[i];
      info.bTimeValid = false;
      info.lowerTime = 0;
      info.upperTime = 0;
      out.emplace_back(info);
    }
  }
  return true;
}

uint32_t PSFLibrary::_createVolumeAt(const sVolumeInfo& info, uint32_t chapterIndex) const
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t iRet = 0U;
  // check if we have enough space to create volume at this chapter
  const io_offset_t volumeOffset = PSF_SECTIONS_to_BYTES(chapterIndex);
  const uint64_t volumeSizeInBytes = PSF_CHAPTERS_to_BYTES(info.sizeInChapters);
  const uint64_t contextSizeInBytes = m_ioContext->getSize();
  if (volumeOffset + volumeSizeInBytes <= contextSizeInBytes)
  {
    // create and init volume
    PSFVolume* const volume = new PSFVolume(m_hasher, m_logger);
    if (volume->init(info.label, info.uniqueId, info.sizeInChapters) == true)
    {
      // dump volume to context at its offset
      const uint32_t volumeSizeInChapters = volume->create(m_ioContext, volumeOffset);
      if (volumeSizeInChapters != 0)
      {
        m_ioContext->flush();
        m_logger->info(__THIS_FUNC__, "volume %.*s (%" PRIu32 " chapters = %" PRIu32 " MiBytes) created",
          NUM_ELEMENTS(info.label), info.label,
          volumeSizeInChapters,
          static_cast<uint32_t>(PSF_CHAPTERS_to_BYTES(volumeSizeInChapters) / (1024ULL * 1024ULL)));
        iRet = volumeSizeInChapters;
      }
      else
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
          "Failed to create volume (%.*s, %" PRIu32 " chapters)",
          NUM_ELEMENTS(info.label), info.label,
          info.sizeInChapters);
      }
    }
    else
    {
      // volume initialization failed
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
        "Failed to init volume (%.*s, %" PRIu32 " chapters)",
        NUM_ELEMENTS(info.label), info.label,
        info.sizeInChapters);
    }
    // release volume object
    delete volume;
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
      "There is not enough space to create new volume at context:\n"
      "    label = %.*s,\n"
      "    offset = %" PRIu64 " bytes ,\n"
      "    size = %" PRIu32 " chapters (%" PRIu64 " bytes).\n"
      "    Context size = %" PRIu64 " bytes",
      NUM_ELEMENTS(info.label), info.label,
      static_cast<uint64_t>(volumeOffset),
      info.sizeInChapters, volumeSizeInBytes,
      contextSizeInBytes);
  }

  return iRet;
}

PSFVolume* PSFLibrary::_getVolumeAt(const uint32_t chapterIndex) const
{
  __DEV_CALLSTACK_FUNC__;
  const uint64_t librarySize = m_ioContext->getSize();
  //tss_psflib::calculate chapter offset in bytes to fetch it from I/O context
  const io_offset_t chapterOffsetBytes = PSF_SECTIONS_to_BYTES(chapterIndex);
  __ASSERT__(chapterOffsetBytes < librarySize && "Chapter doesn't exists in the library");
  if (chapterOffsetBytes >= librarySize)
  {
    m_logger->warning(__THIS_FUNC__, "Looking for volume (offset=%" PRIu64 "bytes). Spills out of library size (%" PRIu64 " bytes)",
        chapterOffsetBytes, librarySize);
    return nullptr;
  }

  PSFVolume* const volume = new PSFVolume(m_hasher, m_logger);
  const uint64_t volumeSize = volume->restore(m_ioContext, chapterOffsetBytes);
  if (volumeSize > 0)
  {
    return volume;
  }
  delete volume;

  // notify warning
  m_logger->warning(__THIS_FUNC__, "Chapter %" PRIu32 " (offset=%" PRIu64 " bytes) doesn't exist in the library (size=%" PRIu64 " bytes)",
    chapterIndex, chapterOffsetBytes, librarySize);
  return nullptr;
}

bool PSFLibrary::_loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  bool bRet = false;
  // trying to restore library header from context
  io_aligned_ptr<sPSFLibraryHeader_t> header;
  const size_t headerSize = context->readBlock(offset, header.size(), header.ptr());
  // if all data read from context and magic string found -> partition is restored
  if ((headerSize == header.size()) && (::memcmp(header->magic, PSF_LIBRARY_MAGIC_CONST, sizeof(PSF_LIBRARY_MAGIC_CONST)) == 0))
  {
    if (this->_checkIntegrity(*header))
    {
      // copy header
      m_header.load(header.ptr());
      m_logger->debug(__THIS_FUNC__, "Library is restored from I/O context");
      bRet = true;
    }
    else
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
        "Header integrity check failed (hash mismatch!)");
    }
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_NOT_PSF,
      "I/O context appears to be not PSF library!");
  }
  return bRet;
}

int PSFLibrary::_updateHash()
{
  __DEV_CALLSTACK_FUNC__;
  const std::shared_ptr<IIOContext> headerMemContext = std::make_shared<MemoryBufferIOContext>(
      m_header->magic, //skip m_hash field
      sizeof(sPSFLibraryHeader_t) - sizeof(Hash32_t), //skip m_hash field
      m_logger);
  const int hashSize = m_hasher->getHash32(headerMemContext, m_header->hash);
  return hashSize;
}

bool PSFLibrary::_checkIntegrity(const sPSFLibraryHeader_t& header) const
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRet = m_hasher->checkIntegrity(
      std::make_shared<MemoryBufferIOContext>(
          &header.magic, // skip m_hash field
          sizeof(sPSFLibraryHeader_t) - sizeof(Hash32_t), // exclude m_hash field size
          m_logger),
      header.hash);
  if (!bRet)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_INTEGRITY_CHECK_FAILED,
      "Library's integrity check failed!");
  }
  return bRet;
}

PSFVolume* PSFLibrary::findVolumeByLabel(const std::string& label) const
{
  __DEV_CALLSTACK_FUNC__;
  for (uint32_t i = 0; i < m_header->nVolumes; ++i)
  {
    const uint32_t volumeStartChapter = m_header->volumeOffsetsInChapters[i];
    PSFVolume* const pVolume = this->_getVolumeAt(volumeStartChapter);
    // check volume label
    if (pVolume != nullptr && ::strncmp(label.c_str(), pVolume->getHeader()->label, sizeof(VolumeLabel_t)) == 0)
    {
      return pVolume;
    }
    delete pVolume;
  }
  // notify that volume wasn't found
  m_logger->info(__THIS_FUNC__, "Volume '%s' not found!", label.c_str());
  return nullptr;
}

PSFVolume* PSFLibrary::findVolumeByID(const uint32_t volumeId) const
{
  __DEV_CALLSTACK_FUNC__;
  for (uint32_t i = 0; i < m_header->nVolumes; ++i)
  {
    const uint32_t volumeStartChapter = m_header->volumeOffsetsInChapters[i];
    PSFVolume* const pVolume = this->_getVolumeAt(volumeStartChapter);
    // check volume ID
    if (pVolume != nullptr && pVolume->getHeader()->uniqueId == volumeId)
    {
      return pVolume;
    }
    delete pVolume;
  }
  // notify that volume wasn't found
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_RESTORING_FAILED,
    "Volume id=%" PRIu32 " not found!", volumeId);
  return nullptr;
}

PSFVolume* PSFLibrary::getVolume(const uint32_t index) const
{
  __DEV_CALLSTACK_FUNC__;
  if (index < m_header->nVolumes)
  {
    const uint32_t volumeStartChapter = m_header->volumeOffsetsInChapters[index];
    return this->_getVolumeAt(volumeStartChapter);
  }
  return nullptr;
}
