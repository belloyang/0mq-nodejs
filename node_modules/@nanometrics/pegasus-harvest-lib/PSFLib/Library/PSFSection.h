#ifndef PSFSection_h__
#define PSFSection_h__

#include "../psflib_defines.h"
#include "IPSFEntity.h"
#include <IOContext/IIOContext.h>
#include <Hasher/IHasher.h>
#include <buffers.h>

#include <memory>
#include <string>
#include "IPSFSectionUpdateDelegate.h"


class PSFVolume;
class PSFDataElement;

/// <summary>
/// PSFSection. Represents PSF section object.\n
/// Section spans 1 chapter (1st page is for header), section is aligned to chapter start.
/// </summary>
class PSFSection : public IPSFEntity
{
public:
  /// <summary>
  /// Iterator class
  /// </summary>
  class iterator
  {
  private:
    iterator(const PSFSection* pSection, const uint32_t startPage);

  public:
    /**
     * Read next data element in the section.
     * @param output  data element to store data into
     * @return true on success, false - on failure (end of section reached, etc.)
     */
    bool readNext(PSFDataElement& output);

  private:
    const PSFSection* m_pSection;
    uint32_t m_nextPage;
    uint32_t m_nextSequenceIndex;
    friend class PSFSection;
  };

public:
  /**
   * PSFSection constructor
   * @param volume        parent volume (volume that owns this section)
   */
  PSFSection(const PSFVolume* pVolume);

  /**
   * PSFSection destructor
   */
  ~PSFSection();

  /**
   * returns iterator that allows to iterate through data elements in the section
   */
  iterator begin() const { return iterator(this, 1); }

  /**
   * Creates and dumps PSFSection
   * @param context  context to create section at
   * @param offset  offset inside context to create section at
   * @param createContexts specifies if I/O contexts should be created.
   * @return  created section size. 0 - on failure
   */
  size_t create(const uint32_t sectionIndex, const std::shared_ptr<IIOContext>& context, io_offset_t offset,
      const bool createContexts = true);
  
  /**
   * Creates I/O contexts
   * @param context  parent context to create section at
   * @return  success if contexts created; false -> otherwise
   */
  bool createContexts(const std::shared_ptr<IIOContext>& context);

  /**
   * Restores PSFSection from volume I/O context at set offset
   * @param context  context to restore section from
   * @param offset  offset inside context to restore section at
   * @return      restored section size. 0 - on failure
   */
  size_t restore(const uint32_t sectionIndex, const std::shared_ptr<IIOContext>& context, io_offset_t offset);

  /**
   * Discards (emptifies section). Useful when ring buffer is looped and section should be cleared before adding new data
   * @return    true on success; false - otherwise
   */
  bool discard();

  /**
   * Section's index getter
   * @return    section's index
   */
  FORCE_INLINE uint32_t getIndex() const { return m_index; }

  /**
   * Section's index setter
   * @param index  index to set
   */
  FORCE_INLINE void setIndex(const uint32_t index) { m_index = index; }

  /**
   * Section's offset getter (offset inside volume context)
   * @return  section's offset (offset inside volume context)
   */
  FORCE_INLINE io_offset_t getInVolumeOffset() const { return m_inVolumeOffset; }

  /**
   * Section's header getter
   * @return    section's header
   */
  FORCE_INLINE const sPSFSectionHeader_t* getHeader() const { return m_header.ptr(); }

  /**
   * Checks if section is empty
   * @return  true - when section is empty; false - otherwise
   */
  FORCE_INLINE bool isEmpty() const { return (m_header->nextPage == 1); }

  /**
   * Checks if dataElement can be stored withing this section
   * @param dataElement  data element to store in the section
   * @return        true - if data element can be stored in the section; false - otherwise
   */
  bool canFitDataElement(const PSFDataElement* dataElement) const;

  /**
   * hecks if data element with specified sequenceNumber is stored within this section
   * @param sequenceNumber  data element sequence number to check in the section
   * @return          true - if data element is stored in the section; false - otherwise
   */
  bool containsDataElement(const sequence_number_t sequenceNumber) const;

  /**
   * Writes data element to section
   * @param dataElement  dataElement to write to this section
   * @return        written data element size on success; 0 - on failure
   */
  size_t writeDataElement(PSFDataElement* dataElement,
      const std::shared_ptr<IPSFSectionUpdateDelegate>& updateDelegate);

  /**
   * Reads data element from section at specified offset
   * @param out        output PSFDataElement object
   * @param inSectionOffset  in-section offset to read data element at
   * @return          read data element's size on success; 0 - on failure
   */
  size_t readDataElement(const io_offset_t inSectionOffset, PSFDataElement& output) const;

  /**
   * Reads data element by sequence number
   * @param sequenceNumber  data element's sequence number to seek for
   * @return                found data element on success; nullptr - on failure
   */
  PSFDataElement* findDataElement(const sequence_number_t sequenceNumber) const;

  /**
   * Loads data element from section by sequence number
   * @param sequenceNumber    data element's sequence number to seek for
   * @param output            data element to store data into
   * @return                  data element size (in bytes), 0 - if not restored
   */
  size_t loadDataElement(const sequence_number_t sequenceNumber, PSFDataElement& output) const;

  /**
   * Flushes section to underlying context.
   */
  bool flush(const std::shared_ptr<IPSFSectionUpdateDelegate>& updateDelegate);

private:
  virtual bool _loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset) __OVERRIDES__(IPSFEntity);
  bool _dumpHeader(const std::shared_ptr<IIOContext>& context, io_offset_t offset);
  int _updateHash();
  bool _checkIntegrity(const sPSFSectionHeader_t& header) const;

private:
  //! Header data
  io_aligned_ptr<sPSFSectionHeader_t> m_header;
  //! Section's index
  uint32_t m_index;
  //! In volume offset (in bytes)
  io_offset_t m_inVolumeOffset;
  //! section's context (context to access section data only)
  std::shared_ptr<IIOContext> m_sectionContext;
  //! bool flag that specifies if header is up to date
  bool m_bIsHeaderUpToDate;
};

#endif //PSFSection_h__
