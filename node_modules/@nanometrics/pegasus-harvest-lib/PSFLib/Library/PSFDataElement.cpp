#include <cstring> // memcpy, memset

#include <IOContext/MemoryBufferIOContext.h>
#include <IOContext/SequentialIOContext.h>
#include <buffers.h>

#include "PSFDataElement.h"

#include <cinttypes>

// begin: anonymous namespace
namespace
{

  // given size (bytes), rounded up to nearest page
  // WARNING: ignores case where sz_bytes == 0; see assert in PSFDataElement constructor
  size_t roundUpToPageBytes(size_t sz_bytes)
  {
    return ((sz_bytes - 1) / PSF_PAGE_SIZE_BYTES + 1) * PSF_PAGE_SIZE_BYTES;
  }

  // size of data element header, rounded up to nearest page
  const size_t szDataElemHdr_Rounded = roundUpToPageBytes(sizeof(sPSFDataElementHeader_t));

}
// end: anonymous namespace

PSFDataElement::PSFDataElement(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
  : IPSFEntity(hasher, logger)
  , m_inSectionOffset(0)
{
  __DEV_CALLSTACK_FUNC__;
  // reserve at least enough space for 1x Data Element Header
  __ASSERT__(szDataElemHdr_Rounded <= PSF_MAX_DATA_ELEMENT_SIZE_BYTES && "szDataElemHdr_Rounded exceeds maximum allowed");
  this->_allocateBuffer(szDataElemHdr_Rounded);
  // instantiate MemoryBufferIOContext object for hasher
  m_hasherContext.reset(new MemoryBufferIOContext(m_buffer->ptr(), m_buffer->size(), m_logger));
}

void* PSFDataElement::_allocateBuffer(const size_t newSize)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_buffer == nullptr)
  {
    m_buffer = std::make_shared<buffer_io_aligned_alloc<char>>(static_cast<uint32_t>(newSize));
  }
  else
  {
    m_buffer->realloc(static_cast<uint32_t>(newSize));
  }
  //tss_psflib::return buffer data pointer
  return m_buffer->ptr();
}

size_t PSFDataElement::init(const message_type_t type, const void* pData, const size_t size)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(size > 0 && "DataElement cannot be less then 1 byte long");
  const size_t sizeInPages = (size - 1 + sizeof(sPSFDataElementHeader_t)) / PSF_PAGE_SIZE_BYTES + 1;
  //tss_psflib::max data element size check (cannot store over then 1 section/chapter)
  __ASSERT__(sizeInPages <= PSF_MAX_DATA_ELEMENT_SIZE_PAGES && "The data element size exceeds maximum allowed");
  if (sizeInPages > PSF_MAX_DATA_ELEMENT_SIZE_PAGES)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
      "Data element (size=%" PRIu32 " pages) exceed maximum size allowed (%" PRIu32 " pages)",
      static_cast<uint32_t>(sizeInPages),
      static_cast<uint32_t>(PSF_MAX_DATA_ELEMENT_SIZE_PAGES));
    return 0;
  }

  const size_t sizeInBytes = PSF_PAGES_to_BYTES(sizeInPages);
  //tss_psflib::allocate and clear buffer for header & data
  void* const pBuffer = this->_allocateBuffer(sizeInBytes);
  // initialize the header
  {
    sPSFDataElementHeader_t* const headerPtr = reinterpret_cast<sPSFDataElementHeader_t*>(pBuffer);
    //tss_psflib::fill up header data
    headerPtr->messageType = type;
    headerPtr->sizeInPages = static_cast<uint8_t>(sizeInPages);
    headerPtr->sequenceNumber = PSF_SEQUENCE_NUMBER_INVALID;
    ::memcpy(headerPtr->magic, PSF_DATA_ELEMENT_MAGIC_CONST, sizeof(PSF_DATA_ELEMENT_MAGIC_CONST));
  }
  // initialize data (if set)
  {
    if (pData != nullptr && size > 0)
    {
      char* dataPtr = reinterpret_cast<char*>((char*)pBuffer + sizeof(sPSFDataElementHeader_t));
      ::memcpy(dataPtr, pData, size);
    }
  }

  m_bIsValid = true;
  //tss_psflib::return allocated buffer size
  return sizeInBytes;
}

size_t PSFDataElement::restore(const std::shared_ptr<IIOContext>& sectionContext, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRestored = this->_loadFromContext(sectionContext, offset);
  if (bRestored)
  {
    //tss_psflib::data element restored -> return it's size in bytes
    const uint8_t sizeInPages = this->getHeader()->sizeInPages;
    return PSF_PAGES_to_BYTES(sizeInPages);
  }

  //tss_psflib::failed to restore Data Element -> return 0
  return 0;
}

bool PSFDataElement::_loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::read header info from context
  __ASSERT__(m_buffer->size() >= szDataElemHdr_Rounded && "No room in 'm_buffer' for data element header");
  sPSFDataElementHeader_t* const pHdr = m_buffer->ptr<sPSFDataElementHeader_t>();
  size_t readBytes = context->readBlock(offset, szDataElemHdr_Rounded, pHdr);
  if (readBytes != szDataElemHdr_Rounded)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "Failed to restore DataElement header from context");
    return false;
  }

  //tss_psflib::read data
  const size_t totalSizeBytes = PSF_PAGES_to_BYTES(pHdr->sizeInPages);
  void* pBuffer = reinterpret_cast<void*>(pHdr);
  if (totalSizeBytes > readBytes) {
    //tss_psflib::allocate/reallocate buffer of this size
    pBuffer = this->_allocateBuffer(totalSizeBytes); // warning: if re-allocated then previously read header will be lost
    //read all the data to buffer (header + payload)
    readBytes = context->readBlock(offset, totalSizeBytes, pBuffer);
    if (readBytes != totalSizeBytes)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
        "Failed to restore DataElement body from context");
      return false;
    }
  }
  if (!this->_checkIntegrity(pBuffer))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "DataElement integrity check failed");
    //tss_psflib::discard Data Element validity flag
    m_bIsValid = false;
    return false;
  }

  m_inSectionOffset = offset;
  m_bIsValid = true;
  return true;
}

//dumps DataElement completely (header & data|payload)
size_t PSFDataElement::dump(const std::shared_ptr<IIOContext>& sectionContext, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::dump data by itself
  const sPSFDataElementHeader_t* const headerPtr = m_buffer->ptr<sPSFDataElementHeader_t>();
  if (m_buffer->ptr() == NULL || !__is_io_aligned__(m_buffer->ptr()) || headerPtr->sizeInPages < 1)
  {
    m_logger->warning(__THIS_FUNC__, "Data element has invalid/unaligned buffer (%p, size=%" PRIu32 " pages) which will be skipped",
      m_buffer->ptr(),
      static_cast<uint32_t>(headerPtr->sizeInPages));
  }
  else if (this->_updateHash() > 0)
  {
    const size_t totalSizeBytes = PSF_PAGES_to_BYTES(headerPtr->sizeInPages);
    const size_t dataWritten = sectionContext->writeBlock(offset, totalSizeBytes, m_buffer->ptr());
    if (totalSizeBytes != dataWritten)
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED, 
        "Failed to dump DataElement data (size=%" PRIu32,
        static_cast<uint32_t>(totalSizeBytes));
      return 0;
    }

    m_inSectionOffset = offset;
    return totalSizeBytes;
  }

  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED, 
    "Failed to update DataElement hash");
  return 0;
}

bool PSFDataElement::reserveMemory(const uint32_t memorySizeInBytes)
{
  __DEV_CALLSTACK_FUNC__;
  void* const pBuffer = this->_allocateBuffer(memorySizeInBytes);
  if (pBuffer != nullptr)
    return true;

  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_OUT_OF_MEMORY, 
    "Failed to reserve memory (size=%" PRIu32 " bytes)", memorySizeInBytes);
  return false;
}

size_t PSFDataElement::getData(const void** pData) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::if no data to lock -> return error
  if (m_buffer->empty())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "Data cannot be locked -> Data Element is not initialized/restored!");
    *pData = nullptr;
    return 0;
  }

  const sPSFDataElementHeader_t* const headerPtr = m_buffer->ptr<sPSFDataElementHeader_t>();
  //tss_psflib::lock data (it comes right after the header)
  *pData = (void*)(m_buffer->ptr<char>() + sizeof(sPSFDataElementHeader_t));
  //tss_psflib::expose payload size (data element size - sizeof(Header))
  const size_t payloadSize = PSF_PAGES_to_BYTES(headerPtr->sizeInPages) - sizeof(sPSFDataElementHeader_t);
  return payloadSize;
}

size_t PSFDataElement::getData(void** pData)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::if no data to lock -> return error
  if (m_buffer->empty())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "Data cannot be locked -> Data Element is not initialized/restored!");
    *pData = nullptr;
    return 0;
  }

  const sPSFDataElementHeader_t* const headerPtr = m_buffer->ptr<sPSFDataElementHeader_t>();
  //tss_psflib::lock data (it comes right after the header)
  *pData = (void*)(m_buffer->ptr<char>() + sizeof(sPSFDataElementHeader_t));
  //tss_psflib::expose payload size (data element size - sizeof(Header))
  const size_t payloadSize = PSF_PAGES_to_BYTES(headerPtr->sizeInPages) - sizeof(sPSFDataElementHeader_t);
  return payloadSize;
}

int PSFDataElement::_updateHash()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_buffer->empty())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
      "Data Element is not initialized/restored (null buffer). Cannot calculate the hash!!!");
    return 0;
  }

  sPSFDataElementHeader_t* const headerPtr = m_buffer->ptr<sPSFDataElementHeader_t>();
  const size_t totalSizeBytes = PSF_PAGES_to_BYTES(headerPtr->sizeInPages);
  const int hashLen = m_hasher->getHash32(
    std::make_shared<MemoryBufferIOContext>(
      &headerPtr->sequenceNumber, //skip m_hash field
      totalSizeBytes - sizeof(Hash32_t), //skip m_hash field
      m_logger),
    headerPtr->hash);

  return hashLen;
}

bool PSFDataElement::_checkIntegrity(const void* pBuffer) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pBuffer != nullptr && "pBuffer cannot be nullptr here!");
  //tss_psflib::fetch header from the buffer
  const sPSFDataElementHeader_t* const headerPtr = reinterpret_cast<const sPSFDataElementHeader_t*>(pBuffer);
  const size_t totalSizeBytes = PSF_PAGES_to_BYTES(headerPtr->sizeInPages);
  if (totalSizeBytes == 0 || totalSizeBytes > PSF_MAX_DATA_ELEMENT_SIZE_BYTES)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_INTEGRITY_CHECK_FAILED,
      "Error to check integrity. Invalid DataElement size = %" PRIu32,
      static_cast<uint32_t>(totalSizeBytes));
    return false;
  }

  //tss_psflib::check data element integrity (header & payload - the entire buffer)
  m_hasherContext->init(
    &headerPtr->sequenceNumber, //skip m_hash field
    totalSizeBytes - sizeof(Hash32_t) //skip m_hash field
  );
  const bool bRet = m_hasher->checkIntegrity(
    m_hasherContext,
    headerPtr->hash);
  if (!bRet)
  {
    m_logger->error(__THIS_FUNC__, 
      eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_INTEGRITY_CHECK_FAILED,
      "Data element's integrity check failed!");
  }
  return bRet;
}
