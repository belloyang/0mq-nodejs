#ifndef PSFLibrary_h__
#define PSFLibrary_h__

#include "../psflib_defines.h"
#include "IPSFEntity.h"
#include "PSFVolume.h"

#include <IOContext/IIOContext.h>
#include <IOContext/IIODriver.h>
#include <Hasher/IHasher.h>
#include <Meters/Timers/ITimer.h>
#include <buffers.h>

#include <string>
#include <memory>
#include <vector>

/// <summary>
/// Represents PSF library object (top-level one).\n
/// </summary>
class PSFLibrary : public IPSFEntity
{
public:
  /**
   * PSFLibrary constructor
   * @param ioContext    root/main I/O context for library
   * @param hasher    hasher instance
   * @param logger    logger instance
   */
  PSFLibrary(const std::shared_ptr<IIOContext>& ioContext,
      const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger);

  /**
   * PSFLibrary destructor
   */
  ~PSFLibrary() = default;

  /** PSFLibrary creator method
   * @param deviceContext  device underlying I/O context
   * @param hasher         hasher instance
   * @param logger         logger instance
   * @param readbuffer     pointer to buffer to be used for read caching
   * @param writeBuffer    pointer to buffer to be used for write caching
   *
   * NOTE:
   * If both readbufferPtr and writebufferPtr are nullptr then an unbuffered IO
   * context will be created.
   */
  static PSFLibrary* create(
    const std::shared_ptr<IIOContext>& deviceContext,
    const std::shared_ptr<IHasher>& hasher,
    const std::shared_ptr<ILogger>& logger,
    const std::shared_ptr<buffer_base<char>>& readBuffer,
    const std::shared_ptr<buffer_base<char>>& writeBuffer
    );

  /** PSFLibrary creator method
   * @param deviceContext  device underlying I/O context
   * @param hasher    hasher instance
   * @param logger    logger instance
   * @param bufferSzHint  (OPTIONAL) hint for I/O buffer size
   */
  static PSFLibrary* create(const std::shared_ptr<IIOContext>& deviceContext,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
    const size_t bufferSzHint = __IO_BUFFERS_SIZE__);
  
#if !defined(DEV_PLATFORM_STM32) //path makes no sense on STM32 controller -> hide this method
  /** PSFLibrary creator method
   * @param path      file path to create PSF library at
   * @param hasher    hasher instance
   * @param logger    logger instance
   * @param async     make an asynchronous reader I/O context (NOTE: writing is still blocking/non-async)
   * @param bufferSzHint  (OPTIONAL) hint for I/O buffer size
   */
  static PSFLibrary* create(const std::string& path,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
    const bool async,
    const size_t bufferSzHint = __IO_BUFFERS_SIZE__);
  /** PSFLibrary creator method
   * @param path        file path to create PSF library at
   * @param hasher      hasher instance
   * @param logger      logger instance
   * @param async       make an asynchronous reader I/O context (NOTE: writing is still blocking/non-async)
   * @param readBuffer  buffer to be used for I/O caching
   * @param writeBuffer buffer to be used for I/O caching
   */
  static PSFLibrary* create(const std::string& path,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
    const bool async,
    const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer);
#endif
 
  /** PSFLibrary creator method - BUFFERED
   * @param driver      IO driver (SD MMC, eMMC, etc.)
   * @param hasher      hasher instance
   * @param logger      logger instance
   * @param readBuffer  buffer to be used for read caching
   * @param writeBuffer buffer to be used for write caching
   */
  static PSFLibrary* create(const std::shared_ptr<IIODriver>& driver,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
    const std::shared_ptr<buffer_base<char>>& readBuffer, const std::shared_ptr<buffer_base<char>>& writeBuffer);

  /** PSFLibrary creator method - UNBUFFERED
   * @param driver      IO driver (SD MMC, eMMC, etc.)
   * @param hasher      hasher instance
   * @param logger      logger instance
   */
  static PSFLibrary* create(const std::shared_ptr<IIODriver>& driver,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger);

  /** PSFLibrary creator method - BUFFERED
   * @param driver    IO driver (SD MMC, eMMC, etc.)
   * @param hasher    hasher instance
   * @param logger    logger instance
   * @param bufferSzHint  hint for I/O buffer size
   */
  static PSFLibrary* create(const std::shared_ptr<IIODriver>& driver,
    const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger,
  const size_t bufferSzHint);

  /**
   * Root I/O context getter
   * @return  root I/O context
   */
  FORCE_INLINE const std::shared_ptr<IIOContext>& getIOContext() const { return m_ioContext; }

  /**
   * Tries to restore library from the root I/O context
   * @return  true on success; false - otherwise
   */
  bool restore();

  /**
   * Creates library partitioning (volumes)
   * @param volumesConfigs volumes configurations
   * @param timer timer instance to be used for timestamps generation
   * @return  true on success; false - otherwise
   */
  bool format(const std::vector<sPSFVolumeConfig_t>& volumesConfigs, const std::shared_ptr<ITimer>& timer);

  /**
   * Lists all the volumes present in library
   * @param out  output array of volumes infos
   * @return    true on success; false - otherwise
   */
  bool listVolumes(std::vector<sVolumeInfo>& out) const;

  /**
   * Finds volume by it's label
   * @param label      volume's label to search in the library
   * @return        PSFVolume* instance on success; nullptr - otherwise
   */
  PSFVolume* findVolumeByLabel(const std::string& label) const;

  /**
   * Finds volume by it's ID
   * @param label      volume's label to search in the library
   * @return        PSFVolume* instance on success; nullptr - otherwise
   */
  PSFVolume* findVolumeByID(const uint32_t volumeId) const;

  /**
   * Gets volume by it's index
   * @param index    volume's index to search in the library
   * @return      PSFVOlume* instance on success; nullptr - otherwise
   */
  PSFVolume* getVolume(const uint32_t index) const;

  /**
   * Library's header getter
   * @return    library's header
   */
  FORCE_INLINE const sPSFLibraryHeader_t* getHeader() const { return m_header.ptr(); }

private:
  virtual bool _loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset) __OVERRIDES__(IPSFEntity);

  int _updateHash();

  /**
   * Creates volume with specified label and size in chapters and returns created volume size in chapters
   * @param info          volume's info
   * @param chapterIndex  chapter index to start volume at
   * @return              size (in chapters) of created volume. 0 - on failure
   */
  uint32_t _createVolumeAt(const sVolumeInfo& info, const uint32_t chapterIndex) const;

  /**
   * Gets volume at specified chapter index
   * @param chapterIndex  chapter index to fetch volume at
   * @return        PSFVolume* object on success; nullptr - on failure
   */
  PSFVolume* _getVolumeAt(const uint32_t chapterIndex) const;

  /**
   *  Checks library's header's integrity
   * @param header  library's header
   * @return      true on success; false - otherwise
   */
  bool _checkIntegrity(const sPSFLibraryHeader_t& header) const;

private:
  //! Library's header
  io_aligned_ptr<sPSFLibraryHeader_t> m_header;
  //! Library's root/main I/O context
  const std::shared_ptr<IIOContext> m_ioContext;
};

#endif //PSFLibrary_h__

