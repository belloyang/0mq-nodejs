#ifndef PSFDataElement_h__
#define PSFDataElement_h__

#include "../psflib_defines.h"
#include "IPSFEntity.h"
#include "buffers.h"

#include <IOContext/IIOContext.h>

#include <memory>
#include <string>

// forward declarations
class MemoryBufferIOContext;

/// <summary>
/// PSFDataElement. Represents PSF data element object.\n
/// Data Element spans to multiple integer count of pages. Payload (data) follows immediately after header data!
/// </summary>
class PSFDataElement : public IPSFEntity
{
public:
  /**
   * PSFDataElement constructor
   * @param hasher  hasher instance
   * @param logger  logger instance
   */
  PSFDataElement(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger);

  /**
   * PSFDataElement destructor
   */
  ~PSFDataElement() = default;

  /**
   * Inits DataElement with content (data). 'size' stands for content size in bytes (DataElement header is tolerated independently)
   * @param type    content data type
   * @param pData    content data
   * @param size    content data size
   * @return      total Data Element size (header + payload) in bytes
   */
  size_t init(const message_type_t type, const void* pData, const size_t size);

  /**
   * Tries to restore DataElement from context
   * @param sectionContext  section context that element is being restored from
   * @param offset      offset inside section context that element is being restored at
   * @return          total element size (in bytes)
   */
  size_t restore(const std::shared_ptr<IIOContext>& sectionContext, io_offset_t offset);

  /**
   * Section's header getter
   * @return  section's header
   */
  FORCE_INLINE const sPSFDataElementHeader_t* getHeader() const { return m_buffer->ptr<const sPSFDataElementHeader_t>(); }

  /**
   * Sequence number/index setter
   * @param number  sequence number to be set to data element
   */
  FORCE_INLINE void setSequenceNumber(const sequence_number_t number) { m_buffer->ptr<sPSFDataElementHeader_t>()->sequenceNumber = number; }

  /**
   * Previous data element offset setter
   * @param prevOffsetInPages    set offset to the previous data element (+, in pages)
   */
  FORCE_INLINE void setPrevOffset(const uint8_t prevOffsetInPages) { m_buffer->ptr<sPSFDataElementHeader_t>()->prev = prevOffsetInPages; }

  /**
   * Gets the pointer to internal data buffer (non-modifiable)
   * @param pData    pointer to the pointer to expose internal non-modifiable data
   * @return total DataElement size on success (in bytes); 0 - otherwise
   */
  size_t getData(const void** pData) const;
  
  /**
   * Gets the pointer to internal data buffer (modifiable)
   * @param pData    pointer to the pointer to expose internal modifiable data
   * @return total DataElement size on success (in bytes); 0 - otherwise
   */
  size_t getData(void** pData);

  /**
   * In-section offset getter
   * @return  offset (in bytes) in section context that Data Element starts at
   */
  FORCE_INLINE io_offset_t getInSectionOffset() const { return m_inSectionOffset; }
  
  /**
   * Checks if PSFDataElement is instance of the message
   * @param messageType message type to check
   * @return  true if PSFDataElement represents structure with message type, false - otherwise
   */
  FORCE_INLINE bool isInstanceOf(const message_type_t messageType) const { return (this->getHeader()->messageType == messageType); }

  /**
   * Dumps DataElement completely (header & data|payload)
   * @param sectionContext  section context to dump element to
   * @param offset      section context offset to dump data element at
   * @return          dumped data size (in bytes)
   */
  size_t dump(const std::shared_ptr<IIOContext>& sectionContext, io_offset_t offset);

  /**
   * Reserves/preallocates memory for data element
   * @param memorySizeInBytes memory size in bytes to preallocate
   * @return true on success, false - otherwise
  */
  bool reserveMemory(const uint32_t memorySizeInBytes);
  
  /**
   * Sets internal buffer for data element
   * @param buffer buffer to use internally
   */
  FORCE_INLINE void setBuffer(const std::shared_ptr<buffer_base<char>>& buffer) { m_buffer = buffer; }

private:
  virtual bool _loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset) __OVERRIDES__(IPSFEntity);

  void* _allocateBuffer(const size_t newSize);

  int _updateHash();
  bool _checkIntegrity(const void* pBuffer) const;

private:
  std::shared_ptr<buffer_base<char>> m_buffer;
  io_offset_t m_inSectionOffset; //in-section offset
  // memory buffer IO context for hasher to use; (re)init before each use in case 'm_bufferState' changes
  std::shared_ptr<MemoryBufferIOContext> m_hasherContext;
};

#endif //PSFDataElement_h__
