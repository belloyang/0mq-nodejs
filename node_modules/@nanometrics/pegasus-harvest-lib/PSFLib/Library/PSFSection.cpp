#include "PSFSection.h"

#include "PSFVolume.h"
#include "PSFDataElement.h"

#include <IOContext/MemoryBufferIOContext.h>
#include <IOContext/PartialIOContext.h>

#include <cinttypes>

PSFSection::iterator::iterator(const PSFSection* pSection, const uint32_t startPage)
  : m_pSection(pSection)
  , m_nextPage(startPage)
  , m_nextSequenceIndex(PSF_SEQUENCE_NUMBER_INVALID)
{
  __DEV_CALLSTACK_FUNC__;
  m_nextSequenceIndex = pSection->getHeader()->sequenceStart;
}

bool PSFSection::iterator::readNext(PSFDataElement& output)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_nextSequenceIndex == PSF_SEQUENCE_NUMBER_INVALID || m_nextSequenceIndex > m_pSection->getHeader()->sequenceEnd)
    return false;

  const io_offset_t inSectionOffset = PSF_PAGES_to_BYTES(m_nextPage);
  const size_t iRet = m_pSection->readDataElement(inSectionOffset, output);
  if (iRet > 0)  {
    m_nextPage += output.getHeader()->sizeInPages;
    m_nextSequenceIndex++;
    return true;
  }

  return false;
}


PSFSection::PSFSection(const PSFVolume* pVolume)
  : IPSFEntity(pVolume->getHasher(), pVolume->getLogger())
  , m_index(-1)
  , m_inVolumeOffset(0)
  , m_bIsHeaderUpToDate(true)
{
  __DEV_CALLSTACK_FUNC__;
  m_header->sequenceStart = m_header->sequenceEnd = PSF_SEQUENCE_NUMBER_INVALID;
  m_header->nextPage = 1; //1st page stands for the very first data element in section beginning (0th page is held by header page)
}

PSFSection::~PSFSection()
{
  __DEV_CALLSTACK_FUNC__;
  // if header hasn't been synced (predicate hasn't been raised after last element written) -> flush it now or data gets lost
  if (!m_bIsHeaderUpToDate)
  {
    this->_dumpHeader(m_sectionContext, 0);
  }
}

size_t PSFSection::create(const uint32_t sectionIndex, const std::shared_ptr<IIOContext>& context, io_offset_t offset, bool createContexts)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::discard header and dump it
  m_header.clear();
  m_header->sequenceStart = m_header->sequenceEnd = PSF_SEQUENCE_NUMBER_INVALID;
  m_header->nextPage = 1u; //1st page stands for the very first data element in section beginning (0th page is held by header page)
  //tss_psflib::dump header to section context beginning
  if (!this->_dumpHeader(context, offset))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_WRITING_FAILED,
      "Failed to create the section");
    return 0;
  }

  //tss_psflib::section created -> create section context (part of volume context that starts from offset and is 1 chapter big)
  m_bIsValid = true;
  m_index = sectionIndex;
  m_inVolumeOffset = offset;
  if (createContexts)
  {
    m_sectionContext = std::make_shared<PartialIOContext>(context,
      m_inVolumeOffset,
      PSF_CHAPTERS_to_BYTES(1), //each section spans exactly 1 chapter
      m_logger);
  }
  //tss_psflib::return section size (1 chapter)
  return PSF_CHAPTER_SIZE_BYTES;
}

bool PSFSection::createContexts(const std::shared_ptr<IIOContext>& context)
{
  __DEV_CALLSTACK_FUNC__;
  if (!m_bIsValid)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_RESTORING_FAILED,
        "Cannot create contexts. Section hasn't been created!");
    return false;
  }
  // create context
  m_sectionContext = std::make_shared<PartialIOContext>(context,
    m_inVolumeOffset,
    PSF_CHAPTERS_to_BYTES(1), //each section spans exactly 1 chapter
    m_logger);
  return true;
}

size_t PSFSection::restore(const uint32_t sectionIndex, const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRestored = this->_loadFromContext(context, offset);
  if (bRestored)
  {
    m_index = sectionIndex;
    //tss_psflib::section restored -> return it's size (1 chapter)
    return PSF_CHAPTER_SIZE_BYTES;
  }

  //tss_psflib::failed to restore section -> return 0
  return 0;
}

bool PSFSection::_loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  m_header->sequenceStart = m_header->sequenceEnd = PSF_SEQUENCE_NUMBER_INVALID;
  m_bIsValid = false;
  //tss_psflib::read header
  const size_t headerSize = context->readBlock(offset, m_header.size(), m_header.ptr());
  if (headerSize != m_header.size())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_RESTORING_FAILED,
      "Failed to restore header from context");
    return false;
  }

  //tss_psflib::check header's integrity
  if (!this->_checkIntegrity(*m_header))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_RESTORING_FAILED,
      "Section's header integrity check failed");
    return false;
  }

  //tss_psflib::section restored from context (save offset and create internal context)
  m_inVolumeOffset = offset;
  m_sectionContext = std::make_shared<PartialIOContext>(context,
    m_inVolumeOffset,
    PSF_CHAPTERS_to_BYTES(1), //each section spans exactly 1 chapter
    m_logger);
  m_bIsValid = true;
  m_bIsHeaderUpToDate = true;

  return true;
}

bool PSFSection::_dumpHeader(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::update section's hash
  this->_updateHash();
  const size_t dataWritten = context->writeBlock(offset, m_header.size(), m_header.ptr());
  if (dataWritten != m_header.size())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_WRITING_FAILED,
      "Header wasn't properly written (only %" PRIu32 "B) to IO context (hash=0x%08x)",
      static_cast<uint32_t>(dataWritten),
      m_header->hash.value);
    return false;
  }
  // flush section context
  context->flush();

  // mark section header as up-to-date
  m_bIsHeaderUpToDate = true;

  return true;
}

bool PSFSection::discard()
{
  __DEV_CALLSTACK_FUNC__;
  m_header.clear();
  m_header->sequenceStart = m_header->sequenceEnd = PSF_SEQUENCE_NUMBER_INVALID;
  m_header->nextPage = 1; //1st page (0th is held by header)
  this->_updateHash();
  return true;
}

bool PSFSection::canFitDataElement(const PSFDataElement* dataElement) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::calculate how many pages remain (total size(chapter size) - endPage - 1page(header))
  const size_t pagesRemain = PSF_CHAPTER_SIZE_PAGES - m_header->nextPage;
  const bool bRet = (dataElement->getHeader()->sizeInPages <= pagesRemain);
  return bRet;
}

bool PSFSection::containsDataElement(const sequence_number_t sequenceNumber) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!this->isEmpty())
  {
    const bool bRet = (sequenceNumber >= m_header->sequenceStart) && (sequenceNumber <= m_header->sequenceEnd);
    return bRet;
  }

  return false;
}

size_t PSFSection::writeDataElement(PSFDataElement* dataElement,
    const std::shared_ptr<IPSFSectionUpdateDelegate>& updateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(dataElement != nullptr && "Cannot dump NULL data element!");
  __ASSERT__(updateDelegate != nullptr && "section update delegate cannot be null");
  if (dataElement == nullptr)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
      "Cannot dump data element (ptr=%p). NULL or not initialized!!", dataElement);
    return 0;
  }

  __ASSERT__(this->canFitDataElement(dataElement) && "Data Element cannot fit into the section; canFitDataElement() should be called to check it");
  if (!this->canFitDataElement(dataElement))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
      "Data Element cannot fit into the section. Jump to the next section!!!");
    return 0;
  }

  //tss_psflib::dump data element at last section's page
  const size_t dataWritten = dataElement->dump(m_sectionContext, PSF_PAGES_to_BYTES(m_header->nextPage));
  const sPSFDataElementHeader_t* const deHeader = dataElement->getHeader();
  //tss_psflib::if data element written -> update section's header
  if (dataWritten > 0)
  {
#if defined(__DEBUG__) //PGFW-587, #4
    m_logger->debug(__THIS_FUNC__, "Dumped element (size=%" PRIu32 " pages, sequence=%" PRIu32 ", message_type=%" PRIu32 ", hash=0x%08x) at (section=%" PRIu32 ", page=%" PRIu32")",
      static_cast<uint32_t>(deHeader->sizeInPages),
      deHeader->sequenceNumber,
      static_cast<uint32_t>(deHeader->messageType),
      deHeader->hash.value,
      m_index,
      m_header->nextPage);
#endif //__DEBUG__
    // update other header's fields
    {
      // if this section was empty -> written element is the first one
      if (this->isEmpty())
      {
        m_header->sequenceStart = deHeader->sequenceNumber;
      }
      m_header->sequenceEnd = deHeader->sequenceNumber;
      m_header->nextPage += deHeader->sizeInPages;
      m_header->lastWrittenSize = deHeader->sizeInPages;
      // mark header as updated (not up-to-date)
      m_bIsHeaderUpToDate = false;
    }
    //tss_psflib::dump the header if predicate is not set at all or is raised
    if (updateDelegate->shouldUpdate(this, dataWritten))
    {
      // dump header (this method flushes the buffers to context as well)
      this->_dumpHeader(m_sectionContext, 0);
      // notify delegate that section header was updated
      updateDelegate->onSectionUpdated(this);
    }
    return dataWritten;
  }

  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
    "Failed to dump element (size=%" PRIu32 ", sequence=%" PRIu32 ") at (section=%" PRIu32 ", page=%" PRIu32 ")",
    static_cast<uint32_t>(deHeader->sizeInPages),
    deHeader->sequenceNumber,
    m_index,
    m_header->nextPage);
  return 0;
}

size_t PSFSection::readDataElement(const io_offset_t inSectionOffset, PSFDataElement& output) const
{
  __DEV_CALLSTACK_FUNC__;
  if (inSectionOffset >= m_sectionContext->getSize())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "Attempting to read DataElement out of section's context");
    return 0;
  }

  //tss_psflib::restoring data element from volume context (tolerate section offset (m_offset) + 1page(header) + requested offset(offset))
  const size_t bytesRead = output.restore(m_sectionContext, inSectionOffset);
  if (bytesRead <= 0)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "Failed to restore data element (offset=%" PRIu64 ") from section",
      inSectionOffset);
  }

  return bytesRead;
}

int PSFSection::_updateHash()
{
  __DEV_CALLSTACK_FUNC__;
  std::shared_ptr<IIOContext> headerMemContext = std::make_shared<MemoryBufferIOContext>(
    &m_header->sequenceStart, //skip m_hash field
    sizeof(sPSFSectionHeader_t) - sizeof(Hash32_t), //skip m_hash field
    m_logger);
  const int hashSize = m_hasher->getHash32(headerMemContext, m_header->hash);
  return hashSize;
}

bool PSFSection::_checkIntegrity(const sPSFSectionHeader_t& header) const
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRet = m_hasher->checkIntegrity(
    std::make_shared<MemoryBufferIOContext>(
      &header.sequenceStart, //skip m_hash field
      sizeof(sPSFSectionHeader_t) - sizeof(Hash32_t), //skip m_hash field
      m_logger),
    header.hash);
  if (!bRet)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_INTEGRITY_CHECK_FAILED,
      "Section's integrity check failed!");
  }

  return bRet;
}

size_t PSFSection::loadDataElement(const sequence_number_t sequenceNumber, PSFDataElement& output) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::check if section contains data element at all
  if (this->containsDataElement(sequenceNumber))
  {
    //tss_psflib::initial offset = 1page (right after section's header)
    io_offset_t dataElementOffset = PSF_PAGE_SIZE_BYTES; //set data element offset after section header
    while (true)
    {
      //tss_psflib::trying to restore data element from section context at current offset
      const size_t dataElementSize = output.restore(m_sectionContext, dataElementOffset);
      //tss_psflib::if dataElementSize > 0 - element was restored with success
      if (dataElementSize > 0)
      {
        const uint32_t dataElementSequenceNumber = output.getHeader()->sequenceNumber;
        //tss_psflib::check if data element's sequence number matches seeking one
        if (dataElementSequenceNumber == sequenceNumber)
          return PSF_PAGES_to_BYTES(output.getHeader()->sizeInPages);

        //tss_psflib::if current dataElement sequence number is bigger then seeking ->
        //no sense to keep on seeking because seeking data element hasn't been restored properly
        if (dataElementSequenceNumber > sequenceNumber)
          break;
      }
      else
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
          "Failed to read DataElement from section");
        break;
      }
      //tss_harv::jump to the next data element (adjust offset to skip read one)
      dataElementOffset += dataElementSize;
    }
  }

  //tss_psflib::notify (warn) that data element hasn't been found
  m_logger->warning(__THIS_FUNC__, "DataElement (sequence number=%" PRIu32 " not found in section", sequenceNumber);
  return 0;
}

PSFDataElement* PSFSection::findDataElement(const sequence_number_t sequenceNumber) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::check if section contains data element at all
  if (this->containsDataElement(sequenceNumber))
  {
    //tss_psflib::initial offset = 1page (right after section's header)
    io_offset_t dataElementOffset = PSF_PAGE_SIZE_BYTES; //set data element offset after section header
    PSFDataElement* const dataElement = new PSFDataElement(m_hasher, m_logger);
    while (true)
    {
      //tss_psflib::trying to restore data element from section context at current offset
      const size_t dataElementSize = dataElement->restore(m_sectionContext, dataElementOffset);
      //tss_psflib::if dataElementSize > 0 - element was restored with success
      if (dataElementSize > 0)
      {
        const sequence_number_t dataElementSequenceNumber = dataElement->getHeader()->sequenceNumber;
        //tss_psflib::check if data element's sequence number matches seeking one
        if (dataElementSequenceNumber == sequenceNumber)
          return dataElement;

        //tss_psflib::if current dataElement sequence number is bigger then seeking ->
        //no sense to keep on seeking because seeking data element hasn't been restored properly
        if (dataElementSequenceNumber > sequenceNumber)
          break;
      }
      else
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
          "Failed to read DataElement from section");
        break;
      }
      //tss_harv::jump to the next data element (adjust offset to skip read one)
      dataElementOffset += dataElementSize;
    }
    //tss_psflib::free object
    delete dataElement;
  }

  //tss_psflib::notify (warn) that data element hasn't been found
  m_logger->warning(__THIS_FUNC__, "DataElement (sequence number=%" PRIu32 " not found in section", sequenceNumber);
  return nullptr;
}

bool PSFSection::flush(const std::shared_ptr<IPSFSectionUpdateDelegate>& updateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(updateDelegate != nullptr && "updateDelegate cannot be null");
  // dump header
  if (!m_bIsHeaderUpToDate)
  {
    // dump header (flushes buffers to I/O context as well)
    if (this->_dumpHeader(m_sectionContext, 0))
    {
      // notify the delegate that section header has been updated
      updateDelegate->onSectionUpdated(this);
      return true;
    }
    // notify an error
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_WRITING_FAILED,
      "Failed to flush section!");
    return false;
  }
  // no need to flush -> return 'true' to indicate success (no error)
  return true;
}
