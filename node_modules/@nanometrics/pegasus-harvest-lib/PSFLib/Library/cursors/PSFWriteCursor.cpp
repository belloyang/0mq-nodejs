#include "PSFWriteCursor.h"

#include "../PSFVolume.h"
#include "../PSFSection.h"
#include "../PSFDataElement.h"

#include <cinttypes>

PSFWriteCursor::PSFWriteCursor(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger)
:  m_volume(volume)
,  m_logger(logger)
,  m_startSectionIndex(-1)
,  m_endSectionIndex(-1)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_volume != nullptr && "'volume' cannot be nullptr here");
  m_state.nextSeqNumber   = 0;
  m_state.currentPage     = 1;
  m_state.lastWrittenSize = 0;
  m_state.section         = std::make_shared<PSFSection>(m_volume);
}

void PSFWriteCursor::init(const uint32_t startSectionIndex, const uint32_t endSectionIndex)
{
  __DEV_CALLSTACK_FUNC__;
  m_startSectionIndex = startSectionIndex;
  m_endSectionIndex = endSectionIndex;
  // load section
  m_volume->loadSection(endSectionIndex, *m_state.section);
  // restore write position
  const sPSFSectionHeader_t* const pSectionHeader = m_state.section->getHeader();
  m_state.lastWrittenSize = pSectionHeader->lastWrittenSize;
  m_state.currentPage     = pSectionHeader->nextPage;
  m_state.nextSeqNumber   = pSectionHeader->sequenceEnd + 1;
}

uint32_t PSFWriteCursor::_gotoNextSection(const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  // flush current section before switching to the next one
  m_state.section->flush(sectionUpdateDelegate);
  // switch to the next section
  const uint32_t sectionIndex = m_state.section->getIndex();
  const uint32_t nSections = m_volume->getHeader()->sizeInChapters - 1;
  const uint32_t nextSectionIndex = (sectionIndex + 1) % nSections;
  m_volume->loadSection(nextSectionIndex, *m_state.section);
  m_state.currentPage = 1u; //set page to 1st (skip 0th for sections header)
  return nextSectionIndex;
}

size_t PSFWriteCursor::write(const message_type_t type, const void* pData, const size_t dataSize,
    const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  size_t bytesWritten = 0;
  // create PSFDataElement object
  PSFDataElement* const pDataElement = new PSFDataElement(m_volume->getHasher(), m_logger);
  if (pDataElement && pDataElement->init(type, pData, dataSize) > 0)
  {
    bytesWritten = this->write(pDataElement, sectionUpdateDelegate);
  }
  delete pDataElement;
  return bytesWritten;
}

size_t PSFWriteCursor::write(PSFDataElement* pDataElement,
    const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(pDataElement != nullptr && "Data Element is NULL!");
  if (pDataElement != nullptr)
  {
    // get the next sequence number for the new element
    pDataElement->setSequenceNumber(m_state.nextSeqNumber);
    // check if DataElement fits within the current section
    if (m_state.section->canFitDataElement(pDataElement))
    {
      // writing is performed within current section -> offset to previous = last written size
      pDataElement->setPrevOffset(m_state.lastWrittenSize);
      const size_t bytesWritten = m_state.section->writeDataElement(pDataElement, sectionUpdateDelegate);
      if (bytesWritten > 0)
      {
        m_state.nextSeqNumber++; // bump next sequence number
        m_state.lastWrittenSize = pDataElement->getHeader()->sizeInPages;
        m_state.currentPage += m_state.lastWrittenSize;
        return bytesWritten;
      }
    }
    else // writing should be done to the next section
    {
      // calculate offset from the section's end to the beginning of the last written element
      const uint8_t offsetToTheLastWritten = (uint8_t)(
          PSF_CHAPTER_SIZE_PAGES - (m_state.section->getHeader()->nextPage) + //pages remain
          m_state.section->getHeader()->lastWrittenSize); //last written data size

      // advance write to the next section
      m_endSectionIndex = this->_gotoNextSection(sectionUpdateDelegate);
      // check if start section is affected -> advance start section to the next one
      if (m_endSectionIndex == m_startSectionIndex)
      {
        const uint32_t nSections = m_volume->getHeader()->sizeInChapters - 1;
        m_startSectionIndex = (m_startSectionIndex + 1) % nSections;
      }

      // set offset to the previous data element (in the previous section =
      // offset to the element from the section end + 1 page (for current section's header))
      pDataElement->setPrevOffset(offsetToTheLastWritten + 1);

      // discard section (it will be overridden -> data should be discarded)
      m_state.section->discard();
      const size_t bytesWritten = m_state.section->writeDataElement(pDataElement, sectionUpdateDelegate);
      if (bytesWritten > 0)
      {
        m_state.nextSeqNumber++;
        m_state.lastWrittenSize = pDataElement->getHeader()->sizeInPages;
        m_state.currentPage += m_state.lastWrittenSize;
        return bytesWritten;
      }
    }
  }

  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_WRITING_FAILED,
    "Failed to dump data element to volume");
  return 0;
}

bool PSFWriteCursor::flush(const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate)
{
  __DEV_CALLSTACK_FUNC__;
  // flush current section
  return m_state.section->flush(sectionUpdateDelegate);
}
