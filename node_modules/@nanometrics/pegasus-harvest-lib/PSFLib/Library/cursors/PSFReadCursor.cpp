#include "PSFReadCursor.h"

#include "../PSFVolume.h"
#include "../PSFSection.h"
#include "../PSFDataElement.h"

#include <cinttypes>

PSFReadCursor::PSFReadCursor(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger)
:  m_volume(volume)
,  m_logger(logger)
,  m_startSectionIndex(-1)
,  m_endSectionIndex(-1)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_volume != nullptr && "'volume' cannot be nullptr here");
  m_state.sequenceNumber = 0;
  m_state.currentPage = 1;
  m_state.prevElementSize = 0;
  m_state.isInvalid = true;
  m_state.section = std::make_shared<PSFSection>(m_volume);
}

void PSFReadCursor::init(const uint32_t startSectionIndex, const uint32_t endSectionIndex)
{
  __DEV_CALLSTACK_FUNC__;
  m_startSectionIndex = startSectionIndex;
  m_endSectionIndex = endSectionIndex;
  // load section
  m_volume->loadSection(startSectionIndex, *m_state.section);
  m_state.sequenceNumber = m_state.section->getHeader()->sequenceStart; //start reading from the first element in the section
  m_state.currentPage = 1; //skip 0th page (section's header)
  m_state.prevElementSize = 0;
  m_state.isInvalid = false;
}

void PSFReadCursor::invalidate(uint32_t startSectionIndex, uint32_t endSectionIndex)
{
  __DEV_CALLSTACK_FUNC__;
  // check if reading (reading section) is affected by writing operation and mark cursor as invalid
  if (m_state.section->getIndex() == endSectionIndex)
    m_state.isInvalid = true;

  // set sections info
  m_startSectionIndex = startSectionIndex;
  m_endSectionIndex = endSectionIndex;
}

bool PSFReadCursor::is_eof() const
{
  __DEV_CALLSTACK_FUNC__;
  if (m_state.section == nullptr)
    return true;

  const sPSFSectionHeader_t* const sHeader = m_state.section->getHeader();
  // if sequenceEnd is not set (-1) -> it means that section is empty
  if (sHeader->sequenceEnd == PSF_SEQUENCE_NUMBER_INVALID)
    return true;

  // if read cursor is in the end_section and sequence number to read is bigger then section sequenceEnd
  //-> last element has been read
  if (m_state.section->getIndex() == m_endSectionIndex && sHeader->sequenceEnd < m_state.sequenceNumber)
    return true;

  return false;
}

bool PSFReadCursor::is_bof() const
{
  __DEV_CALLSTACK_FUNC__;
  if (m_state.section == nullptr)
    return true;

  //tss_psflib::if prev_element_size == 0 -> it means that read hasn't been done yet -> it's Begin-of-Stream
  if (m_state.prevElementSize == 0)
    return true;

  // if current reading section == start_section and previous element is stored within the previous section
  // the volume has been ring-buffered that current element points to the element in the overridden section
  if (m_state.section->getIndex() == m_startSectionIndex && m_state.currentPage <= m_state.prevElementSize)
    return true;

  //tss_psflib::Begin-of-Stream conditions are not met
  return false;
}

sequence_number_t PSFReadCursor::seek(const sequence_number_t sequenceIndex)
{
  __DEV_CALLSTACK_FUNC__;
  // small check to avoid unnecessary seek
  if (m_state.sequenceNumber == sequenceIndex)
    return sequenceIndex;

  // find section that contains data element with sequence index
  PSFSection* const section = m_volume->findSectionBySequenceNumber(sequenceIndex);
  if (section != nullptr)
  {
    // find data element in the section by index
    PSFDataElement* const pDataElement = section->findDataElement(sequenceIndex);
    if (pDataElement != nullptr)
    {
      // reset READ-cursor state
      m_state.section.reset(section);
      m_state.currentPage = static_cast<uint32_t>(pDataElement->getInSectionOffset() / PSF_PAGE_SIZE_BYTES);
      m_state.sequenceNumber = sequenceIndex;

      const uint8_t offsetToPrev = pDataElement->getHeader()->prev;
      // check if previous element stored within current section
      if (m_state.currentPage >= offsetToPrev)
      {
        m_state.prevElementSize = offsetToPrev;
      }
      else
      {
        __ASSERT__(m_state.currentPage == 1 &&
            "previous element can be in the previous section only for the very first element in this section (commences at 1st page - right after the header)");
        m_state.prevElementSize = offsetToPrev - 1; //prev element size = offset from current - 1 (for sections header)
        //NOTE::though it's size from the last element in the previous section till section end - it's fine for navigation/iterating
      }
      delete pDataElement;
      return sequenceIndex;
    }
  }

  // failed to seek sequence index -> return invalid
  return PSF_SEQUENCE_NUMBER_INVALID;
}

uint32_t PSFReadCursor::_gotoNextSection()
{
  __DEV_CALLSTACK_FUNC__;
  const uint32_t currentIndex = m_state.section->getIndex();
  const uint32_t nSections = m_volume->getHeader()->sizeInChapters - 1;
  const uint32_t nextSectionIndex = (currentIndex + 1) % nSections;
  m_volume->loadSection(nextSectionIndex, *m_state.section);
  // set read cursor before the very first data element in the section (starts from 1st page after header's page)
  m_state.currentPage = 1u;
  return nextSectionIndex;
}
uint32_t PSFReadCursor::_gotoPrevSection()
{
  __DEV_CALLSTACK_FUNC__;
  const uint32_t currentIndex = m_state.section->getIndex();
  const uint32_t nSections = m_volume->getHeader()->sizeInChapters - 1;
  const uint32_t prevSectionIndex = (currentIndex - 1 + nSections) % nSections;
  m_volume->loadSection(prevSectionIndex, *m_state.section);
  // set read cursor before the last element in the section
  const sPSFSectionHeader_t* const pSectionHeader = m_state.section->getHeader();
  m_state.currentPage = pSectionHeader->nextPage - pSectionHeader->lastWrittenSize;
  return prevSectionIndex;
}

size_t PSFReadCursor::readNext(PSFDataElement& output)
{
  __DEV_CALLSTACK_FUNC__;
  // if cursor is invalid -> reset it
  if (m_state.isInvalid)
    this->init(m_startSectionIndex, m_endSectionIndex);

  if (this->is_eof())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "EOF for reading reached! Cannot read anything furthermore!");
    return 0;
  }

  // read Data element from section
  const size_t bytesRead = m_state.section->readDataElement(PSF_PAGES_to_BYTES(m_state.currentPage), output);
  if (bytesRead > 0)
  {
    m_state.sequenceNumber = output.getHeader()->sequenceNumber + 1; //set read cursor to the next sequence number
    m_state.prevElementSize = output.getHeader()->sizeInPages;
    m_state.currentPage += m_state.prevElementSize;
    // check if the next element is in the next section
    if (!m_state.section->containsDataElement(m_state.sequenceNumber))
    {
      // if reading was done  not in the endSection -> advance to the next section
      if (m_state.section->getIndex() != m_endSectionIndex)
      {
        this->_gotoNextSection();
      }
      else // reading was done in the endSection, so eof reached -> increase sequence number so it's bigger then endSection->m_lastSequenceIndex
        //-> eof check will return true on the next call
      {
        m_logger->debug(__THIS_FUNC__, "Last element was read -> eof reached (section=%" PRIu32 ", sequence_number=%" PRIu32 ", page=%" PRIu32,
            m_state.section->getIndex(),
            m_state.sequenceNumber,
            m_state.currentPage);
      }
    }
  }

  return bytesRead;
}

size_t PSFReadCursor::readPrev(PSFDataElement& output)
{
  __DEV_CALLSTACK_FUNC__;
  if (m_state.isInvalid)
    this->init(m_startSectionIndex, m_endSectionIndex);

  if (this->is_bof())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED,
      "BOF for reading reached! Cannot read anything backward!");
    return 0;
  }

  size_t bytesRead = 0;
  // check if previous element is stored within current section
  if (m_state.section->containsDataElement(m_state.sequenceNumber - 1))
  {
    // get page to read the element before read cursor
    const size_t prevElementStartPage = m_state.currentPage - m_state.prevElementSize;
    bytesRead = m_state.section->readDataElement(PSF_PAGES_to_BYTES(prevElementStartPage), output);
    if (bytesRead > 0)
    {
      m_state.sequenceNumber--;
      // advance read cursor (reading page)
      m_state.currentPage = prevElementStartPage;
    }
  }
  else // previous element is in the previous section
  {
    // reset cursor to previous section
    this->_gotoPrevSection();
    bytesRead = m_state.section->readDataElement(PSF_PAGES_to_BYTES(m_state.currentPage), output);
    if (bytesRead > 0)
    {
      m_state.sequenceNumber--;
    }
  }

  // recalculate prev element size
  if (bytesRead > 0)
  {
    const uint8_t offsetToPrev = output.getHeader()->prev;
    // check if previous element stored within current section
    if (m_state.currentPage >= offsetToPrev)
    {
      m_state.prevElementSize = offsetToPrev;
    }
    else
    {
      __ASSERT__(m_state.currentPage == 1 &&
          "previous element can be in the previous section only for the very first element in this section (element that starts from 1st page (after header page)");
      m_state.prevElementSize = offsetToPrev - 1; //prev element size = offset from current - 1 (for sections header)
      //NOTE::though it's size from the last element in the previous section till section end - it's fine for navigation/iterating
    }
  }

  return bytesRead;
}

void PSFReadCursor::push()
{
  __DEV_CALLSTACK_FUNC__;
  m_statesStack.push(m_state);
}

void PSFReadCursor::pop()
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(!m_statesStack.empty() && "stack is empty. pop/push calls mismtach");
  m_state = m_statesStack.top();
  m_statesStack.pop();
}
