#ifndef PSFReadCursor_h__
#define PSFReadCursor_h__

#include "../../psflib_defines.h"

#include <Logger/ILogger.h>

#include <memory>
#include <stack>

class PSFVolume;
class PSFSection;
class PSFDataElement;

/**
 * Read cursor
 */
class PSFReadCursor
{
public:
  typedef struct 
  {
    std::shared_ptr<PSFSection> section;
    sequence_number_t sequenceNumber; //last read element sequence number
    uint32_t currentPage; //in-section offset (in pages)
    uint8_t  prevElementSize; //previous element size (in pages)
    bool     isInvalid; //specifies if cursor is invalid (has been affected by write)
  } sCursorState;

  /**
   * PSFReadCursor constructor
   * @param volume  volume that is held by this object
   * @param logger  logger instance
   */
  PSFReadCursor(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger);
  /**
   * PSFReadCursor desturctor
   */
  ~PSFReadCursor() = default;

  /**
   * Inits read cursor
   * @param startSectionIndex   start section (the section that has the lowest sequence number)
   * @param endSectionIndex     end section (section with the highest sequence number -> current writing section)
   */
  void init(const uint32_t startSectionIndex, const uint32_t endSectionIndex);
  /**
   * Invalidates read cursor considering new start and end section indices
   * @param startSectionIndex new start section index
   * @param endSectionIndex   new end section index
   */
  void invalidate(uint32_t startSectionIndex, uint32_t endSectionIndex);

  /**
   * 'End-of-File' checker
   * @return if end of file (end of volume) reached
   */
  bool is_eof() const;
  /**
   * 'Begin-of-File' checker
   * @return if read cursor set to the beginning of the volume
   */
  bool is_bof() const;
  /**
   * Sets read cursor before data element with specified sequence index
   * @param sequenceIndex data element sequence index to set cursor before
   * @return  sequenceIndex on success, -1 - on failure
   */
  sequence_number_t seek(const sequence_number_t sequenceIndex);
  /**
   * Tells current read cursor position (Data element sequence index that read cursor is set to)
   * @return  data element sequence index that cursor is set to
   */
  FORCE_INLINE sequence_number_t tell() const { return m_state.sequenceNumber; }

  /**
   * Reads next data element from volume and advances reading cursor to the next position
   * @param output  read PSFDataElement
   * @return  amount of bytes read
   */
  size_t readNext(PSFDataElement& output);
  /**
   * Reads previous data element from volume and advances reading cursor to the previous position
   * @param output  read PSFDataElement
   * @return  amount of bytes read
   */
  size_t readPrev(PSFDataElement& output);

  /**
   * Cursor state getter
   * @return cursor state
   */
  FORCE_INLINE const sCursorState& getState() const { return m_state; }

  /**
   * Pushes state to stack. NOTE!: this method relies on dynamic memory allocation
   */
  void push();
  /**
   * Restores state from stack. NOTE!: this method relies on dynamic memory allocation
   */
  void pop();

private:
  uint32_t _gotoNextSection();
  uint32_t _gotoPrevSection();

private:
  const PSFVolume* m_volume;
  const std::shared_ptr<ILogger> m_logger;
  sCursorState m_state;
  std::stack<sCursorState> m_statesStack; // states stack; relies on dynamic memory allocation!
  uint32_t m_startSectionIndex;
  uint32_t m_endSectionIndex;
};

#endif //PSFReadCursor_h__
