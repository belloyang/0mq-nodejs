#ifndef PSFWriteCursor_h__
#define PSFWriteCursor_h__

#include "../../psflib_defines.h"
#include "../IPSFSectionUpdateDelegate.h"

#include <Logger/ILogger.h>
#include <memory>

class PSFVolume;
class PSFSection;
class PSFDataElement;

/**
 * Write cursor
 */
class PSFWriteCursor
{
public:
  typedef struct
  {
    std::shared_ptr<PSFSection> section;
    sequence_number_t nextSeqNumber;     // next sequence number to use
    uint32_t currentPage;                // in section offset (in pages) that cursor is set at
    uint8_t  lastWrittenSize;            // last written element size
  } sCursorState;

  /**
   * PSFWriteCursor constructor
   * @param volume  volume that is held by this object
   * @param logger  logger instance
   */
  PSFWriteCursor(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger);
  /**
   * PSFWriteCursor destructor
   */
  ~PSFWriteCursor() = default;

  /**
   * Inits write cursor
   * @param startSectionIndex   start section (the section that has the lowest sequence number)
   * @param endSectionIndex     end section (section with the highest sequence number -> current writing section)
   */
  void init(const uint32_t startSectionIndex, const uint32_t endSectionIndex);

  /**
   * Writes data to volume
   * @param type      data type
   * @param pData     data buffer
   * @param dataSize  data buffer size
   * @return amount of bytes written to volume (0 - on failure)
   */
  size_t write(const message_type_t type, const void* pData, const size_t dataSize,
		  const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate);
  /**
   * Writes PSFDataElement to volume
   * @param pDataElement  data element to write
   * @return amount of bytes written to volume (0 - on failure)
   */
  size_t write(PSFDataElement* pDataElement,
      const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate);

  /**
   * Tells sequence number for the next element to be written
   * @return sequence number for the next element to be written
   */
  FORCE_INLINE sequence_number_t tell() const { return m_state.nextSeqNumber; }

  /**
   * Start section index getter
   * @return  start section index
   */
  FORCE_INLINE uint32_t getStartSectionIndex() const { return m_startSectionIndex; }
  /**
   * End section index getter
   * @return  end section index
   */
  FORCE_INLINE uint32_t getEndSectionIndex() const { return m_endSectionIndex; }

  /**
   * Cursor state getter
   * @return cursor state
   */
  FORCE_INLINE const sCursorState& getState() const { return m_state; }

  /**
   * Flushes data to underlying context
   */
  bool flush(const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate);

private:
  uint32_t _gotoNextSection(const std::shared_ptr<IPSFSectionUpdateDelegate>& sectionUpdateDelegate);

private:
  const PSFVolume* m_volume;
  const std::shared_ptr<ILogger> m_logger;
  sCursorState m_state;
  uint32_t m_startSectionIndex;
  uint32_t m_endSectionIndex;
};

#endif //PSFWriteCursor_h__
