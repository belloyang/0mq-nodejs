#include "PSFStream.h"

#include "PSFVolume.h"
#include "PSFSection.h"
#include "PSFDataElement.h"

#include "search/SearchEngine.h"
#include "search/MaxSequenceEndDichotomiser.h"
#include "search/MinSequenceEndDichotomiser.h"

#include "PSFSectionUpdateDelegate_Always.h"

#include <cinttypes>

PSFStream::PSFStream(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger)
:  m_logger(logger)
,  m_volume(volume)
,  m_sectionUpdateDelegate(std::make_shared<PSFSectionUpdateDelegate_Always>(logger))
,  m_readCursor(volume, logger)
,  m_writeCursor(volume, logger)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_volume != nullptr && "'volume' cannot be nullptr here! Stream should be opened for existing volume!");
  const sPSFVolumeHeader_t* const vHeader = m_volume->getHeader();
  SearchEngine searchEngine;
  // restore the very first and last sections
  const uint32_t minSectionIndex = searchEngine.dichotomySearch(0, vHeader->sizeInChapters - 2,
      std::make_shared<MinSequenceEndDichotomiser>(m_volume, m_logger));
  const uint32_t maxSectionIndex = searchEngine.dichotomySearch(0, vHeader->sizeInChapters - 2,
      std::make_shared<MaxSequenceEndDichotomiser>(m_volume, m_logger));
  // init cursors
  m_writeCursor.init(minSectionIndex, maxSectionIndex);
  m_readCursor.init(minSectionIndex, maxSectionIndex);
  // print info about restored read cursor
  const PSFReadCursor::sCursorState& readCursor = m_readCursor.getState();
  m_logger->debug(__THIS_FUNC__, "'%.*s' read cursor restored:  @(section=%" PRIu32 ", page=%" PRIu32 ", sequence_number=%" PRIu32")",
      NUM_ELEMENTS(vHeader->label), vHeader->label,
      minSectionIndex, readCursor.currentPage, readCursor.sequenceNumber);
  // print info about restored write cursor
  const PSFWriteCursor::sCursorState& writeCursor = m_writeCursor.getState();
  m_logger->debug(__THIS_FUNC__, "'%.*s' write cursor restored: @(section=%" PRIu32 ", page=%" PRIu32 ", next_seq_number=%" PRIu32")",
      NUM_ELEMENTS(vHeader->label), vHeader->label,
      maxSectionIndex, writeCursor.currentPage, writeCursor.nextSeqNumber);
}

size_t PSFStream::write(const message_type_t type, const void* pData, const size_t dataSize)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t ret = m_writeCursor.write(type, pData, dataSize, m_sectionUpdateDelegate);
  // writing may affect reading cursor -> invalidate it
  m_readCursor.invalidate(m_writeCursor.getStartSectionIndex(), m_writeCursor.getEndSectionIndex());
  return ret;
}

bool PSFStream::is_eof() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.is_eof();
}

bool PSFStream::is_bof() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.is_bof();
}

size_t PSFStream::write(PSFDataElement* pDataElement)
{
  __DEV_CALLSTACK_FUNC__;
  return m_writeCursor.write(pDataElement, m_sectionUpdateDelegate);
}

size_t PSFStream::readNext(PSFDataElement& output)
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.readNext(output);
}

size_t PSFStream::readPrev(PSFDataElement& output)
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.readPrev(output);
}

sequence_number_t PSFStream::rseek(const sequence_number_t sequenceIndex)
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.seek(sequenceIndex);
}

sequence_number_t PSFStream::rseek_end()
{
  __DEV_CALLSTACK_FUNC__;
  if (!this->is_eof())
  {
    // get current write cursor (specifies the sequence number for the new element to be written)
    const sequence_number_t writeCursor = m_writeCursor.tell();
    if (writeCursor != PSF_SEQUENCE_NUMBER_INVALID)
    {
      // get sequence number of the latest written element
      const sequence_number_t lastSequenceNumber = writeCursor - 1;
      m_logger->debug(__THIS_FUNC__, "Latest written element sequence number = %" PRIu32, lastSequenceNumber);
      // create data element to read the latest PSF entity on the volume
      PSFDataElement dataElement(m_volume->getHasher(), m_volume->getLogger());
      // set read cursor to (right before) the latest element in the volume
      m_readCursor.seek(lastSequenceNumber);
      // read latest element -> read cursor fetches all required navigation data and point to eof now
      m_readCursor.readNext(dataElement);
    }
  }
  return m_readCursor.tell();
}

sequence_number_t PSFStream::rtell() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_readCursor.tell();
}

void PSFStream::rpush()
{
  __DEV_CALLSTACK_FUNC__;
  m_readCursor.push();
}

void PSFStream::rpop()
{
  __DEV_CALLSTACK_FUNC__;
  m_readCursor.pop();
}

sequence_number_t PSFStream::wtell() const
{
  __DEV_CALLSTACK_FUNC__;
  return m_writeCursor.tell();
}

bool PSFStream::flush()
{
  __DEV_CALLSTACK_FUNC__;
  return m_writeCursor.flush(m_sectionUpdateDelegate);
}
