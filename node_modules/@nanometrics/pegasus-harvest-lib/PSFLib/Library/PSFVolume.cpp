#include "PSFVolume.h"

#include <IOContext/MemoryBufferIOContext.h>
#include <IOContext/PartialIOContext.h>
#include <IOContext/RingBufferIOContext.h>

#include "search/SearchEngine.h"
#include "search/SearchSequenceNumberDichotomiser.h"

#include <cinttypes> // PRIu64

PSFVolume::PSFVolume(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger)
  : IPSFEntity(hasher, logger)
  , m_headerContext(nullptr)
  , m_dataContext(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  this->_updateHash();
}

bool PSFVolume::init(const VolumeLabel_t label, uint32_t uniqueId, uint32_t sizeInChapters)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::chapter size checks
  if (sizeInChapters < 2)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
      "Volume size in chapters should be >= 2 (1 chapter for header, the rest for data");
    return false;
  }
  if (sizeInChapters > PSF_MAX_VOLUME_SIZE_CHAPTERS)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
      "Volume size (%" PRIu32 " chapters) exceeds maximum allowed size (%" PRIu32 " chapters)",
      sizeInChapters,
      static_cast<uint32_t>(PSF_MAX_VOLUME_SIZE_CHAPTERS));
    return false;
  }

  //tss_psflib::init header
  ::memcpy(m_header->label, label, sizeof(VolumeLabel_t));
  m_header->uniqueId = uniqueId;
  m_header->sizeInChapters = sizeInChapters;
  this->_updateHash();
  return true;
}

uint32_t PSFVolume::create(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_fslib::dump header
  if (this->_dumpHeader(context, offset))
  {
    //tss_psflib::header dumped with success -> create contexts
    this->_createContexts(context, offset);

    //tss_psflib::create sections in DataContext (header section is handled by headerContext -> start from 0 offset)
    io_offset_t sectionOffset = 0;
    std::shared_ptr<PSFSection> section = std::make_shared<PSFSection>(this);
    for (uint32_t index = 0; index < m_header->sizeInChapters - 1; index++)
    {
      //tss_psflib::create empty sections (do not create contexts)
      sectionOffset += section->create(index, m_dataContext, sectionOffset, false);
    }
    m_bIsValid = true;
    return m_header->sizeInChapters;
  }

  //tss_psflib::failed to dump header -> return error
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED, 
    "Failed to dump volume's header");
  m_bIsValid = false;
  return 0;
}

uint64_t PSFVolume::restore(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRestored = this->_loadFromContext(context, offset);
  if (bRestored)
  {
    m_bIsValid = true;
    //tss_psflib::return volume size in bytes
    return PSF_SECTIONS_to_BYTES(m_header->sizeInChapters);
  }

  //tss_psflib::failed to restore volume -> return 0
  return 0UL;
}

bool PSFVolume::erase()
{
  __DEV_CALLSTACK_FUNC__;
  if ((m_headerContext == nullptr) || (m_dataContext == nullptr))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
      "Cannot erase volume that hasn't been created");
    return false;
  }

  //tss_psflib::create sections in DataContext (header section is handled by headerContext -> start from 0 offset)
  io_offset_t sectionOffset = 0;
  std::shared_ptr<PSFSection> section = std::make_shared<PSFSection>(this);
  for (uint32_t index = 0; index < m_header->sizeInChapters - 1; index++)
  {
    //tss_psflib::create empty sections (do not create contexts)
    sectionOffset += section->create(index, m_dataContext, sectionOffset, false);
  }
  m_bIsValid = true;
  return true;
}

bool PSFVolume::_loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  io_aligned_ptr<sPSFVolumeHeader_t> header;
  if (context->readBlock(offset, header.size(), header.ptr()) != header.size())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_RESTORING_FAILED, 
      "Failed to restore volume's header");
    return false;
  }

  //tss_psflib::check header integrity
  if (!this->_checkIntegrity(*header))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_RESTORING_FAILED,
      "Volume's integrity check failed!");
    return false;
  }

  //tss_psflib::load header to m_header
  m_header.load(header.ptr());
  //tss_psflib::create contexts (for header & for data)
  this->_createContexts(context, offset);
  return true;
}

void PSFVolume::_createContexts(const std::shared_ptr<IIOContext>& baseContext, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::create header context with respect to global context offset (spans 1 chapter)
  const io_offset_t volumeSize = PSF_SECTIONS_to_BYTES(m_header->sizeInChapters);
  m_headerContext = std::make_shared<PartialIOContext>(baseContext,
    offset, //header commences at offset
    PSF_CHAPTER_SIZE_BYTES, //1 chapter reserved for header
    m_logger);

  //tss_psflib::create data context (ring buffer) (volumeSize - 1chapter for header)
  const io_offset_t dataSize = volumeSize - PSF_CHAPTER_SIZE_BYTES;
  m_dataContext = std::make_shared<RingBufferIOContext>(
    std::make_shared<PartialIOContext>(baseContext,
      offset + PSF_CHAPTER_SIZE_BYTES, //data commences after header
      dataSize,  //data size
      m_logger),
    m_logger);
}

bool PSFVolume::_dumpHeader(const std::shared_ptr<IIOContext>& context, io_offset_t offset)
{
  __DEV_CALLSTACK_FUNC__;
  const size_t dataWritten = context->writeBlock(offset, m_header.size(), m_header.ptr());
  if (dataWritten != m_header.size())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_WRITING_FAILED,
      "Header wasn't properly written (only %" PRIu32 "B) to IO context (hash=0x%08x)",
      static_cast<uint32_t>(dataWritten),
      m_header->hash.value);
    return false;
  }
  return true;
}

int PSFVolume::_updateHash()
{
  __DEV_CALLSTACK_FUNC__;
  std::shared_ptr<IIOContext> headerMemContext = std::make_shared<MemoryBufferIOContext>(
    &m_header->uniqueId, //skip m_hash field
    sizeof(sPSFVolumeHeader_t) - sizeof(Hash32_t), //skip m_hash field
    m_logger);
  const int hashSize = m_hasher->getHash32(headerMemContext, m_header->hash);
  return hashSize;
}

bool PSFVolume::_checkIntegrity(const sPSFVolumeHeader_t& header) const
{
  __DEV_CALLSTACK_FUNC__;
  const bool bRet = m_hasher->checkIntegrity(
    std::make_shared<MemoryBufferIOContext>(
      &header.uniqueId, //skip m_hash field
      sizeof(sPSFVolumeHeader_t) - sizeof(Hash32_t), //skip m_hash field
      m_logger),
    header.hash);
  if (!bRet)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_VOLUME_INTEGRITY_CHECK_FAILED,
      "Volume's integrity check failed!");
  }
  return bRet;
}

bool PSFVolume::loadSection(const uint32_t sectionIndex, PSFSection& output) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::check sectionIndex boundaries
  if (sectionIndex >= static_cast<uint32_t>(m_header->sizeInChapters - 1))
    return false;

  //tss_psflib::get section offset in DataContext (no header counted)
  const io_offset_t sectionOffset = PSF_SECTIONS_to_BYTES(sectionIndex);
  if (output.restore(sectionIndex, m_dataContext, sectionOffset) > 0)
    return true;

  //tss_psflib::notify that section wasn't loaded
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_SECTION_RESTORING_FAILED,
    "Failed to load volume(%.*s) section (%" PRIu32 ")",
    NUM_ELEMENTS(m_header->label), m_header->label,
    sectionIndex);
  return false;
}

PSFSection* PSFVolume::findSectionBySequenceNumber(const sequence_number_t sequenceNumber) const
{
  __DEV_CALLSTACK_FUNC__;
  //tss_psflib::seek active section using search engine
  const size_t sectionIndex = SearchEngine().dichotomySearch(
    0, m_header->sizeInChapters - 2,
    std::make_shared<SearchSequenceNumberDichotomiser>(this, sequenceNumber, m_logger));
  //tss_psflib:: if section found -> return it
  if (sectionIndex != ((size_t)-1))
  {
    PSFSection* const pSection = new PSFSection(this);
    if (this->loadSection(sectionIndex, *pSection))
      return pSection;
    delete pSection;
  }

  m_logger->warning(__THIS_FUNC__, "Section that contains %" PRIu32 " sequence NOT found", sequenceNumber);
  return nullptr;
}
