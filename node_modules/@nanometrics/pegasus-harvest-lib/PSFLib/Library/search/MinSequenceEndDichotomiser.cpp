#include "MinSequenceEndDichotomiser.h"

#include "../PSFVolume.h"
#include "../PSFSection.h"

MinSequenceEndDichotomiser::MinSequenceEndDichotomiser(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger)
:  IDichotomiser(logger)
,  m_volume(volume)
,  m_fromSection(nullptr)
,  m_toSection(nullptr)
,  m_middleSection(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_volume != nullptr && "'volume' cannot be nullptr here");
  m_fromSection = new PSFSection(m_volume);
  m_toSection = new PSFSection(m_volume);
  m_middleSection = new PSFSection(m_volume);
}

MinSequenceEndDichotomiser::~MinSequenceEndDichotomiser()
{
  __DEV_CALLSTACK_FUNC__;
  delete m_fromSection;
  delete m_toSection;
  delete m_middleSection;
}

bool MinSequenceEndDichotomiser::isLess(const PSFSection* pSection1, const PSFSection* pSection2) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!pSection2->isValid() || pSection2->isEmpty())
    return true;
  if (!pSection1->isValid() || pSection1->isEmpty())
    return false;
  return pSection1->getHeader()->sequenceEnd <= pSection2->getHeader()->sequenceEnd;
}

bool MinSequenceEndDichotomiser::shrinkRange(size_t from, size_t to, size_t& newFrom, size_t& newTo) const
{
  __DEV_CALLSTACK_FUNC__;
  if (to == from)
  {
    newFrom = from;
    newTo = to;
    return true;
  }

  m_volume->loadSection(from, *m_fromSection);
  m_volume->loadSection(to , *m_toSection);

  //tss_psflib::if both sections are empty -> return "from" section
  if (m_toSection->isEmpty() && m_fromSection->isEmpty())
  {
    newFrom = newTo = from;
    return true;
  }

  //tss_psflib::check if sections are neighbours and chose the best one
  if (to - from == 1)
  {
    if (this->isLess(m_fromSection, m_toSection))
    {
      newFrom = newTo = from;
    }
    else
    {
      newFrom = newTo = to;
    }
    return true;
  }

  const size_t middle = (from + to) >> 1;

  //0) (from)...(middle)....(to)
  //1) (0) 1  2  3  (4)  _  _  _  (_) - no ring-buffered volume (with empty sections)
  //2) (0) 1  2  3  (4)  5  6  7  (8) - no ring-buffered volume (filled)
  //3) (9) 10 2  3  (4)  5  6  7  (8) - ring-buffered volume
  //4) (12)13 14 15 (16) 17 6  7  (8) - ring-buffered volume

  //tss_psflib::if "from" section is less then "to" section - sections are in ascending order -> "from" is minimal section (1) or (2)
  if (this->isLess(m_fromSection, m_toSection))
  {
    newFrom = newTo = from;
  }
  //tss_psflib:: "from" section is bigger then "to" section -> looped in between - (3) or (4) variants
  else
  {
    m_volume->loadSection(middle, *m_middleSection);
    //tss_psflib:: if "from" section is less then "middle section" -> (4) variant (looping is done in [middle, to])
    if (this->isLess(m_fromSection, m_middleSection))
    {
      //look in [middle, to]
      newFrom = middle;
      newTo = to;
    }
    else //tss_psflib::(3) variant
    {
      //look in [from, middle]
      newFrom = from;
      newTo = middle;
    }
  }

  return true;
}
