#include "SearchSequenceNumberDichotomiser.h"

#include "../PSFVolume.h"
#include "../PSFSection.h"

SearchSequenceNumberDichotomiser::SearchSequenceNumberDichotomiser(const PSFVolume* volume, const sequence_number_t sequenceNumber,
    const std::shared_ptr<ILogger>& logger)
:  IDichotomiser(logger)
,  m_volume(volume)
,  m_sequenceNumber(sequenceNumber)
,  m_fromSection(nullptr)
,  m_toSection(nullptr)
,  m_middleSection(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  m_fromSection = new PSFSection(m_volume);
  m_toSection = new PSFSection(m_volume);
  m_middleSection = new PSFSection(m_volume);
}

SearchSequenceNumberDichotomiser::~SearchSequenceNumberDichotomiser()
{
  __DEV_CALLSTACK_FUNC__;
  delete m_fromSection;
  delete m_toSection;
  delete m_middleSection;
}

bool SearchSequenceNumberDichotomiser::_isAscendingRange(const sPSFSectionHeader_t* from, const sPSFSectionHeader_t* to) const
{
  __DEV_CALLSTACK_FUNC__;
  return (from->sequenceStart <= to->sequenceEnd); // this check returns true for empty "to" as well. 
  // It's okay: if "to" section is empty -> no loop -> indexes sequence is ascending on [from, to] range
}

bool SearchSequenceNumberDichotomiser::shrinkRange(size_t from, size_t to, size_t& newFrom, size_t& newTo) const
{
  __DEV_CALLSTACK_FUNC__;
#define SHRINK_RANGE(_from, _to) { newFrom = _from; newTo = _to; }

  // load "from" section
  m_volume->loadSection(from, *m_fromSection);
  // if from section is empty -> next sections are empty as well, range cannot be shrunk, return false
  if (m_fromSection->isEmpty())
  {
    return false;
  }
  // check if "from" section contains element -> return [from, from] range
  if (m_fromSection->containsDataElement(m_sequenceNumber))
  {
    SHRINK_RANGE(from, from);
    return true;
  }

  // load "to" section
  m_volume->loadSection(to, *m_toSection);
  // check if "to" section contains element -> return [to, to] range
  if (m_toSection->containsDataElement(m_sequenceNumber))
  {
    SHRINK_RANGE(to, to);
    return true;
  }

  // check if "to" & "from" are neighbours and both do not contain element -> element cannot be found
  if (to - from <= 1)
  {
    return false;
  }

  // get middle section
  const size_t middle = (from + to) >> 1;
  // load middle section
  m_volume->loadSection(middle, *m_middleSection);
  // if middle is empty -> shrink to [from, middle]
  if (m_middleSection->isEmpty())
  {
    SHRINK_RANGE(from, middle);
    return true;
  }

  // get headers ("from" and "middle" are not empty here; "to" - might be)
  const sPSFSectionHeader_t* const pFromHeader = m_fromSection->getHeader();
  const sPSFSectionHeader_t* const pMiddleHeader = m_middleSection->getHeader();
  const sPSFSectionHeader_t* const pToHeader = m_toSection->getHeader();

  // check the entire [from, to] is ascending -> no loop inside
  if (this->_isAscendingRange(pFromHeader, pToHeader))
  {
    // check if sequence number is after the middle -> search in [middle, to]
    if (m_sequenceNumber > pMiddleHeader->sequenceStart)
    {
      SHRINK_RANGE(middle, to);
    }
    else // search in [from; middle]
    {
      SHRINK_RANGE(from, middle);
    }
    return true;
  }

  // loop somewhere in [from, to] (either in [from, middle] or [middle, to])
  if (this->_isAscendingRange(pFromHeader, pMiddleHeader)) // no loop in [from, middle]
  {
    // check if element is in [from, middle]
    if (pFromHeader->sequenceStart <= m_sequenceNumber && m_sequenceNumber <= pMiddleHeader->sequenceEnd)
    {
      SHRINK_RANGE(from, middle);
    }
    else // element not in [from, middle] -> shrink to [middle, to]
    {
      SHRINK_RANGE(middle, to);
    }
    return true;
  }
  else // loop in [from, middle] -> NO loop in [middle, to]
  {
    // check if elements is in [middle; to]
    if (pMiddleHeader->sequenceStart <= m_sequenceNumber && m_sequenceNumber <= pToHeader->sequenceEnd)
    {
      SHRINK_RANGE(middle, to);
    }
    else // element not in [middle, to] -> shrink to [from, middle]
    {
      SHRINK_RANGE(from, middle);
    }
    return true;
  }
  
  return false;
}
