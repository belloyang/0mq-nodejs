#include "MaxSequenceEndDichotomiser.h"

#include "../PSFVolume.h"
#include "../PSFSection.h"

MaxSequenceEndDichotomiser::MaxSequenceEndDichotomiser(const PSFVolume* volume, const std::shared_ptr<ILogger>& logger)
:  IDichotomiser(logger)
,  m_volume(volume)
,  m_fromSection(nullptr)
,  m_toSection(nullptr)
,  m_middleSection(nullptr)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(m_volume != nullptr && "'volume' cannot be nullptr here");
  m_fromSection = new PSFSection(m_volume);
  m_toSection = new PSFSection(m_volume);
  m_middleSection = new PSFSection(m_volume);
}

MaxSequenceEndDichotomiser::~MaxSequenceEndDichotomiser()
{
  __DEV_CALLSTACK_FUNC__;
  delete m_fromSection;
  delete m_toSection;
  delete m_middleSection;
}

bool MaxSequenceEndDichotomiser::isBigger(const PSFSection* pSection1, const PSFSection* pSection2) const
{
  __DEV_CALLSTACK_FUNC__;
  if (!pSection2->isValid() || pSection2->isEmpty())
    return true;
  if (!pSection1->isValid() || pSection1->isEmpty())
    return false;
  return pSection1->getHeader()->sequenceEnd >= pSection2->getHeader()->sequenceEnd;
}

bool MaxSequenceEndDichotomiser::shrinkRange(size_t from, size_t to, size_t& newFrom, size_t& newTo) const
{
  __DEV_CALLSTACK_FUNC__;
  if (to == from)
  {
    newFrom = from;
    newTo = to;
    return true;
  }

  m_volume->loadSection(from, *m_fromSection);
  m_volume->loadSection(to, *m_toSection);

  //tss_psflib::if both sections are empty -> return "from" section
  if (m_toSection->isEmpty() && m_fromSection->isEmpty())
  {
    newFrom = newTo = from;
    return true;
  }

  //tss_psflib::check if sections are neighbours and chose the best one
  if (to - from == 1)
  {
    if (this->isBigger(m_fromSection, m_toSection))
    {
      newFrom = newTo = from;
    }
    else
    {
      newFrom = newTo = to;
    }
    return true;
  }

  const size_t middle = (from + to) >> 1;
  //0) (from)...(middle)....(to)
  //1) (0) 1  2  3  (4)  _  _  _  (_) - no ring-buffered volume (with empty sections)
  //2) (0) 1  2  3  (4)  5  6  7  (8) - no ring-buffered volume (filled)
  //3) (9) 10 2  3  (4)  5  6  7  (8) - ring-buffered volume
  //4) (12)13 14 15 (16) 17 6  7  (8) - ring-buffered volume

  //tss_psflib::if "from" section is bigger then "to" section -> looped in between -> (1) or (3) or (4)
  if (this->isBigger(m_fromSection, m_toSection))
  {
    m_volume->loadSection(middle, *m_middleSection);
    //tss_psflib:: if "from" section is better then "middle section" -> (3) variant
    if (this->isBigger(m_fromSection, m_middleSection))
    {
      //look in [from, middle]
      newFrom = from;
      newTo = middle;
    }
    else //tss_psflib::(1) or (4) variant
    {
      //look in [middle, to]
      newFrom = middle;
      newTo = to;
    }
  }
  //tss_psflib::"from" section is smaller -> sections are in ascending order -> "to" - maximum
  else
  {
    newFrom = newTo = to;
  }

  return true;
}
