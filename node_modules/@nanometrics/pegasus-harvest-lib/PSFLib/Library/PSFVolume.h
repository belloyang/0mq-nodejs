#ifndef PSFVolume_h__
#define PSFVolume_h__

#include "../psflib_defines.h"

#include "IPSFEntity.h"
#include "PSFSection.h"
#include "PSFDataElement.h"

#include <buffers.h>
#include <IOContext/IIOContext.h>
#include <Hasher/IHasher.h>

#include <memory>
#include <string>

/// <summary>
/// PSFVolume. Represents PSF volume object.\n
/// Volume spans integer amount of chapters. 1st chapter is reserved for header. Is aligned to chapter start
/// </summary>
class PSFVolume : public IPSFEntity
{
public:
  /**
   * PSFSection constructor
   * @param hasher        hasher instance
   * @param logger        logger instance
   */
  PSFVolume(const std::shared_ptr<IHasher>& hasher, const std::shared_ptr<ILogger>& logger);
  //! PSFVolume destructor
  ~PSFVolume() = default;

  /**
   * Init volume parameters
   * @param label        volume's label
   * @param uniqueId      volume's unique ID
   * @param sizeInChapters  volume's size in chapters
   * @return          true on success; false - on failure
   */
  bool init(const VolumeLabel_t label, uint32_t uniqueId, uint32_t sizeInChapters);

  /**
   * Dumps volume to context
   * @param context   context to dump volume to
   * @param offset    offset inside context to dump volume at
   * @return volume size (in chapters) on success; 0 - on failure
   */
  uint32_t create(const std::shared_ptr<IIOContext>& context, io_offset_t offset);

  /**
   * Restores volume from context at offset. Returns volume's size
   * @param context  context to restore volume from
   * @param offset  offset inside context to restore volume at
   * @return  volume's size (in bytes) on success; 0 - on failure
   */
  uint64_t restore(const std::shared_ptr<IIOContext>& context, io_offset_t offset);

  /**
   * Erases all the data on the volume (destroys each section)
   * @return  true if succeeded, false - otherwise
   */
  bool erase();

  /**
   * Volume's header getter
   * @return  volume's header
   */
  FORCE_INLINE const sPSFVolumeHeader_t* getHeader() const { return m_header.ptr(); }

  /**
   * Loads section into preallocated PSFSection object
   * @param sectionIndex  section index to load
   * @param output    output PSFSection object
   * @return        true if section was loaded; false - otherwise
   */
  bool loadSection(const uint32_t sectionIndex, PSFSection& output) const;

  /**
   * Data context getter. Data context commences after Volume's header context -> volume's header is excluded from data context
   * because header should not be ring-buffered. Only data context represents ring-buffer
   * @return  data context (context that data is stored into)
   */
  const std::shared_ptr<IIOContext>& getDataContext() const { return m_dataContext; }

  /**
   * Finds section for data element sequence number
   * @param sequenceNumber    data element sequence number
   * @return            PSFSection object on success; nullptr - on failure
   */
  PSFSection* findSectionBySequenceNumber(const sequence_number_t sequenceNumber) const;

private:
  virtual bool _loadFromContext(const std::shared_ptr<IIOContext>& context, io_offset_t offset) __OVERRIDES__(IPSFEntity);
  void _createContexts(const std::shared_ptr<IIOContext>& baseContext, io_offset_t offset);
  bool _dumpHeader(const std::shared_ptr<IIOContext>& context, io_offset_t offset);
  int _updateHash();
  bool _checkIntegrity(const sPSFVolumeHeader_t& header) const;

private:
  //! Header buffer
  io_aligned_ptr<sPSFVolumeHeader_t> m_header;
  //! Volume's header context (1 chapter long). Keeps only access to header. Is changed on each write operation.
  std::shared_ptr<IIOContext> m_headerContext;
  //! Volume's data context (ring buffer, header is not included -> context starts after header's chapter)
  std::shared_ptr<IIOContext> m_dataContext;
};

#endif //PSFVolume_h__
