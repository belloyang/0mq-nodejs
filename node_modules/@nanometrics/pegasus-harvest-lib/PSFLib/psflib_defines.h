#ifndef psflib_defines_h__
#define psflib_defines_h__

#include "../shared_defines.h"
#include "../version.h"

#include <libio_defines.h>

#include <string>
#include <vector>

#if defined(DEV_PLATFORM_STM32)
  #include "platform/psflib_stm32_defines.h"
#elif defined(DEV_PLATFORM_WIN32)
  #include "platform/psflib_win32_defines.h"
#elif defined(DEV_PLATFORM_LINUX)
  #include "platform/psflib_linux_defines.h"
#elif defined(DEV_PLATFORM_MACOS)
  #include "platform/psflib_macos_defines.h"
#endif

typedef enum : uint32_t
{
  PSF_ERROR_CODE_BASE = 0x20000000, /*!< base error code for PSF library */

  PSF_ERROR_CODE_BASE_LIBRARY = PSF_ERROR_CODE_BASE + 0x00001000, /*!< base error code for PSFLibrary */
  PSF_ERROR_LIBRARY_WRITING_FAILED         = PSF_ERROR_CODE_BASE_LIBRARY + 0x00000001, /*!< library creation/initialization/dumping failed */
  PSF_ERROR_LIBRARY_RESTORING_FAILED       = PSF_ERROR_CODE_BASE_LIBRARY + 0x00000002, /*!< library restoring/reading failed */
  PSF_ERROR_LIBRARY_INTEGRITY_CHECK_FAILED = PSF_ERROR_CODE_BASE_LIBRARY + 0x00000003, /*!< library integrity check failed */
  PSF_ERROR_LIBRARY_NOT_PSF                = PSF_ERROR_CODE_BASE_LIBRARY + 0x00000004, /*!< data has been read/restored but appears to be not PSF library*/

  PSF_ERROR_CODE_BASE_VOLUME  = PSF_ERROR_CODE_BASE + 0x00002000, /*!< base error code for PSF volume */
  PSF_ERROR_VOLUME_WRITING_FAILED         = PSF_ERROR_CODE_BASE_VOLUME + 0x00000001, /*!< volume creation/dumping failed */
  PSF_ERROR_VOLUME_RESTORING_FAILED       = PSF_ERROR_CODE_BASE_VOLUME + 0x00000002, /*!< volume restoring/reading failed */
  PSF_ERROR_VOLUME_INTEGRITY_CHECK_FAILED = PSF_ERROR_CODE_BASE_VOLUME + 0x00000003, /*!< volume integrity check failed */

  PSF_ERROR_CODE_BASE_SECTION = PSF_ERROR_CODE_BASE + 0x00003000, /*!< base error code for PSF sections */
  PSF_ERROR_SECTION_WRITING_FAILED         = PSF_ERROR_CODE_BASE_SECTION + 0x00000001, /*!< section creation/initialization/dumping failed */
  PSF_ERROR_SECTION_RESTORING_FAILED       = PSF_ERROR_CODE_BASE_SECTION + 0x00000002, /*!< section restoring/reading failed */
  PSF_ERROR_SECTION_INTEGRITY_CHECK_FAILED = PSF_ERROR_CODE_BASE_SECTION + 0x00000003, /*!< section integrity check failed */

  PSF_ERROR_CODE_BASE_DATA_ELEMENT = PSF_ERROR_CODE_BASE + 0x00004000, /*!< base error code for PSF sections */
  PSF_ERROR_DATA_ELEMENT_WRITING_FAILED         = PSF_ERROR_CODE_BASE_DATA_ELEMENT + 0x00000001, /*!< data element creation/initialization/dumping failed */
  PSF_ERROR_DATA_ELEMENT_RESTORING_FAILED       = PSF_ERROR_CODE_BASE_DATA_ELEMENT + 0x00000002, /*!< data element restoring/reading failed */
  PSF_ERROR_DATA_ELEMENT_INTEGRITY_CHECK_FAILED = PSF_ERROR_CODE_BASE_DATA_ELEMENT + 0x00000003, /*!< data element integrity check failed */

  PSF_ERROR_CODE_BASE_MEMORY = PSF_ERROR_CODE_BASE + 0x00005000, /*!< base error code for memory failures */
  PSF_ERROR_OUT_OF_MEMORY = PSF_ERROR_CODE_BASE_MEMORY + 0x00000001, /*!< memory allocation error */
} ePSFLibErrorCode;

// enforce compact byte packing for all subsequent unions and structures in this file
#pragma pack(push, 1)

//! PSF version
const uint32_t PSF_VERSION = 1;

//! PSF 'magic constant' (string) to be written at the beginning of PSF library to help to identify it
const char PSF_LIBRARY_MAGIC_CONST[24] = {
  'P', 'e', 'g', 'a', 's', 'u', 's', ' ',
  'S', 't', 'r', 'e', 'a', 'm', 'i', 'n', 'g', ' ',
  'F', 'o', 'r', 'm', 'a', 't'
};

//! PSF Data element magic code (string)
const char PSF_DATA_ELEMENT_MAGIC_CONST[2] = { 
    'D', 'e'
};

//! PSF entities specific constants
#define PSF_PAGE_SIZE_BYTES      (512)  // bytes (0.5 KiB)
#define PSF_CHAPTER_SIZE_PAGES   (8192) // pages = 4 MiB
#define PSF_CHAPTER_SIZE_BYTES   (PSF_CHAPTER_SIZE_PAGES * PSF_PAGE_SIZE_BYTES)
#define PSF_CHAPTER_SIZE_MIBYTES (PSF_CHAPTER_SIZE_BYTES / 1024 / 1024)

//! PSF conversion macros
// NOTE: Explicitly type cast to the TARGET numeric type (either 32-bit or 64-bit) to
// ensure calculation operates in the correct domain. The numeric types in this case are
// specific to the PSF design. Eg. maximum volume size is in the order of TBytes, so
// any conversion to bytes must use a 64-bit numeric type.
#define PSF_PAGES_to_BYTES(nPages)        ((uint64_t)(nPages) * PSF_PAGE_SIZE_BYTES)
#define PSF_SECTIONS_to_PAGES(nSections)  ((uint32_t)(nSections) * PSF_CHAPTER_SIZE_PAGES)
#define PSF_SECTIONS_to_BYTES(nSections)  ((uint64_t)(nSections) * PSF_CHAPTER_SIZE_BYTES)
#define PSF_CHAPTERS_to_PAGES             PSF_SECTIONS_to_PAGES
#define PSF_CHAPTERS_to_BYTES             PSF_SECTIONS_to_BYTES

//! PSF constraints & constants
#define PSF_MAX_VOLUMES_COUNT             (256)
#define PSF_MAX_VOLUME_SIZE_CHAPTERS      (524288) //(2 ^ 19, 2TiB)
#define PSF_MAX_VOLUME_SIZE               PSF_CHAPTERS_to_BYTES(PSF_MAX_VOLUME_SIZE_CHAPTERS)
#define PSF_MAX_DATA_ELEMENT_SIZE_PAGES   (254)
#define PSF_MAX_DATA_ELEMENT_SIZE_BYTES   PSF_PAGES_to_BYTES(PSF_MAX_DATA_ELEMENT_SIZE_PAGES)
#define PSF_SEQUENCE_NUMBER_INVALID       ((uint32_t)-1)

//! Sequence number typedef
typedef uint32_t sequence_number_t;
//! Message type typedef
typedef uint32_t message_type_t;
//! PSF library magic value
typedef char MagicValue_t[sizeof(PSF_LIBRARY_MAGIC_CONST)]; // magic value should fit Magic const size
//! Volume label typedef
// Up to sizeof(type) characters for this string type, null-padded at end.
// In case of max-length string, string is NOT null-terminated.
typedef char VolumeLabel_t[32];

//! Device name typedef
// Up to (sizeof(type) - 1) meaningful characters for this string type, null-padded at the end and null-terminated
typedef char DeviceName_t[64];
//! Device path typedef
// Up to (sizeof(type) - 1) meaningful characters for this string type, null-padded at the end and null-terminated
typedef char DevicePath_t[64];

//! struct that defines PSF volume configuration
typedef struct
{
  VolumeLabel_t label; //! volume label
  uint32_t id; //! volume unique ID
  double sizePercent; //! volume size (in percent of the entire available context size)
} sPSFVolumeConfig_t;
//! struct that defines PSF format configuration (FAT32 label & volumes)
typedef struct
{
  uint32_t fatSizeMiB; //! FAT32 size in MiB
  std::string fatVolumeLabel; //! FAT volume label
  std::vector<sPSFVolumeConfig_t> volumes; //! PSF volumes configuration
} sPSFFormatConfig_t;

//! sVolumeInfo structure
typedef struct
{
  //! label/name
  VolumeLabel_t label;
  //! unique identifier
  uint32_t uniqueId;
  //! size (in chapters)
  uint32_t sizeInChapters;
  //! index
  uint32_t index;
  //! start chapter
  uint32_t startChapter;
  //! bool has time
  bool bTimeValid;
  //! lower time (applicable for volumes that have records with timestamps)
  timestamp_t lowerTime;
  //! upper time (applicable for volumes that have records with timestamps)
  timestamp_t upperTime;
} sVolumeInfo;

//! sPSFDeviceInfo structure
typedef struct
{
  //! device name
  DeviceName_t deviceName;
  //! device path
  DevicePath_t devicePath;
} sPSFDeviceInfo_t;

//! HashAlgorithm enumeration
typedef enum
{
  PSF_HASH_MURMUR3 = 0, /*!< Murmur3 hash algorithm */
  PSF_HASH_CRC32_MPEG = 1, /*!< CRC32-MPEG hash algorithm */
  PSF_HASH_DEFAULT = PSF_HASH_MURMUR3 /*!< Default hash algorithm */
} ePSFHashAlgorithm_t;

//! PSFLibrary header structure (1 chapter is reserved for it)
typedef struct
{
  //! Hash value
  Hash32_t hash;
  //! PSF Magic string buffer
  MagicValue_t magic;
  //! PSF version
  uint32_t psfVersion;
  //! Library creation time
  timestamp_t creationTime;
  //! Number of volumes in the library
  uint32_t nVolumes; //library size
  //! Offsets (in chapters) for each volume in library
  uint32_t volumeOffsetsInChapters[PSF_MAX_VOLUMES_COUNT];
} sPSFLibraryHeader_t;

//! PSFVolume header structure (1 chapter/section is reserved for it)
typedef struct
{
  //! Hash value
  Hash32_t hash;
  //! Unique identifier
  uint32_t uniqueId;
  //! Volume's label/name
  VolumeLabel_t label;
  //! Volume's size (in chapters/sections), including volume header
  uint32_t sizeInChapters;
} sPSFVolumeHeader_t;

//! PSFSection header structure (1 page is reserved for it)
typedef struct
{
  //! Hash value
  Hash32_t hash;
  //! Sequence number of the first data element in the section (PSF_SEQUENCE_NUMBER_INVALID if the section is empty)
  sequence_number_t sequenceStart;
  //! Sequence number of the last data element in the section (PSF_SEQUENCE_NUMBER_INVALID if the section is empty (first <= last satisfied in this case as well))
  sequence_number_t sequenceEnd;
  //! Page offset where the next data element will be written, relative to start of section
  //! If the section is empty, then next == 1, since page #0 contains the section header.
  uint32_t nextPage;
  //! Last written data element size (in pages)
  uint8_t lastWrittenSize;
  //! unused (for alignment)
  uint8_t UNUSED[3];
} sPSFSectionHeader_t;

//! PSFDataElement header structure (spans it's size. DataElement payload commences right after header)
typedef struct
{
  //! Hash value
  Hash32_t hash;
  //! Sequence number of data element
  sequence_number_t sequenceNumber;
  //! message type to identify an application dependent message structure that overloads the payload
  message_type_t messageType;
  //! data element size in pages (including header, 0 < 254)
  uint8_t sizeInPages;
  //! reverse offset in pages to the start of previous data element (0 <= prev <= 255). should be positive (+) but mean offset to the left
  uint8_t prev;
  //! Magic string identifying a data element. Set to "De".
  //! magic may assist data recovery operations in case the structural integrity of the PSF library is compromised.
  //! magic is also used to force the data element header size to 16 bytes, which supports 8-byte address alignment for the start of the data element payload. This is optimal for 64-bit platforms in case the data element payload commences with a 64-bit member
  uint8_t magic[2];
} sPSFDataElementHeader_t;

#pragma pack(pop) // #pragma pack(push, 1)

#endif //psflib_defines_h__
