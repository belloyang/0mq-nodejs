#include "psf_utils.h"

#include <chrono> // system_clock, nanoseconds
#include <ctime>  // strftime
#include <cstdio> // sprintf

namespace psf_utils
{
  // POSIX epoch
  const static std::chrono::system_clock::time_point posixEpoch = std::chrono::system_clock::from_time_t(0);

  timestamp_t get_timestamp()
  {
    __DEV_CALLSTACK_FUNC__;
    const std::chrono::nanoseconds now = std::chrono::duration_cast<std::chrono::nanoseconds>(
      std::chrono::system_clock::now() - posixEpoch);
    return now.count();
  }

  void timestamp_to_string(char* buf, size_t sz, timestamp_t t)
  {
    __DEV_CALLSTACK_FUNC__;
    // get seconds and fractional seconds
    std::chrono::nanoseconds t_nanoseconds(t);
    std::chrono::system_clock::time_point t_timepoint(std::chrono::duration_cast<std::chrono::system_clock::duration>(t_nanoseconds));
    int64_t tt = (int64_t)std::chrono::system_clock::to_time_t(t_timepoint);
    std::chrono::nanoseconds fraction_ns = t_timepoint - std::chrono::system_clock::from_time_t(tt);
    // note that chrono truncates value for the following conversions
    std::chrono::milliseconds fraction_ms = std::chrono::duration_cast<std::chrono::milliseconds>(fraction_ns);
    // handle -ve fraction (time before POSIX epoch)
    if (fraction_ms.count() < 0) {
      --tt;
      fraction_ms += std::chrono::milliseconds(1000);
    }
    // write date and time
    tm gmTime;
    size_t written = ::strftime(buf, sz, "%F %T", psf_utils::gmtime(&tt, &gmTime));
    buf += written;
    sz -= written;
    // append fractional seconds
    if (sz >= 5) { // includes terminating null character
      const int result = sprintf(buf, ".%03d", static_cast<int>(fraction_ms.count()));
      written = result > 0 ? static_cast<size_t>(result) : 0;
      buf += written;
      sz -= written;
    }
    // append 'UTC'
    if (sz >= 5) { // includes terminating null character
      sprintf(buf, " UTC");
    }
  }


  const char pivotal_gmtime_r_stamp_lm[] =
    "pivotal_gmtime_r. Copyright (C) 2009  Paul Sheer. Terms and "
    "conditions apply. Visit http://2038bug.com/ for more info.";

  static const int tm_days[4][13] = {
      {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
      {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
      {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
      {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
  };

#define TM_LEAP_CHECK(n) ((!(((n) + 1900) % 400) || (!(((n) + 1900) % 4) && (((n) + 1900) % 100))) != 0)
#define TM_WRAP(a, b, m) ((a) = ((a) < 0) ? ((b)--, (a) + (m)) : (a))

  struct tm* gmtime(int64_t *timep, struct tm *result)
  {
    __DEV_CALLSTACK_FUNC__;
    if (!timep || !result)
      return NULL;

    if (sizeof(time_t) == 4) //32bit platform fallback or when 32bits time_t imposed (through defines, etc.)
    {
      int v_tm_sec, v_tm_min, v_tm_hour, v_tm_mon, v_tm_wday, v_tm_tday;
      int leap;
      long m;
      int64_t tv = *timep;

      v_tm_sec = ((int64_t)tv % (int64_t)60);
      tv /= 60;
      v_tm_min = ((int64_t)tv % (int64_t)60);
      tv /= 60;
      v_tm_hour = ((int64_t)tv % (int64_t)24);
      tv /= 24;
      v_tm_tday = (int)tv;

      TM_WRAP(v_tm_sec, v_tm_min, 60);
      TM_WRAP(v_tm_min, v_tm_hour, 60);
      TM_WRAP(v_tm_hour, v_tm_tday, 24);

      if ((v_tm_wday = (v_tm_tday + 4) % 7) < 0)
        v_tm_wday += 7;

      m = (long)v_tm_tday;

      if (m >= 0)
      {
        result->tm_year = 70;
        leap = TM_LEAP_CHECK(result->tm_year);

        while (m >= (long)tm_days[leap + 2][12])
        {
          m -= (long)tm_days[leap + 2][12];
          result->tm_year++;
          leap = TM_LEAP_CHECK(result->tm_year);
        }

        v_tm_mon = 0;

        while (m >= (long)tm_days[leap][v_tm_mon])
        {
          m -= (long)tm_days[leap][v_tm_mon];
          v_tm_mon++;
        }
      }
      else
      {
        result->tm_year = 69;
        leap = TM_LEAP_CHECK(result->tm_year);

        while (m < (long)-tm_days[leap + 2][12])
        {
          m += (long)tm_days[leap + 2][12];
          result->tm_year--;
          leap = TM_LEAP_CHECK(result->tm_year);
        }

        v_tm_mon = 11;

        while (m < (long)-tm_days[leap][v_tm_mon])
        {
          m += (long)tm_days[leap][v_tm_mon];
          v_tm_mon--;
        }

        m += (long)tm_days[leap][v_tm_mon];
      }

      result->tm_mday = (int)m + 1;
      result->tm_yday = tm_days[leap + 2][v_tm_mon] + m;
      result->tm_sec = v_tm_sec;
      result->tm_min = v_tm_min;
      result->tm_hour = v_tm_hour;
      result->tm_mon = v_tm_mon;
      result->tm_wday = v_tm_wday;
    }
    else  //8-bytes time_t
    {
      time_t _time = (time_t)(*timep);
      const tm* const gmTime = ::gmtime(&_time);
      *result = (*gmTime);
    }

    return result;
  } /* End of ms_gmtime_r() */

  struct tm* gmtime_from_timestamp(const timestamp_t time, struct tm *result)
  {
    __DEV_CALLSTACK_FUNC__;
    int64_t timeSec = time / 1000000000LL;
    return psf_utils::gmtime(&timeSec, result);
  }

  /*
   * unit test for psf_utils_timestamp_to_string()
   */
#if 0
  {
    int64_t val[] = { 0, 1LL, 10LL, 100LL, 1000LL, 10000LL, 100000LL, 1000000LL, 10000000LL, 100000000LL, 999400000LL, 999500000LL, 999999999LL, 1000000000LL };
    for (unsigned i = 0; i < NUM_ELEMENTS(val); ++i) {
      psf_utils_timestamp_to_string(creation, NUM_ELEMENTS(creation), val[i]);
      printf("timestamp=%s, val[%2u]=%ld\n", creation, i, val[i]);
    }
  }
  {
    int64_t val[] = { 0, -1LL, -10LL, -100LL, -1000LL, -10000LL, -100000LL, -1000000LL, -10000000LL, -100000000LL, -999400000LL, -999500000LL, -999999999LL, -1000000000LL };
    for (unsigned i = 0; i < NUM_ELEMENTS(val); ++i) {
      psf_utils_timestamp_to_string(creation, NUM_ELEMENTS(creation), val[i]);
      printf("timestamp=%s, val[%2u]=%ld\n", creation, i, val[i]);
    }
  }
#endif

} //namespace psf_utils
