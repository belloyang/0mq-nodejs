#include "CLCommand_LoadLibrary.h"

#include <Library/PSFLibrary.h>
#include <IOContext/io_contexts.h>
#include <PlatformUtils/PlatformUtils.h>
#include <Utils/fat32_utils.h>
#include <Utils/pdb_utils.h>

#include <cinttypes>
#include <cstring> // ::memcmp

CLCommand_LoadLibrary::CLCommand_LoadLibrary(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("load-library", logger)
,  m_libPath("")
,  m_inputPath("")
,  m_bCreateFAT32(false)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_LoadLibrary::_parseLibPath), "output PSF library path");
  this->_registerArgument("-if=", CLCOMMAND_PARSE_HANDLER(CLCommand_LoadLibrary::_parseInputPath), "input file path");
  this->_registerArgument("-fat", CLCOMMAND_PARSE_HANDLER(CLCommand_LoadLibrary::_parseCreateFat32),
                          "create FAT32 partition flag", "not set");
}

int CLCommand_LoadLibrary::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<output PSF path>')");
    return -1;
  }
  if (m_inputPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Input path is not specified ('-if=<input file path>')");
    return -1;
  }

  // create FAT32 partition using default configuration
  if (m_bCreateFAT32)
  {
    const std::shared_ptr<IIOContext>& deviceContext = this->_createDeviceContext(m_libPath);
    const sPSFFormatConfig_t& formatConfig = pdb_utils::PSF_FORMAT_CONFIGURATION_DEFAULT;
    if (!fat32_utils::write_FAT32_Partition(deviceContext, formatConfig.fatVolumeLabel, formatConfig.fatSizeMiB, m_logger))
    {
      m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvLibErrorCode::HARVLIB_ERROR_OPERATION_FAILED,
        "Failed to create FAT32 partition on %s",
        m_libPath.c_str());
      return -1;
    }
    m_logger->info(m_name.c_str(), "FAT32 partition '%s' created (%" PRIu32 " MiB)",
      formatConfig.fatVolumeLabel.c_str(), formatConfig.fatSizeMiB);
  }

  // create image file context (open for reading)
  const std::shared_ptr<IIOContext>& fileContext = this->_createFileContext(m_inputPath);
  io_offset_t fileContextOffset = 0u;
  // read and verify library header (make sure the file provided is PSF image)
  io_aligned_ptr<sPSFLibraryHeader_t> libraryHeader;
  fileContextOffset += fileContext->readBlock(0, libraryHeader.size(), libraryHeader.ptr());
  if (::memcmp(libraryHeader->magic, PSF_LIBRARY_MAGIC_CONST, sizeof(PSF_LIBRARY_MAGIC_CONST)) != 0)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, ePSFLibErrorCode::PSF_ERROR_LIBRARY_RESTORING_FAILED,
        "Provided file '%s' doesn't appear to be PSF image", m_inputPath.c_str());
    return -1;
  }

  // create PSF library context (create empty library and retrieve context from there to tolerate FAT32).
  PSFLibrary* library = PSFLibrary::create(m_libPath, m_hasher, m_logger, false);
  std::shared_ptr<IIOContext> libraryContext = library->getIOContext();
  delete library; // context retrieved -> library instance can be removed
  // copy library header
  libraryContext->writeBlock(0, libraryHeader.size(), libraryHeader.ptr());
  // copy volumes
  const sPSFLibraryHeader_t* const header = libraryHeader.ptr();
  m_logger->info(m_name.c_str(), "Library restored from file with %" PRIu32 " volumes", header->nVolumes);
  io_aligned_ptr<sPSFSectionHeader_t> sectionHeader;
  buffer_io_aligned_alloc<uint8_t> chapter(PSF_CHAPTER_SIZE_BYTES);
  for (uint32_t i = 0; i < header->nVolumes; ++i)
  {
    uint32_t nChaptersCopied = 0u, nChaptersErased = 0u;
    const uint32_t volumeStartChapter = header->volumeOffsetsInChapters[i];
    io_offset_t volumeOffset = PSF_CHAPTERS_to_BYTES(static_cast<io_offset_t>(volumeStartChapter));
    // copy volume header chapter
    fileContextOffset += fileContext->readBlock(fileContextOffset, chapter.size(), chapter.ptr());
    volumeOffset      += libraryContext->writeBlock(volumeOffset, chapter.size(), chapter.ptr());
    ++nChaptersCopied;
    // save volume header (on stack, the chapter buffer will be reused)
    const sPSFVolumeHeader_t volumeHeader = *chapter.ptr<sPSFVolumeHeader_t>();
    // try to copy every chapter
    while (nChaptersCopied < volumeHeader.sizeInChapters)
    {
      // read & copy section header
      fileContextOffset += fileContext->readBlock(fileContextOffset, sectionHeader.size(), sectionHeader.ptr());
      // if chapter is empty -> skip copying -> goto 'cleanup'
      if (sectionHeader.ptr()->sequenceStart == PSF_SEQUENCE_NUMBER_INVALID)
      {
        break;
      }
      // copy non-empty section header
      volumeOffset      += libraryContext->writeBlock(volumeOffset, sectionHeader.size(), sectionHeader.ptr());
      // copy the rest (content) of the chapter after header
      const size_t remainingSize = chapter.size() - sectionHeader.size();
      fileContextOffset += fileContext->readBlock(fileContextOffset, remainingSize, chapter.ptr());
      volumeOffset      += libraryContext->writeBlock(volumeOffset, remainingSize, chapter.ptr());
      ++nChaptersCopied;
    }
    /* cleanup: erase the rest of the chapters (to remove old data)
     'sectionHeader' is one of the following:
       1. EMPTY, because of an empty section loaded into it in the loop above OR
       2. NOT EMPTY, because empty section hasn’t been faced in the loop above
          but it means that all the sections are copied → no remaining section to erase (nChaptersCopied = volumeHeader.sizeInChapters)
          and the following loop won’t iterate even once.
    */
    for (uint32_t chapterIdx = nChaptersCopied; chapterIdx < volumeHeader.sizeInChapters; ++chapterIdx)
    {
      // get chapter offset (volumeStartChapter + 1 chapter (volume header)
      const io_offset_t chapterOffset = PSF_CHAPTERS_to_BYTES(static_cast<io_offset_t>(volumeStartChapter + chapterIdx));
      libraryContext->writeBlock(chapterOffset, sectionHeader.size(), sectionHeader.ptr());
      ++nChaptersErased;
    }
    // print summary
    m_logger->info(m_name.c_str(), "Volume '%.*s' (id=%" PRIu32 "): (total = %" PRIu32 ", copied = %" PRIu32 ", erased = %" PRIu32 ")",
      NUM_ELEMENTS(volumeHeader.label), volumeHeader.label, volumeHeader.uniqueId,
      volumeHeader.sizeInChapters, nChaptersCopied, nChaptersErased);
  }

  return 0;
}

std::shared_ptr<IIOContext> CLCommand_LoadLibrary::_createFileContext(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_LINUX) || defined(DEV_PLATFORM_MACOS)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(path, O_RDONLY, m_logger);
#elif defined(DEV_PLATFORM_WIN32)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_Windows>(path, FILE_READ_DATA, 0, OPEN_EXISTING, m_logger);
#endif
  return fileContext;
}

std::shared_ptr<IIOContext> CLCommand_LoadLibrary::_createDeviceContext(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& libPath = PlatformUtils::getInstance()->fixDevicePath(path);
  const std::string& physicalPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(physicalPath);
#if defined(DEV_PLATFORM_WIN32)
  // create logical drive context to lock and dismount current drive to allow writing to underlying physical drive
  std::shared_ptr<FileIOContext_Windows> logicalContext = std::make_shared<FileIOContext_Windows>(libPath,
    GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING,
    m_logger);
  // lock and dismount drive (required to destroy FS on it)
  logicalContext->lock();
  logicalContext->dismount();
  // create device context
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_Windows>(physicalPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, OPEN_EXISTING, m_logger);
#elif defined(DEV_PLATFORM_LINUX)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(physicalPath, O_RDWR | O_LARGEFILE, m_logger);
#elif defined(DEV_PLATFORM_MACOS)
  std::shared_ptr<IIOContext> deviceContext = std::make_shared<FileIOContext_POSIX>(physicalPath, O_RDWR, m_logger);
#endif
  return deviceContext;
}

std::string CLCommand_LoadLibrary::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Loads PSF library content from file");
}

bool CLCommand_LoadLibrary::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_LoadLibrary::_parseInputPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_inputPath = std::string(arg);
  return true;
}

bool CLCommand_LoadLibrary::_parseCreateFat32(const char* /*arg*/)
{
  __DEV_CALLSTACK_FUNC__;
  // this is the flag (set vs unset) not boolean value (true/false).
  // If parser detected it (called this method) -> it means it's set.
  m_bCreateFAT32 = true;
  return true;
}
