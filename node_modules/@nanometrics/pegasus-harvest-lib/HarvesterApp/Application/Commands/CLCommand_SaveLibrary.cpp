#include "CLCommand_SaveLibrary.h"

#include <PlatformUtils/PlatformUtils.h>
#include <Library/PSFLibrary.h>
#include <IOContext/io_contexts.h>
#include <buffers.h>

#include <cinttypes>

CLCommand_SaveLibrary::CLCommand_SaveLibrary(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("save-library", logger)
,  m_libPath("")
,  m_outputPath("")
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_SaveLibrary::_parseLibPath), "input PSF library path");
  this->_registerArgument("-of=", CLCOMMAND_PARSE_HANDLER(CLCommand_SaveLibrary::_parseOutputPath), "output file path");
}

int CLCommand_SaveLibrary::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_outputPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Output path is not specified ('-of=<output file path>')");
    return -1;
  }

  // prepare physical disk/block device for raw access
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  // restore PSF library
  std::shared_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  if (pLibrary && pLibrary->restore())
  {
    const std::shared_ptr<IIOContext>& libraryContext = pLibrary->getIOContext();
    const std::shared_ptr<IIOContext>& fileContext = this->_createFileContext(m_outputPath);
    io_offset_t fileContextOffset = 0u;
    // copy header
    io_aligned_ptr<sPSFLibraryHeader_t> libraryHeader;
    libraryContext->readBlock(0, libraryHeader.size(), libraryHeader.ptr());
    fileContextOffset += fileContext->writeBlock(0, libraryHeader.size(), libraryHeader.ptr());
    const sPSFLibraryHeader_t* const header = libraryHeader.ptr();
    m_logger->info(m_name.c_str(), "Library restored with %" PRIu32 " volumes", header->nVolumes);
    // copy volumes
    io_aligned_ptr<sPSFSectionHeader_t> sectionHeader;
    buffer_io_aligned_alloc<uint8_t> chapter(PSF_CHAPTER_SIZE_BYTES);
    for (uint32_t i = 0; i < header->nVolumes; ++i)
    {
      const uint32_t volumeStartChapter = header->volumeOffsetsInChapters[i];
      io_offset_t volumeOffset = PSF_CHAPTERS_to_BYTES(static_cast<io_offset_t>(volumeStartChapter));
      // read and copy volume header chapter
      volumeOffset      += libraryContext->readBlock(volumeOffset, chapter.size(), chapter.ptr());
      fileContextOffset += fileContext->writeBlock(fileContextOffset, chapter.size(), chapter.ptr());
      uint32_t nChaptersCopied = 1u; // include volume header copied (spans 1 section)
      // save volume header (on stack, the chapter buffer will be reused)
      const sPSFVolumeHeader_t volumeHeader = *chapter.ptr<sPSFVolumeHeader_t>();
      while (nChaptersCopied < volumeHeader.sizeInChapters)
      {
        // copy section header
        volumeOffset      += libraryContext->readBlock(volumeOffset, sectionHeader.size(), sectionHeader.ptr());
        fileContextOffset += fileContext->writeBlock(fileContextOffset, sectionHeader.size(), sectionHeader.ptr());
        if (sectionHeader.ptr()->sequenceStart == PSF_SEQUENCE_NUMBER_INVALID)
        {
          break;
        }
        // copy section content (remaining)
        const size_t remainingSize = chapter.size() - sectionHeader.size();
        volumeOffset      += libraryContext->readBlock(volumeOffset, remainingSize, chapter.ptr());
        fileContextOffset += fileContext->writeBlock(fileContextOffset, remainingSize, chapter.ptr());
        ++nChaptersCopied;
      }
      // print summary
      m_logger->info(m_name.c_str(), "Volume '%.*s' (id=%" PRIu32 "): %" PRIu32 " chapters saved",
        NUM_ELEMENTS(volumeHeader.label), volumeHeader.label, volumeHeader.uniqueId,
        nChaptersCopied);
    }
    m_logger->info(m_name.c_str(), "PSF library saved to '%s'", m_outputPath.c_str());
    return 0;
  }
  else
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "Failed to restore PSF library at '%s'", m_libPath.c_str());
  }
  return 0;
}

std::shared_ptr<IIOContext> CLCommand_SaveLibrary::_createFileContext(const std::string& path) const
{
  __DEV_CALLSTACK_FUNC__;
#if defined(DEV_PLATFORM_LINUX) || defined(DEV_PLATFORM_MACOS)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(path, O_WRONLY | O_CREAT, m_logger);
#elif defined(DEV_PLATFORM_WIN32)
  const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_Windows>(path, FILE_WRITE_DATA, 0, OPEN_ALWAYS, m_logger);
#endif
  return fileContext;
}

std::string CLCommand_SaveLibrary::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Saves PSF library content to file");
}

bool CLCommand_SaveLibrary::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_SaveLibrary::_parseOutputPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_outputPath = std::string(arg);
  return true;
}
