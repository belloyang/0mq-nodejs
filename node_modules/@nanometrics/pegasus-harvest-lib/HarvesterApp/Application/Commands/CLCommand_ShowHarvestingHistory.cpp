#include "CLCommand_ShowHarvestingHistory.h"

#include <Operations/Operation_ReadVolume.h>

#include <cinttypes>
#include <cstdio>
#include <ctime>

class LoadHarvestinHistory_Delegate: public IProcessorDelegate
{
public:
  LoadHarvestinHistory_Delegate(const std::shared_ptr<ILogger>& logger)
  : m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~LoadHarvestinHistory_Delegate() = default;

  virtual void onPSFRead(const PSFDataElement* dataElement) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    if (dataElement->isInstanceOf(PDB_eMessageType_t::MSG_HARVEST_LOG_V0) && m_harvestLog.restore(dataElement))
    {
      const MsgHarvestLog::Header* const pHeader = m_harvestLog.getHeader();
      const time_t startTimeVal = static_cast<time_t>(pdb_utils::nanoseconds_to_seconds(pHeader->start));
      m_logger->info(__THIS_FUNC__, "History entity:\n"
        "    volume_id = %" PRIu32 "\n"
        "    start = %" PRId64 " - %s"
        "    duration = %" PRIu64 " ms\n"
        "    length = %" PRIu64 " bytes\n"
        "    range = [%" PRIu32 ", %" PRIu32 "]\n"
        "    target timespan [%" PRId64 ", %" PRId64 "]\n"
        "    actual timespan [%" PRId64 ", %" PRId64 "]\n"
        "    platform:\n"
        "        harvester = %.*s\n"
        "        OS = %.*s\n"
        "        kernel = %.*s\n"
        "        platform = %.*s\n"
        "        BIOS = %.*s\n"
        "        CPU = %.*s\n"
        "        RAM = %.*s\n"
        "        disk = %.*s\n",
        pHeader->volume_id,
        pHeader->start, ::ctime(&startTimeVal),
        pHeader->duration,
        pHeader->length,
        pHeader->lower, pHeader->upper,
        pHeader->timespan_target.time_lower, pHeader->timespan_target.time_upper,
        pHeader->timespan_actual.time_lower, pHeader->timespan_actual.time_upper,
        NUM_ELEMENTS(pHeader->platform_desc.harvester), pHeader->platform_desc.harvester,
        NUM_ELEMENTS(pHeader->platform_desc.os), pHeader->platform_desc.os,
        NUM_ELEMENTS(pHeader->platform_desc.kernel), pHeader->platform_desc.kernel,
        NUM_ELEMENTS(pHeader->platform_desc.platform), pHeader->platform_desc.platform,
        NUM_ELEMENTS(pHeader->platform_desc.bios), pHeader->platform_desc.bios,
        NUM_ELEMENTS(pHeader->platform_desc.cpu), pHeader->platform_desc.cpu,
        NUM_ELEMENTS(pHeader->platform_desc.ram), pHeader->platform_desc.ram,
        NUM_ELEMENTS(pHeader->platform_desc.disk), pHeader->platform_desc.disk);
    }
  }
  virtual void onCompleted(const eOperationStatus /*status*/) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
  }

private:
  const std::shared_ptr<ILogger> m_logger;
  MsgHarvestLog m_harvestLog;
};

CLCommand_ShowHarvestingHistory::CLCommand_ShowHarvestingHistory(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("show-history", logger)
,  m_libPath("")
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_ShowHarvestingHistory::_parseLibPath),
      "PSF library path");
}

bool CLCommand_ShowHarvestingHistory::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}

int CLCommand_ShowHarvestingHistory::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }

  //tss_harv::load history
  const std::shared_ptr<IOperation> op = std::make_shared<Operation_ReadVolume>(m_libPath, PDB_eVolumeID::VOLUME_HARVEST_LOG,
    std::make_shared<LoadHarvestinHistory_Delegate>(m_logger));
  if (op->execute(m_hasher, m_logger))
    return 1;

  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
    "Failed to read harvesting history!");
  return -1;
}

std::string CLCommand_ShowHarvestingHistory::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Prints harvesting history for PSF lib");
}
