#include "CLCommand_Harvest.h"

#include <Client/PlatformBasedClient.h>

#include <Operations/Operation_HarvestData.h>
#include <Operations/Operation_HarvestLogs.h>
#include <Operations/Operation_HarvestSOH.h>
#include <Operations/Operation_HarvestTimingSOH.h>
#include <Operations/Operation_FlushHarvestingHistory.h>

#include <PlatformUtils/PlatformUtils.h>

#include <Utils/psf_utils.h>

#include <climits>
#include <ctime>
#include <cmath>
#include <cinttypes>

class Harvest_Delegate : public IProgressDelegate
{
public:
  Harvest_Delegate(CLCommand_Harvest* pCaller, const std::shared_ptr<ILogger>& logger, const float step)
    : IProgressDelegate()
    , m_pCaller(pCaller)
    , m_logger(logger)
    , m_notificationStep(step)
    , m_lastNotifiedValue(0.f)
    , m_nReportsSent(0u)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual ~Harvest_Delegate() = default;

  virtual void onError(const IOperation* operation, const sHarvestError& errorData) __OVERRIDES__(IProgressDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    //tss_harv::fetch error data
    m_logger->info(operation->getName().c_str(), "Error code=%" PRIu32 "(0x%08x) occurred in filter '%s'",
      errorData.code,
      errorData.code,
      errorData.reporter.c_str());
  }

  virtual void onProgress(const IOperation* operation, const sHarvestProgress& progressData) __OVERRIDES__(IProgressDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const float newProgress = progressData.progress;
    //tss_harv::check if notification step exceeds or completed (all elements processed)
    if (m_nReportsSent == 0u || (::fabs(newProgress - m_lastNotifiedValue) >= m_notificationStep) ||
      (progressData.nElementsProcessed == progressData.nElementsTotal))
    {
      m_nReportsSent++;
      m_lastNotifiedValue = newProgress;
      const double processedDataSizeInMiBytes = (double)progressData.nBytesProcessed / (1024.0 * 1024.0);
      m_logger->info(operation->getName().c_str(), "Progress summary:\n"
        "    Iterations = %" PRIu32 "\n"
        "    Time = %" PRIu32 " milliseconds\n"
        "    Data = %" PRIu64 " bytes (~%.0f MiBytes, ~%.3f GiBytes)\n"
        "    Elements processed = %" PRIu32 " / %" PRIu32 "\n"
        "    Files generated = %lu\n"
        "    Time range = [%" PRId64 ", %" PRId64 "]\n"
        "    Speed = %.2f MiBytes/s",
        progressData.nElementsProcessed,
        progressData.durationMs,
        progressData.nBytesProcessed, processedDataSizeInMiBytes, processedDataSizeInMiBytes / 1024.0,
        progressData.nElementsProcessed, progressData.nElementsTotal,
        progressData.nFilesGenerated,
        progressData.timeRange.lower, progressData.timeRange.upper,
        progressData.speedMiBpSec);
    }
  }

  virtual void onOpReport(const IOperation* operation, const sHarvestOpReport& reportData, const MsgHarvestLog::Header& harvestLog) __OVERRIDES__(IProgressDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const std::string statuses[] = { "COMPLETED", "ABORTED", "FAILED" };
    m_logger->info(__THIS_FUNC__, "Operation '%s' finished with status %s(%" PRIu32 ")", operation->getName().c_str(),
      statuses[reportData.status].c_str(),
      (uint32_t)reportData.status);
    // add history
    if (reportData.status == eOperationStatus::OP_STATUS_COMPLETED &&
        (harvestLog.timespan_actual.time_lower != harvestLog.timespan_actual.time_upper)) //check if any data harvested (Since Last may cut of all the data if no new acquired)
    {
    	m_pCaller->addHarvestLog(harvestLog);
    }
  }

private:
  CLCommand_Harvest* m_pCaller;
  const std::shared_ptr<ILogger> m_logger;
  float m_notificationStep;
  float m_lastNotifiedValue;
  uint32_t m_nReportsSent;
};

class FlushHarvestingHistory_Delegate: public Operation_FlushHarvestingHistory::IDelegate
{
public:
  FlushHarvestingHistory_Delegate(const std::shared_ptr<ILogger>& logger)
  : m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual ~FlushHarvestingHistory_Delegate() = default;

  virtual void onHistoryWritten(IOperation* /*pOperation*/, const MsgHarvestLog::Header& historyHeader) __OVERRIDES__(Operation_FlushHarvestingHistory::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const time_t startTimeVal = static_cast<time_t>(pdb_utils::nanoseconds_to_seconds(historyHeader.start));
    m_logger->info(__THIS_FUNC__, "History written:\n"
      "    volume_id = %" PRIu32 "\n"
      "    start = %" PRId64 " - %s"
      "    duration = %" PRIu64 " ms\n"
      "    length = %" PRIu64 " bytes\n"
      "    range = [%" PRIu32 ", %" PRIu32 "]\n"
      "    target timespan [%" PRId64 ", %" PRId64 "]\n"
      "    actual timespan [%" PRId64 ", %" PRId64 "]\n"
      "    platform:\n"
      "        harvester = %.*s\n"
      "        OS = %.*s\n"
      "        kernel = %.*s\n"
      "        platform = %.*s\n"
      "        BIOS = %.*s\n"
      "        CPU = %.*s\n"
      "        RAM = %.*s\n"
      "        disk = %.*s\n",
      historyHeader.volume_id,
      historyHeader.start, ::ctime(&startTimeVal),
      historyHeader.duration,
      historyHeader.length,
      historyHeader.lower, historyHeader.upper,
      historyHeader.timespan_target.time_lower, historyHeader.timespan_target.time_upper,
      historyHeader.timespan_actual.time_lower, historyHeader.timespan_actual.time_upper,
      NUM_ELEMENTS(historyHeader.platform_desc.harvester), historyHeader.platform_desc.harvester,
      NUM_ELEMENTS(historyHeader.platform_desc.os), historyHeader.platform_desc.os,
      NUM_ELEMENTS(historyHeader.platform_desc.kernel), historyHeader.platform_desc.kernel,
      NUM_ELEMENTS(historyHeader.platform_desc.platform), historyHeader.platform_desc.platform,
      NUM_ELEMENTS(historyHeader.platform_desc.bios), historyHeader.platform_desc.bios,
      NUM_ELEMENTS(historyHeader.platform_desc.cpu), historyHeader.platform_desc.cpu,
      NUM_ELEMENTS(historyHeader.platform_desc.ram), historyHeader.platform_desc.ram,
      NUM_ELEMENTS(historyHeader.platform_desc.disk), historyHeader.platform_desc.disk);
  }

  virtual void onCompleted(IOperation* pOperation, const eOperationStatus status) __OVERRIDES__(Operation_FlushHarvestingHistory::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const std::string statuses[] = { "COMPLETED", "ABORTED", "FAILED" };
    m_logger->info(__THIS_FUNC__, "Operation '%s' finished with status %s(%" PRIu32 ")", pOperation->getName().c_str(),
      statuses[status].c_str(),
      (uint32_t)status);
  }

private:
  const std::shared_ptr<ILogger> m_logger;
};

CLCommand_Harvest::CLCommand_Harvest(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("harvest", logger)
,  m_libPath("")
,  m_bAppendExtension(true)
{
  m_params.lower.time = 0;
  m_params.upper.time = std::numeric_limits<timestamp_t>::max();
  m_params.nHoursPerFile = 1;
  m_params.outputPattern = "${Y}/${N}/${S}/${C}.D/${N}.${S}.${L}.${C}.D.${Y}.${J}"; //SDS pattern
  m_params.nPagesMax = (uint32_t)-1;

  m_harvestLogs.reserve(4); // reserve space for 4 harvest logs (log, seismic, soh, timing soh)

  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseLibPath),
    "PSF library path");
  this->_registerArgument("-l=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseLowerTime),
    "lower time to harvest data from", "0");
  this->_registerArgument("-u=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseUpperTime),
    "upper time to harvest data to", "max(int64_t)");
  this->_registerArgument("-o=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseOutput),
    "output directory. If not specified - output files generation is DISABLED");
  this->_registerArgument("-p=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parsePattern),
    "output pattern:\n"
    "      ${S} is the station name\n" // SCNL order matches historic introduction of these fields
    "      ${C} is the channel name\n"
    "      ${N} is the network name\n"
    "      ${L} is the location name\n"
    "      ${TIME} is the event time in YYYYMMDD_hhmmss format\n"
    "      Date/Time format can also be specified explicitly using the following:\n"
    "        ${Y} is 4-digit year\n"
    "        ${M} is 2-digit month\n"
    "        ${D} is 2-digit day of month\n"
    "        ${J} is 3-digit Julian day(day of year)\n"
    "        ${h} is hour of 2-digit hour of day\n"
    "        ${m} is hour of 2-digit minutes of the hour\n"
    "        ${s} is hour of 2-digit seconds of the minute\n    ",
    m_params.outputPattern);
  this->_registerArgument("-d=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseDuration),
    "data time to be stored per miniSEED file (in hours)", std::to_string(m_params.nHoursPerFile));
  this->_registerArgument("-m=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parsePagesCount),
    "max pages count to harvest/read", "-1 (stands for max amount of pages possible within uint32_t)");
  this->_registerArgument("-ext=", CLCOMMAND_PARSE_HANDLER(CLCommand_Harvest::_parseExtension),
    "append extensions to the generated files (0|1)", "1");
}

void CLCommand_Harvest::addHarvestLog(const MsgHarvestLog::Header& harvestLog)
{
  __DEV_CALLSTACK_FUNC__;
  m_harvestLogs.push_back(harvestLog);
}

bool CLCommand_Harvest::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_Harvest::_parseLowerTime(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.lower.time = static_cast<timestamp_t>(::atoll(arg));
  return true;
}
bool CLCommand_Harvest::_parseUpperTime(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.upper.time = static_cast<timestamp_t>(::atoll(arg));
  return true;
}
bool CLCommand_Harvest::_parseOutput(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.outputDir = PlatformUtils::getInstance()->normalize(std::string(arg));
  return true;
}
bool CLCommand_Harvest::_parsePattern(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.outputPattern = PlatformUtils::getInstance()->normalize(std::string(arg));
  return true; 
}
bool CLCommand_Harvest::_parseDuration(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.nHoursPerFile = (uint32_t)::atoi(arg);
  return true; 
}
bool CLCommand_Harvest::_parsePagesCount(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.nPagesMax = (uint32_t)::atoi(arg);
  return true;
}

bool CLCommand_Harvest::_parseExtension(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  const char flag = static_cast<char>(::atoi(arg));
  m_bAppendExtension = (flag != 0);
  return true;
}

int CLCommand_Harvest::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  // check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(),  eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT,
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }

  // check time range
  if (m_params.lower.time >= m_params.upper.time)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
      "Invalid time range to harvest data set! Upper time must be bigger the lower time");
    return -1;
  }

  // check hours per file
  if (!(m_params.nHoursPerFile > 0))
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "Invalid miniSEED file duration. Must be > 0 hours.");
    return -1;
  }

  // print requested time ranges
  {
    tm lowerTime; psf_utils::gmtime_from_timestamp(m_params.lower.time, &lowerTime);
    char lowerTimeBuf[32];
    std::strftime(lowerTimeBuf, sizeof(lowerTimeBuf), "%a, %d.%m.%Y %H:%M:%S", &lowerTime);
    tm upperTime; psf_utils::gmtime_from_timestamp(m_params.upper.time, &upperTime);
    char upperTimeBuf[32];
    std::strftime(upperTimeBuf, sizeof(upperTimeBuf), "%a, %d.%m.%Y %H:%M:%S", &upperTime);
    m_logger->info(__THIS_FUNC__, "Harvesting data in [%s - %s] time range", lowerTimeBuf, upperTimeBuf);
  }

  const std::shared_ptr<IClient> client = std::make_shared<PlatformBasedClient>(std::string("HarvesterCL v") + HARVCL_getVersionInfo().version_string, m_logger);
  // harvest logs
  {
    sHarvestParams params = m_params;
    params.outputDir = m_params.outputDir.empty() ? "" : PlatformUtils::getInstance()->join(m_params.outputDir, "logs");
    params.outputPattern = (m_bAppendExtension) ? m_params.outputPattern + ".txt" : m_params.outputPattern;
    const std::shared_ptr<IOperation> op = std::make_shared<Operation_HarvestLogs>(m_libPath, params,
      client, std::make_shared<Harvest_Delegate>(this, m_logger, 1.f));
    if (!op->execute(m_hasher, m_logger))
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
        "Failed to harvest logs!");
  }
  
  // harvest data
  {
    sHarvestParams params = m_params;
    params.outputPattern = (m_bAppendExtension) ? m_params.outputPattern + ".mseed" : m_params.outputPattern;
    const std::shared_ptr<IOperation> op = std::make_shared<Operation_HarvestData>(m_libPath, params,
      client, std::make_shared<Harvest_Delegate>(this, m_logger, 1.f));
    if (!op->execute(m_hasher, m_logger))
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
        "Failed to harvest Sensor Input data!");
  }
  
  // harvest SOH
  {
    sHarvestParams params = m_params;
    params.outputDir = m_params.outputDir.empty() ? "" : PlatformUtils::getInstance()->join(m_params.outputDir, "soh");
    params.outputPattern = (m_bAppendExtension) ? m_params.outputPattern + ".mseed" : m_params.outputPattern;
    const std::shared_ptr<IOperation> op = std::make_shared<Operation_HarvestSOH>(m_libPath, params, 0xFFFFFFFF,
      client, std::make_shared<Harvest_Delegate>(this, m_logger, 1.f));
    if (!op->execute(m_hasher, m_logger))
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to harvest Health Input data!");
  }

  // harvest Timing SOH
  {
    sHarvestParams params = m_params;
    params.outputDir = m_params.outputDir.empty() ? "" : PlatformUtils::getInstance()->join(m_params.outputDir, "timing_soh");
    params.outputPattern = (m_bAppendExtension) ? m_params.outputPattern + ".mseed" : m_params.outputPattern;
    const std::shared_ptr<IOperation> op = std::make_shared<Operation_HarvestTimingSOH>(m_libPath, params,
      client, std::make_shared<Harvest_Delegate>(this, m_logger, 1.f));
    if (!op->execute(m_hasher, m_logger))
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to harvest ClockStatus data!");
  }

  // flush harvesting history to PDB
  {
    const std::shared_ptr<IOperation> op = std::make_shared<Operation_FlushHarvestingHistory>(m_libPath, m_harvestLogs,
      std::make_shared<FlushHarvestingHistory_Delegate>(m_logger));
    if (!op->execute(m_hasher, m_logger))
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to flush harvesting history!");
  }

  return 1;
}

std::string CLCommand_Harvest::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Harvests data from PSF lib");
}
