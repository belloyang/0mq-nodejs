#include "CLCommand_GenerateData.h"

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>
#include <Utils/psf_utils.h>

#include <DataFilters/GraphBuilder.h>
#include <DataFilters/Generators/gap_generators/GapGenerator_Random.h>

#include <climits>
#include <map>
#include <cinttypes>

CLCommand_GenerateData::CLCommand_GenerateData(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("generate-data", logger)
,  m_libPath("")
,  m_channelsMask((1 << PDB_MAXIMUM_CHANNELS_COUNT) - 1)
,  m_nPackets(0)
,  m_useBigEndian(true)
,  m_startTimestamp(psf_utils::get_timestamp())
,  m_minGapSecs(0)
,  m_maxGapSecs(0)
,  m_gapProbability(0.f)
,  m_signalLevel( (double)( (1ul << 27) - 1 ) ) // Pegasus is a 28-bit digitizer. Full-scale counts is +/- (2^27 - 1).
,  m_noiseLevel(0.0)
,  m_encoding("steim2")
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseLibPath),
    "PSF library path");
  this->_registerArgument("-n=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parsePacketsCount),
    "packets count. -1 = auto-detected count to fill up the volume entirely");
  this->_registerArgument("-c=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseChannelsMask),
    "8-bits channels mask 0b0000|Ch3|Ch2|Ch1|Ch0, where Ch# is channel enabled bit (0 - disabled, 1 - enabled)", "0b00001111 - all 4 channels enabled");
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseStartTimestamp),
    "lower timestamp for the data generation (in nanoseconds)", "current POSIX timestamp");
  this->_registerArgument("-le", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseLittleEndian),
    "generate steim frames in little-endian", "big-endian");

  this->_registerArgument("-min_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseMinGapSecs),
    "minimum gap to be generated (in seconds)", "0");
  this->_registerArgument("-max_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseMaxGapSecs),
    "maximum gap to be generated (in seconds)", "0");
  this->_registerArgument("-prob_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseGapProbability),
    "gap probability (in [0.0, 1.0] range)", "0.0");

  this->_registerArgument("-signal=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseSignalLevel),
    "signal peak level (counts, >= 0.0)", "2^27 - 1");
  this->_registerArgument("-noise=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseNoiseLevel),
    "noise RMS level (counts, >= 0.0)", "0.0");

  this->_registerArgument("-e=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateData::_parseEncoding),
    "encoding to be used for data generation (steim1 | steim2)", "steim2");
}

bool CLCommand_GenerateData::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_GenerateData::_parseChannelsMask(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_channelsMask = (uint8_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateData::_parsePacketsCount(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_nPackets = ::atoi(arg);
  return true; 
}
bool CLCommand_GenerateData::_parseStartTimestamp(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_startTimestamp = ::atoll(arg);
  return true;  
}
bool CLCommand_GenerateData::_parseLittleEndian(const char* /*arg*/)
{
  __DEV_CALLSTACK_FUNC__;
  m_useBigEndian = false;
  return true;
}
bool CLCommand_GenerateData::_parseMinGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_minGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateData::_parseMaxGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_maxGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateData::_parseGapProbability(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_gapProbability = (float)::atof(arg);
  return true;
}
bool CLCommand_GenerateData::_parseSignalLevel(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_signalLevel = ::atof(arg);
  return true;
}
bool CLCommand_GenerateData::_parseNoiseLevel(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_noiseLevel = ::atof(arg);
  return true;
}
bool CLCommand_GenerateData::_parseEncoding(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_encoding = std::string(arg);
  return true;
}

int CLCommand_GenerateData::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_nPackets == 0)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT,
      "Number of packets is not set ('-n=<count>')");
    return -1;
  }
  if ((m_channelsMask & ((1 << PDB_MAXIMUM_CHANNELS_COUNT) - 1)) == 0) //check if none of channels is enabled
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT, 
      "Channels mask is invalid. All channels are disabled.");
    return -1;    
  }
  if (m_minGapSecs > m_maxGapSecs)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Minimum gap (%" PRIu32 " seconds) is bigger then maximum gap (%" PRIu32 " seconds)!!", m_minGapSecs, m_maxGapSecs);
    return -1;
  }
  if (m_gapProbability < 0.0 || m_gapProbability > 1.0) {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Gap probability must be in the range [0,+1]");
    return -1;
  }
  if (m_signalLevel < 0.0) {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Signal peak level must be >= 0.0 counts");
    return -1;
  }
  if (m_noiseLevel < 0.0) {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Noise RMS level must be >= 0.0 counts");
    return -1;
  }
  //analyze media type passed
  PDB_eMediaType_t mediaType;
  {
    static const std::map<std::string, PDB_eMediaType_t> mediaTypeNamesMap = {
      {"steim1", PDB_eMediaType_t::MEDIA_STEIM1},
      {"steim2", PDB_eMediaType_t::MEDIA_STEIM2},
    };
    const auto foundIt = mediaTypeNamesMap.find(m_encoding);
    if (foundIt == mediaTypeNamesMap.end())
    {
      m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
        "Encoding (-e='%s') is invalid", m_encoding.c_str());
      return -1;
    }
    mediaType = foundIt->second;
  }

  //tss_harv::prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harv::create PSF library
  std::shared_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  //tss_harv::restoring library
  if (pLibrary && pLibrary->restore())
  {
    GraphBuilder graphBuilder(m_logger);
    //tss_harv::build data generation chain
    const auto chain = graphBuilder.buildSensorInputGenerationChain(pLibrary,
      m_startTimestamp, m_channelsMask, m_nPackets,
      mediaType, m_useBigEndian,
      std::make_shared<GapGenerator_Random>(m_minGapSecs, m_maxGapSecs, m_gapProbability),
      m_signalLevel, m_noiseLevel);
    if (chain != nullptr)
      chain->run(nullptr);
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
      "'%s' is not a PSF library. Use 'format' command to create it", libPath.c_str());
  }

  return 1;
}

std::string CLCommand_GenerateData::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Generates and dumps data to PSF lib");
}
