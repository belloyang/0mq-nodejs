#include "CLCommand_DigitizerInfo.h"

#include <Operations/Operation_GetDigitizerInfo.h>

#include <cinttypes>
#include <ctime>

#include <Utils/psf_utils.h>

class GetDigitizerInfo_Delegate : public Operation_GetDigitizerInfo::IDelegate
{
public:
  GetDigitizerInfo_Delegate(const std::shared_ptr<ILogger>& logger)
    : m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~GetDigitizerInfo_Delegate()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual void onPSFInfoLoaded(IOperation* pOperation, const sPSFLibraryHeader_t& header, const std::vector<sVolumeInfo>& volumes) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    // get creation time as string
    char creation[64]; psf_utils::timestamp_to_string(creation, NUM_ELEMENTS(creation), header.creationTime);
    //tss_harv::print PSF lib info
    m_logger->info(pOperation->getName().c_str(), "Library info:\n"
        "    PSF version = %" PRIu32 "\n"
        "    creation = %s\n"
        "    volumes count = %" PRIu32 "\n"
        "    hash = 0x%08x",
        header.psfVersion,
        creation,
        header.nVolumes,
        header.hash.value);

    //tss_harv::print volumes info
    for (auto& volume : volumes)
    {
      m_logger->info(pOperation->getName().c_str(), "Volume '%.*s' info:\n"
          "    index = %" PRIu32 "\n"
          "    unique ID = %" PRIu32 "\n"
          "    start chapter = %" PRIu32 "\n"
          "    size = %" PRIu32" chapters (%" PRIu32 " MiB)",
          NUM_ELEMENTS(volume.label), volume.label,
          volume.index,
          volume.uniqueId,
          volume.startChapter,
          volume.sizeInChapters, static_cast<uint32_t>(volume.sizeInChapters) * PSF_CHAPTER_SIZE_MIBYTES);
    }
  }

  virtual void onInfoLoaded(IOperation* pOperation, const MsgDigitizerStart* pStart) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    const MsgDigitizerStart::Header* const pHeader = pStart->getHeader();
    const time_t timeVal = static_cast<time_t>(pdb_utils::nanoseconds_to_seconds(pHeader->timestamp));
    m_logger->info(pOperation->getName().c_str(), "Digitizer info:\n"
      "    timestamp = %" PRId64 " - %s"
      "    bin = [%.*s]\n"
      "    serial = '%.*s'\n"
      "    firmware = '%.*s'\n"
      "    station = '%.*s'\n"
      "    channels count = %" PRIu32,
      pHeader->timestamp, ::ctime(&timeVal),
      NUM_ELEMENTS(pHeader->bin), pHeader->bin,
      NUM_ELEMENTS(pHeader->serial), pHeader->serial,
      NUM_ELEMENTS(pHeader->firmware), pHeader->firmware,
      NUM_ELEMENTS(pHeader->station), pHeader->station,
      static_cast<uint32_t>(pHeader->n_channels));
    // print channels info
    for (uint8_t channelIdx = 0; channelIdx < pHeader->n_channels; ++channelIdx)
    {
      const MsgDigitizerStart::Header::sChannel& channel = pHeader->channels[channelIdx];
      m_logger->info(pOperation->getName().c_str(), "Channel #%" PRIu32 " info:\n"
          "    name = '%.*s'\n"
          "    location = '%.*s'",
          static_cast<uint32_t>(channelIdx + 1),
          NUM_ELEMENTS(channel.name), channel.name,
          NUM_ELEMENTS(channel.location), channel.location);
    }
  }
  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus /*status*/) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
  }

private:
  const std::shared_ptr<ILogger> m_logger;
};

CLCommand_DigitizerInfo::CLCommand_DigitizerInfo(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("digitizer-info", logger)
,  m_libPath("")
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_DigitizerInfo::_parseLibPath),
    "PSF library path");
}

bool CLCommand_DigitizerInfo::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}

int CLCommand_DigitizerInfo::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT,
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }

  const std::shared_ptr<Operation_GetDigitizerInfo> op = std::make_shared<Operation_GetDigitizerInfo>(m_libPath, std::make_shared<GetDigitizerInfo_Delegate>(m_logger));
  if (op->execute(m_hasher, m_logger))
    return 1;

  m_logger->warning(__THIS_FUNC__, "No digitizer info found!");
  return -1;
}

std::string CLCommand_DigitizerInfo::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Prints digitizer's info");
}
