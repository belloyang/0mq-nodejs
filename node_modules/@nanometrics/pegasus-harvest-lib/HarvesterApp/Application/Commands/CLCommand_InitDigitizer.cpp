#define NOMINMAX

#include "CLCommand_InitDigitizer.h"

#include <PlatformUtils/PlatformUtils.h>
#include <IOContext/io_contexts.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>
#include <Library/PSFStream.h>
#include <Utils/psf_utils.h>

#include <DataTypes/DigitizerOperationLog/MsgDigitizerStart.h>
#include <DataTypes/DigitizerOperationLog/MsgOpaqueData.h>

#include "external/gzip-1.0.0/compress.hpp"

#include <ctime>
#include <cinttypes>

CLCommand_InitDigitizer::CLCommand_InitDigitizer(const std::shared_ptr<ILogger>& logger)
: CLCommandBase("init-digitizer", logger)
, m_libPath("")
, m_startTimestamp(psf_utils::get_timestamp())
, m_opaqueDataPath("")
, m_gzipData(false)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_InitDigitizer::_parseLibPath),
    "PSF library path");
  this->_registerArgument("-o=", CLCOMMAND_PARSE_HANDLER(CLCommand_InitDigitizer::_parseOpaqueDataPath),
    "opaque data file path", "<empty>");
  this->_registerArgument("-gzip", CLCOMMAND_PARSE_HANDLER(CLCommand_InitDigitizer::_parseGZip),
    "gzips data before pushing to PDB", "<false>");
  ::srand((uint32_t)::time(nullptr));
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_InitDigitizer::_parseStartTimestamp),
    "timestamp for deployment start & opaque data (in nanoseconds)", "current POSIX timestamp");
  ::srand((uint32_t)::time(nullptr));
}

bool CLCommand_InitDigitizer::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_InitDigitizer::_parseStartTimestamp(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_startTimestamp = ::atoll(arg);
  return true;
}
bool CLCommand_InitDigitizer::_parseOpaqueDataPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_opaqueDataPath = std::string(arg);
  return true;
}
bool CLCommand_InitDigitizer::_parseGZip(const char* /*arg*/)
{
  __DEV_CALLSTACK_FUNC__;
  m_gzipData = true;
  return true;
}

int CLCommand_InitDigitizer::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }

  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  std::unique_ptr<PSFLibrary> pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  //tss_harv::restoring library
  if (pLibrary == nullptr || !pLibrary->restore())
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "'%s' is not a PSF library. Use 'format' command to create it", libPath.c_str());
    return -1;
  }

  std::unique_ptr<PSFVolume> pOpLogVolume(pLibrary->findVolumeByID(PDB_eVolumeID::VOLUME_OPERATION_LOG));
  if (pOpLogVolume == nullptr)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Failed to find 'VOLUME_OPERATION_LOG' volume to generate digitizer start message");
    return -1;
  }

  PSFStream volumeStream(pOpLogVolume.get(), pOpLogVolume->getLogger());
  //tss_harv::write start event
  if (!this->_writeDigitizerStart(volumeStream))
    return -1;
  //tss_harv::write opaque data (if specified)
  if (!m_opaqueDataPath.empty() && !this->_writeOpaqueData(volumeStream))
    return -1;
  
  return 1;
}

bool CLCommand_InitDigitizer::_writeDigitizerStart(PSFStream& volumeStream)
{
  __DEV_CALLSTACK_FUNC__;
  MsgDigitizerStart::Header header;
  //tss_harv::init start header with defaults
  {
    ::memset(&header, 0, sizeof(header));
    header.timestamp = m_startTimestamp;
    header.reason = (MsgDigitizerStart::Header::eStartReason)(::rand() % MsgDigitizerStart::Header::eStartReason::START_REASONS_COUNT);
    ::snprintf(header.serial, NUM_ELEMENTS(header.serial), "%06" PRIu32, static_cast<uint32_t>(::rand()));
    ::strncpy(header.bin, "Pegasus LA", NUM_ELEMENTS(header.bin));
    ::strncpy(header.firmware, "0.7.5-RC", NUM_ELEMENTS(header.firmware));
    ::strncpy(header.network, "NE", NUM_ELEMENTS(header.network));
    ::strncpy(header.station, "STATI", NUM_ELEMENTS(header.station));
    header.n_channels = 4;
    for (uint8_t channelIdx = 0; channelIdx < header.n_channels; ++channelIdx)
    {
      auto& channel = header.channels[channelIdx];
      ::strncpy(channel.location, "\0\0", NUM_ELEMENTS(channel.location));
      const char chName[] = { 'C', 'h', (char)(channelIdx + '1') };
      ::strncpy(channel.name, chName, NUM_ELEMENTS(channel.name));
    }
    header.offline = -1;
    //tss_harv::just set some sensible bin number for the time being
  }

  //tss_harv::create start message and write to it volume's stream
  {
    std::unique_ptr<MsgDigitizerStart> const start(new MsgDigitizerStart());
    if (start != nullptr && start->init(header))
    {
      //tss_harv::lock the buffer
      size_t bufSize = 0; void* pBuffer = nullptr;
      if (start->lockBuffer(&pBuffer, &bufSize))
      {
        //tss_harv::write the buffer to the volume
        const size_t nBytesWritten = volumeStream.write(start->getType(), pBuffer, bufSize);
        if (nBytesWritten <= 0)
        {
          m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
            "Failed to dump 'MsgDigitizerStart' to volume");
          return false;
        }
        else
        {
          m_logger->info(__THIS_FUNC__, "Digitizer start data has been dumped:\n"
            "    start = %" PRId64 "\n"
            "    bin = [%.*s]\n"
            "    firmware = %.*s\n"
            "    serial = %.*s\n",
            header.timestamp,
            NUM_ELEMENTS(header.bin), header.bin,
            NUM_ELEMENTS(header.firmware), header.firmware,
            NUM_ELEMENTS(header.serial), header.serial);
        }
      }
      else
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
          "Failed to lock 'MsgDigitizerStart' object buffer");
        return false;
      }
    }
    else
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to create 'MsgDigitizerStart' object");
      return false;
    }
  }

  return true;
}

bool CLCommand_InitDigitizer::_writeOpaqueData(PSFStream& volumeStream)
{
  __DEV_CALLSTACK_FUNC__;
  const std::string& opaqueDataPath = PlatformUtils::getInstance()->resolvePath(m_opaqueDataPath);
#if defined(DEV_PLATFORM_LINUX)
    const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(opaqueDataPath, O_RDONLY | O_LARGEFILE, m_logger);
#elif defined(DEV_PLATFORM_MACOS)
    const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_POSIX>(opaqueDataPath, O_RDONLY, m_logger);
#elif defined(DEV_PLATFORM_WIN32)
    const std::shared_ptr<IIOContext> fileContext = std::make_shared<FileIOContext_Windows>(opaqueDataPath, GENERIC_READ, 0, OPEN_EXISTING, m_logger);
#endif
  const uint64_t fileSize = fileContext->getSize();
  if (fileSize == 0ULL)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "Failed to open '%s' file for opaque data", opaqueDataPath.c_str());
    return false;
  }
  const uint32_t maxSize = sizeof(MsgOpaqueData::Header::OpaqueData);
  if (fileContext->getSize() > maxSize)
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "File '%s' is too big (size = %" PRIu64 ", maximum = %" PRIu32 ")", 
      opaqueDataPath.c_str(),
      fileSize, maxSize);
    return false;
  }
    
  //tss_harv::create message and write to it's volume's stream
  std::shared_ptr<MsgOpaqueData::Header> header_ptr = std::make_shared<MsgOpaqueData::Header>(); // on the heap since might be too large for stack
  MsgOpaqueData::Header& header(*header_ptr);
  //tss_harv::init start header with defaults
  {
    ::memset(&header, 0, sizeof(header));
    header.timestamp = m_startTimestamp;
    // if no gzip needed -> push data directly
    if (!m_gzipData)
    {
      header.opaque_size = static_cast<uint32_t>(fileSize);
      fileContext->readBlock(0, header.opaque_size, header.opaque_data.buffer);
    }
    else //compress data
    {
      char* pBuffer = reinterpret_cast<char*>(::malloc(fileSize));
      fileContext->readBlock(0, fileSize, pBuffer);
      const std::string& compressedData = gzip::compress(pBuffer, fileSize);
      ::free(pBuffer);
      header.opaque_size = compressedData.length();
      ::memcpy(header.opaque_data.buffer, compressedData.c_str(), header.opaque_size);
    }
  }
  std::unique_ptr<MsgOpaqueData> const opaqueData(new MsgOpaqueData());
  if (opaqueData != nullptr && opaqueData->init(header))
  {
    //tss_harv::lock the buffer
    size_t bufSize = 0; void* pBuffer = nullptr;
    if (opaqueData->lockBuffer(&pBuffer, &bufSize))
    {
      //tss_harv::write the buffer to the volume
      const size_t nBytesWritten = volumeStream.write(opaqueData->getType(), pBuffer, bufSize);
      if (nBytesWritten <= 0)
      {
        m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
          "Failed to dump 'MsgOpaqueData' to volume");
        return false;
      }
      else
      {
        m_logger->info(__THIS_FUNC__, "Opaque data has been dumped:\n"
          "    start = %" PRId64 "\n"
          "    size = %" PRIu32,
          header.timestamp,
          header.opaque_size);
      }
    }
    else
    {
      m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to lock 'MsgOpaqueData' object buffer");
      return false;
    }
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
      "Failed to create 'MsgOpaqueData' object");
    return false;
  }

  return true;
}

std::string CLCommand_InitDigitizer::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Initializes digitizer with some startup info");
}
