#include "SerialPort_POSIX.h"

#include <PlatformUtils/PlatformUtils.h>

#include <unistd.h>
#include <fcntl.h>
#include <cinttypes>
#include <termios.h>

#include <map>

namespace
{
  const char THIS_CLASS_NAME[] = "SerialPort_POSIX";
  const uint32_t RX_TIMEOUT_TENTHS_SECOND = 5; // 5/10 second
  const std::map<uint32_t, speed_t> BAUD_RATES_MAP = {
    { 57600,   B57600 },
    { 115200,  B115200 },
    { 230400,  B230400 },
    { 460800,  B460800 },
    { 500000,  B500000 },
    { 576000,  B576000 },
    { 921600,  B921600 },
    { 1000000, B1000000 },
    { 1152000, B1152000 },
    { 1500000, B1500000 },
    { 2000000, B2000000 },
    { 2500000, B2500000 },
    { 3000000, B3000000 },
    { 3500000, B3500000 },
    { 4000000, B4000000 }
  };
  const uint32_t RX_RETRIES_COUNT = 5u;
  const uint32_t TX_RETRIES_COUNT = 5u;
}

SerialPort_POSIX::SerialPort_POSIX(const std::string& path, const uint32_t baudRate, const std::shared_ptr<ILogger>& logger)
: ISerialPort()
, m_path(path)
, m_baudRate(baudRate)
, m_handle(0)
, m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_handle = ::open(m_path.c_str(), O_RDWR | O_NOCTTY | O_SYNC);
  if (m_handle > 0)
  {
    m_logger->info(THIS_CLASS_NAME, " '%s' opened", m_path.c_str());
    // configure
    struct termios tty;
    if (::tcgetattr(m_handle, &tty) < 0)
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(THIS_CLASS_NAME, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Error from 'tcgetattr' (%" PRIu32 "): %s",
        errorCode, PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      return;
    }

    /* The following corresponds to:
       stty -F <m_path. e.i:/dev/ttyUSB1> speed <m_baudRate. e.i: 115200> cs8 -cstopb -parenb
     */
    const auto& baudRateIt = BAUD_RATES_MAP.find(m_baudRate);
    if (baudRateIt != BAUD_RATES_MAP.end())
    {
      ::cfsetospeed(&tty, baudRateIt->second);
      ::cfsetispeed(&tty, baudRateIt->second);
    }
    else
    {
      m_logger->warning(THIS_CLASS_NAME, "Unsupported baud rate '%" PRIu32 "'. Default one won't be changed", m_baudRate);
    }
    // see https://man7.org/linux/man-pages/man3/termios.3.html for details
    tty.c_cflag |= (CLOCAL | CREAD); // ignore modem controls
    tty.c_cflag &= ~CSIZE;
    tty.c_cflag |= CS8;      // 8-bit characters
    tty.c_cflag &= ~PARENB;  // no parity bit
    tty.c_cflag &= ~CSTOPB;  // only need 1 stop bit
    tty.c_cflag &= ~CRTSCTS; // no hardware flowcontrol
    // setup for non-canonical mode
    tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);
    tty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    tty.c_oflag &= ~OPOST;
    // configure 'read with timeout'
    tty.c_cc[VMIN] = 0;
    tty.c_cc[VTIME] = RX_TIMEOUT_TENTHS_SECOND;
    if (tcsetattr(m_handle, TCSANOW, &tty) != 0)
    {
      const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
      m_logger->error(THIS_CLASS_NAME, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
        "Error from 'tcsetattr': %s",
        PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
      return;
    }
    m_logger->info(THIS_CLASS_NAME, "Serial port '%s' opened (handle=%d)",
      path.c_str(), m_handle);
  }
  else
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->error(THIS_CLASS_NAME, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode, "Failed to open '%s' (%" PRIu32 ": %s)",
      m_path.c_str(),
      errorCode, PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
}

SerialPort_POSIX::~SerialPort_POSIX()
{
  __DEV_CALLSTACK_FUNC__;
  if (m_handle > 0)
  {
    ::close(m_handle);
  }
}

uint32_t SerialPort_POSIX::send(const void* buffer, const uint32_t size)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t nBytesTotal = 0u;
  if ((m_handle > 0) && (buffer != nullptr) && (size > 0u))
  {
    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(buffer);
    while (nBytesTotal < size)
    {
      uint32_t attempts = 0u;
      while (attempts <= TX_RETRIES_COUNT)
      {
        const ssize_t ret = ::write(m_handle, ptr, size - nBytesTotal);
        if (ret == -1) // report error and retry
        {
          const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
          m_logger->error(THIS_CLASS_NAME, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
            "Error from 'write' (%" PRIu32 "): %s",
            errorCode, PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
          ++attempts;
          continue;
        }
        if (ret == 0) // write not satisfied (interrupted by signal handler, etc.)
        {
          return nBytesTotal;
        }
        // update progress and pointer
        nBytesTotal += static_cast<uint32_t>(ret);
        ptr += static_cast<uint32_t>(ret);
      }
    }
  }
  return nBytesTotal;
}

uint32_t SerialPort_POSIX::receive(void* buffer, const uint32_t size)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t nBytesTotal = 0u;
  if ((m_handle > 0) && (buffer != nullptr) && (size > 0u))
  {
    uint8_t* ptr = reinterpret_cast<uint8_t*>(buffer);
    while (nBytesTotal < size)
    {
      uint32_t attempts = 0u;
      while (attempts <= RX_RETRIES_COUNT)
      {
        const ssize_t ret = ::read(m_handle, ptr, size - nBytesTotal);
        if (ret == -1) // report error and retry
        {
          const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
          m_logger->error(THIS_CLASS_NAME, eErrorCategory::ERROR_CATEGORY_SYSTEM, errorCode,
            "Error from 'read' (%" PRIu32 "): %s",
            errorCode, PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
          ++attempts;
          continue;
        }
        if (ret == 0) // read not satisfied (timeout (termios VTIME) occurred)
        {
          return nBytesTotal;
        }
        // update progress and pointer
        nBytesTotal += static_cast<uint32_t>(ret);
        ptr += static_cast<uint32_t>(ret);
      }
    }
  }
  return nBytesTotal;
}
