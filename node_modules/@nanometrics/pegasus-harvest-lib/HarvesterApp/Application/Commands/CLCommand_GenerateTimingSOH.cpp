#include "CLCommand_GenerateTimingSOH.h"

#include <DataFilters/Generators/gap_generators/GapGenerator_Random.h>

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>

#include <DataFilters/GraphBuilder.h>

#include <Utils/psf_utils.h>

CLCommand_GenerateTimingSOH::CLCommand_GenerateTimingSOH(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("generate-timing-soh", logger)
,  m_libPath("")
,  m_nPackets(0)
,  m_startTimestamp(psf_utils::get_timestamp())
,  m_minGapSecs(0)
,  m_maxGapSecs(0)
,  m_gapProbability(0.f)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parseLibPath),
    "PSF library path");
  this->_registerArgument("-n=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parsePacketsCount),
    "packets count. -1 - auto-calculated to fill up the volume entirely");
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parseStartTimestamp),
    "lower timestamp for the SOH packets generation (in nanoseconds)", "current POSIX timestamp");
  
  this->_registerArgument("-min_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parseMinGapSecs),
    "minimum gap to be generated (in seconds)", "0");
  this->_registerArgument("-max_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parseMaxGapSecs),
    "maximum gap to be generated (in seconds)", "0");
  this->_registerArgument("-prob_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateTimingSOH::_parseGapProbability),
    "gap probability (in [0.0, 1.0] range)", "0.0");
}

bool CLCommand_GenerateTimingSOH::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_GenerateTimingSOH::_parsePacketsCount(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_nPackets = ::atoi(arg);
  return true; 
}
bool CLCommand_GenerateTimingSOH::_parseStartTimestamp(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_startTimestamp = ::atoll(arg);
  return true;
}

bool CLCommand_GenerateTimingSOH::_parseMinGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_minGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateTimingSOH::_parseMaxGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_maxGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateTimingSOH::_parseGapProbability(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_gapProbability = (float)::atof(arg);
  return true;
}

int CLCommand_GenerateTimingSOH::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_nPackets == 0)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "No timing SOH packets count set ('-n=<count>)");
    return -1;
  }

  //tss_harv::prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harv::create PSF library
  std::shared_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  //tss_harv::restoring library
  if (pLibrary && pLibrary->restore())
  {
    GraphBuilder graphBuilder(m_logger);
    //tss_harv::build timing SOH (CLockStatus) data generation chain
    const auto chain = graphBuilder.buildClockStatusGenerationChain(pLibrary, m_startTimestamp, m_nPackets,
      std::make_shared<GapGenerator_Random>(m_minGapSecs, m_maxGapSecs, m_gapProbability));
    if (chain != nullptr)
      chain->run(nullptr);
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
      "Failed to restore PSF library at '%s'", m_libPath.c_str());
  }

  return 1;
}

std::string CLCommand_GenerateTimingSOH::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Generates and dumps Timing SOH (ClockStatus) data (packets) to PSF lib");  
}
