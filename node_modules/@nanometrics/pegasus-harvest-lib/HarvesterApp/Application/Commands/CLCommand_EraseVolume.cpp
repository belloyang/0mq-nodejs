#include "CLCommand_EraseVolume.h"

#include <Operations/Operation_EraseVolume.h>

#include <Utils/psf_utils.h>

#include <cstring> // strncmp
#include <cinttypes>
#include <ctime>

class EraseVolume_Delegate : public Operation_EraseVolume::IDelegate
{
public:
  EraseVolume_Delegate(const uint32_t volumeId, const std::shared_ptr<ILogger>& logger)
    : m_logger(logger)
    , m_volumeId(volumeId)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~EraseVolume_Delegate()
  {
    __DEV_CALLSTACK_FUNC__;
  }

  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus status) __OVERRIDES__(GetVolumeInfo_Delegate::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    if (status == eOperationStatus::OP_STATUS_COMPLETED)
    {
      m_logger->info(__THIS_FUNC__, "Volume %" PRIu32 " erased", m_volumeId);
    }
    else if (status == eOperationStatus::OP_STATUS_FAILED)
    {
      m_logger->warning(__THIS_FUNC__, "Failed to erase volume %" PRIu32, m_volumeId);
    }
  }

private:
  const std::shared_ptr<ILogger> m_logger;
  const uint32_t m_volumeId;
};


CLCommand_EraseVolume::CLCommand_EraseVolume(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("erase-volume", logger)
,  m_libPath("")
,  m_volumeId((uint32_t)-1)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_EraseVolume::_parseLibPath), "PSF library path");
  //tss_harvcl::register "-id" argument with some common volume IDs information
  {
    char* volumeIDSStr = (char*)::malloc(512);
    ::snprintf(volumeIDSStr, 512,
      "        %" PRIu32 " = VOLUME_SENSOR_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_HEALTH_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_CLOCK_STATUS\n"
      "        %" PRIu32 " = VOLUME_HEALTH_DIGEST\n"
      "        %" PRIu32 " = VOLUME_OPERATION_LOG\n"
      "        %" PRIu32 " = VOLUME_HARVEST_LOG\n"
      "        %" PRIu32 " = VOLUME_FORENSIC_LOG\n"
      "        %" PRIu32 " = VOLUME_HEALTH_STATE\n"
      "        %" PRIu32 " = VOLUME_HEALTH_PDF\n"
      "        %" PRIu32 " = VOLUME_SEISMIC_PDF",
      PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES,
      PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES,
      PDB_eVolumeID::VOLUME_CLOCK_STATUS,
      PDB_eVolumeID::VOLUME_HEALTH_DIGEST,
      PDB_eVolumeID::VOLUME_OPERATION_LOG,
      PDB_eVolumeID::VOLUME_HARVEST_LOG,
      PDB_eVolumeID::VOLUME_FORENSIC_LOG,
      PDB_eVolumeID::VOLUME_HEALTH_STATE,
      PDB_eVolumeID::VOLUME_HEALTH_PDF,
      PDB_eVolumeID::VOLUME_SEISMIC_PDF);
    this->_registerArgument("-id=", CLCOMMAND_PARSE_HANDLER(CLCommand_EraseVolume::_parseVolumeId), "volume integer ID. e.i:\n" + std::string(volumeIDSStr));
    ::free(volumeIDSStr);
  }
}

bool CLCommand_EraseVolume::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_EraseVolume::_parseVolumeId(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_volumeId = ::atoi(arg);
  return true;
}

int CLCommand_EraseVolume::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_volumeId == (uint32_t)-1)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Volume ID (integer) not specified ('-id=<volume ID>')");
    return -1;
  }

  const std::shared_ptr<Operation_EraseVolume> op = std::make_shared<Operation_EraseVolume>(m_libPath, m_volumeId,
    std::make_shared<EraseVolume_Delegate>(m_volumeId, m_logger));
  if (op->execute(m_hasher, m_logger))
    return 1;

  return -1;
}

std::string CLCommand_EraseVolume::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Erases volume data");
}
