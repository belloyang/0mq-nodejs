#include "CLCommand_Telemetry.h"

#include "telemetry/TelemetryService_TimeSeries.h"
#include "telemetry/TelemetryService_SOH.h"
#include "telemetry/TelemetryService_Info.h"
#if defined(DEV_PLATFORM_LINUX)
  #include "posix/SerialPort_POSIX.h"
#endif
#include <IResponseBufferProvider.hpp>

#include <PlatformUtils/PlatformUtils.h>

#include <thread>
#include <cinttypes>
#include <iostream>
#include <string>
#include <signal.h>
#include <chrono>

namespace
{
  const char THIS_CLASS_NAME[] = "CLCommand_Telemetry";
  const uint32_t DEFAULT_BAUD_RATE = 115200;
}

class ResponseBufferProvider_Preallocated : public IResponseBufferProvider
{
public:
  virtual MsgSensorInput::Header* getTimeSeriesBuffer() __OVERRIDES__(IResponseBufferProvider) { return &m_sensorInput; }
  virtual LiveSohNotificationData* getSohBuffer() __OVERRIDES__(IResponseBufferProvider) { return &m_soh; }
  virtual DigitizerInfo* getInfoBuffer() __OVERRIDES__(IResponseBufferProvider) { return &m_info; }
private:
  MsgSensorInput::Header m_sensorInput;
  LiveSohNotificationData m_soh;
  DigitizerInfo m_info;
};

CLCommand_Telemetry::CLCommand_Telemetry(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("telemetry", logger)
,  m_portPath("")
,  m_baudRate(DEFAULT_BAUD_RATE)
,  m_bStandalone(false)
,  m_commands{
    { "quit",  Command{ "quit application",    Command::Functor(&CLCommand_Telemetry::_quit, this) } },
    { "help",  Command{ "print commands list", Command::Functor(&CLCommand_Telemetry::_help, this) } },
  }
,  m_bQuitRequested(false)
,  m_bReceiverStopped(true)
{
  __DEV_CALLSTACK_FUNC__;
  // initialize harvest params
  m_params.nHoursPerFile = 24u;
  m_params.outputDir = "./";
  m_params.outputPattern = "${Y}/${N}/${S}/${C}.D/${N}.${S}.${L}.${C}.D.${Y}.${J}";
  m_params.lower.sequence_number = PSF_SEQUENCE_NUMBER_INVALID;
  m_params.lower.time = 0ll;
  m_params.upper.sequence_number = PSF_SEQUENCE_NUMBER_INVALID;
  m_params.upper.time = std::numeric_limits<timestamp_t>::max();
  // register command line options
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parsePortPath),
    "serial port path");
  this->_registerArgument("-b=", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parseBaudRate),
    "baud rate", std::to_string(m_baudRate));
  this->_registerArgument("-o=", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parseOutput),
    "output directory", m_params.outputDir);
  this->_registerArgument("-p=", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parsePattern),
    "output pattern:\n"
    "      ${S} is the station name\n" // SCNL order matches historic introduction of these fields
    "      ${C} is the channel name\n"
    "      ${N} is the network name\n"
    "      ${L} is the location name\n"
    "      ${TIME} is the event time in YYYYMMDD_hhmmss format\n"
    "      Date/Time format can also be specified explicitly using the following:\n"
    "        ${Y} is 4-digit year\n"
    "        ${M} is 2-digit month\n"
    "        ${D} is 2-digit day of month\n"
    "        ${J} is 3-digit Julian day(day of year)\n"
    "        ${h} is hour of 2-digit hour of day\n"
    "        ${m} is hour of 2-digit minutes of the hour\n"
    "        ${s} is hour of 2-digit seconds of the minute\n    ",
    m_params.outputPattern);
  this->_registerArgument("-d=", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parseDuration),
    "data time to be stored per miniSEED file (in hours)", std::to_string(m_params.nHoursPerFile));
  this->_registerArgument("-standalone", CLCOMMAND_PARSE_HANDLER(CLCommand_Telemetry::_parseStandalone),
    "run in standalone mode (if flag specified)", "false");
}

bool CLCommand_Telemetry::_parsePortPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_portPath = std::string(arg);
  return true;
}
bool CLCommand_Telemetry::_parseBaudRate(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_baudRate = static_cast<uint32_t>(::atoi(arg));
  return true;
}
bool CLCommand_Telemetry::_parseOutput(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.outputDir = PlatformUtils::getInstance()->normalize(std::string(arg));
  return true;
}
bool CLCommand_Telemetry::_parsePattern(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.outputPattern = PlatformUtils::getInstance()->normalize(std::string(arg));
  return true;
}
bool CLCommand_Telemetry::_parseDuration(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_params.nHoursPerFile = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_Telemetry::_parseStandalone(const char* /*arg*/)
{
  __DEV_CALLSTACK_FUNC__;
  m_bStandalone = true;
  return true;
}

int CLCommand_Telemetry::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  // check parsed arguments
  if (m_portPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT,
      "Port path is not specified ('-i=<port path. e.i: /dev/ttyUSB0>')");
    return -1;
  }

#if defined(DEV_PLATFORM_LINUX)
  m_factory = std::make_shared<TelemetryPacketsFactory>(m_logger);
  m_processor = std::make_shared<TelemetryPacketsProcessor>(
    std::make_shared<SerialPort_POSIX>(m_portPath, m_baudRate, m_logger),
    std::make_shared<ResponseBufferProvider_Preallocated>(),
    m_logger);
  m_eventsQueue = std::make_shared<EventsQueue>();
  // register services
  m_services = std::vector<std::shared_ptr<ITelemetryService>> {
    std::make_shared<TelemetryService_TimeSeries>(m_factory, m_processor, m_eventsQueue, m_params, m_logger),
    std::make_shared<TelemetryService_SOH>(m_factory, m_processor, m_eventsQueue, m_logger),
    std::make_shared<TelemetryService_Info>(m_factory, m_processor, m_eventsQueue, m_logger)
  };

  // register SIGINT handler
  static CLCommand_Telemetry* THIS = this;
  signal(SIGINT, [](int /*s*/) { THIS->_quit(); });

  // start receiver thread
  std::thread receiverThread(&CLCommand_Telemetry::_receiverFunc, this);
  receiverThread.detach();
  if (m_bStandalone)
  {
    while (!m_bQuitRequested)
    {
      this->_standaloneLoop();
    }
  }
  else
  {
    this->_help();
    this->_printPrompt();
    while (!m_bQuitRequested)
    {
      std::string command;
      std::getline(std::cin, command);
      if (!command.empty())
      {
        this->_processCommand(command);
        this->_printPrompt();
      }
    }
  }
  // wait for receiver thread to finish
  std::unique_lock<std::mutex> lock(m_mutex);
  while (!m_bReceiverStopped)
  {
    m_receiverStoppedEvent.wait(lock);
  }
  // stop services
  for (auto& service : m_services)
  {
    service->stop();
  }
#else
  m_logger->warning(m_name.c_str(), "The command is not supported for the current platform yet");
#endif
  return 0;
}

void CLCommand_Telemetry::_processCommand(const std::string& command)
{
  __DEV_CALLSTACK_FUNC__;
  bool bProcessed = false;
  // pass command to each service
  for (auto& service : m_services)
  {
    if (service->processCommand(command))
    {
      bProcessed = true;
    }
  }
  // process command itself
  const auto& foundIt = m_commands.find(command);
  if (foundIt != m_commands.end())
  {
    m_logger->info(m_name.c_str(), "Running '%s' command (%s)", foundIt->first.c_str(), foundIt->second.description.c_str());
    foundIt->second.functor();
  }
  if (!bProcessed) // nobody processed the command -> report warning
  {
    m_logger->warning(m_name.c_str(), "Command '%s' is not registered", command.c_str());
  }
}

void CLCommand_Telemetry::_standaloneLoop()
{
  __DEV_CALLSTACK_FUNC__;
  // process all events
  std::queue<Event> events;
  m_eventsQueue->fetchEvents(events);
  while (!events.empty())
  {
    const Event& event = events.front();
    bool bProcessed = false;
    for (const auto& service : m_services)
    {
      if (service->processEvent(event))
      {
        bProcessed = true;
      }
    }
    if (!bProcessed)
    {
      m_logger->warning(THIS_CLASS_NAME, "Event (id=%" PRIu32 ", userData=%p) hasn't been processed",
        event.id, event.userData);
    }
    events.pop();
  }
  // tick each service
  const timestamp_t now = m_timer->now();
  for (const auto& service : m_services)
  {
    service->tick(now);
  }
  std::this_thread::sleep_for(std::chrono::microseconds(100u));
}

void CLCommand_Telemetry::_receiverFunc()
{
  __DEV_CALLSTACK_FUNC__;
  m_bReceiverStopped = false;
  TelemetryAPI::Packet packet = {};
  TelemetryAPI::Error errorCode = TelemetryAPI::Error::ERROR_NONE;
  while (!m_bQuitRequested)
  {
    // receive and log packet
    if (m_processor->receive(packet, errorCode) > 0)
    {
      if (errorCode == TelemetryAPI::Error::ERROR_NONE)
      {
        bool bProcessed = false;
        for (auto& service : m_services)
        {
          // delegate packet processing to each service. Single packet can be required by multiple services
          if (service->processPacket(packet))
          {
            bProcessed = true;
          }
        }
        if (!bProcessed)
        {
          m_logger->warning(m_name.c_str(), "Packet (type=0x%04x, size=%" PRIu32 ") hasn't been processed",
            packet.header.type, static_cast<uint32_t>(packet.header.payloadSize));
        }
      }
      else
      {
        m_logger->warning(m_name.c_str(), "Failed to receive packet (error=0x%08x)", errorCode);
      }
      if (!m_bStandalone)
      {
        this->_printPrompt();
      }
    }
  }
  m_bReceiverStopped = true;
  m_logger->info(m_name.c_str(), "Receiver thread stopped");
  m_receiverStoppedEvent.notify_one();
}

void CLCommand_Telemetry::_printPrompt()
{
  __DEV_CALLSTACK_FUNC__;
  printf("%s>: ", m_name.c_str());
  fflush(stdout);
}

void CLCommand_Telemetry::_quit()
{
  __DEV_CALLSTACK_FUNC__;
  signal(SIGINT, SIG_DFL);
  std::lock_guard<std::mutex> lock(m_mutex);
  m_bQuitRequested = true;
}
void CLCommand_Telemetry::_help()
{
  __DEV_CALLSTACK_FUNC__;
  for (auto& command : m_commands)
  {
    m_logger->info(m_name.c_str(), "'%s' - %s", command.first.c_str(), command.second.description.c_str());
  }
  for (auto& service : m_services)
  {
    const auto& commands = service->getCommands();
    for (auto& command : commands)
    {
      m_logger->info(m_name.c_str(), "'%s' - %s", command.first.c_str(), command.second.description.c_str());
    }
  }
}

std::string CLCommand_Telemetry::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Connects to the telemetry serial port to receive/send messages");
}
