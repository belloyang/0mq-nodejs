#include "CLCommand_GenerateLogs.h"

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>

#include <DataFilters/GraphBuilder.h>

#include <Utils/psf_utils.h>

CLCommand_GenerateLogs::CLCommand_GenerateLogs(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("generate-logs", logger)
,  m_libPath("")
,  m_nLogs(0)
,  m_startTimestamp(psf_utils::get_timestamp())
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateLogs::_parseLibPath),
      "PSF library path");
  this->_registerArgument("-n=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateLogs::_parseLogsCount),
      "logs count. -1 - auto-calculated to fill up the volume entirely");
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateLogs::_parseStartTimestamp),
    "lower timestamp for the logs generation (in nanoseconds)", "current POSIX timestamp");
}

bool CLCommand_GenerateLogs::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_GenerateLogs::_parseLogsCount(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_nLogs = ::atoi(arg);
  return true; 
}
bool CLCommand_GenerateLogs::_parseStartTimestamp(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_startTimestamp = ::atoll(arg);
  return true;
}

int CLCommand_GenerateLogs::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_nLogs == 0)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "No logs count set ('-n=<count>)");
    return -1;
  }

  //tss_harv::prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harv::create PSF library
  std::shared_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  //tss_harv::restoring library
  if (pLibrary && pLibrary->restore())
  {
    GraphBuilder graphBuilder(m_logger);
    //tss_harv::build logs generation chain
    const auto chain = graphBuilder.buildLogsGenerationChain(pLibrary, m_startTimestamp, m_nLogs);
    if (chain != nullptr)
      chain->run(nullptr);
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
      "Failed to restore PSF library at '%s'", m_libPath.c_str());
  }

  return 1;
}

std::string CLCommand_GenerateLogs::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Generates and dumps data to PSF lib");  
}
