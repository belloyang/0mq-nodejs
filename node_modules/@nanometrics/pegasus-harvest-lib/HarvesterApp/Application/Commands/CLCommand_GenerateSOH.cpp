#include "CLCommand_GenerateSOH.h"

#include <DataFilters/Generators/gap_generators/GapGenerator_Random.h>

#include <PlatformUtils/PlatformUtils.h>

#include <Library/PSFLibrary.h>
#include <Library/PSFVolume.h>

#include <DataFilters/GraphBuilder.h>

#include <Utils/psf_utils.h>

CLCommand_GenerateSOH::CLCommand_GenerateSOH(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("generate-soh", logger)
,  m_libPath("")
,  m_nPackets(0)
,  m_startTimestamp(psf_utils::get_timestamp())
,  m_minGapSecs(0)
,  m_maxGapSecs(0)
,  m_gapProbability(0.f)
,  m_signalLevel((double)((1ul << 15) - 1)) // SOH samples are 16 bits long. Full-scale counts is +/- (2^15 - 1).
,  m_noiseLevel(0.0)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseLibPath),
    "PSF library path");
  this->_registerArgument("-n=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parsePacketsCount),
    "packets count. -1 - auto-calculated to fill up the volume entirely");
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseStartTimestamp),
    "lower timestamp for the SOH packets generation (in nanoseconds)", "current POSIX timestamp");
  
  this->_registerArgument("-min_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseMinGapSecs),
    "minimum gap to be generated (in seconds)", "0");
  this->_registerArgument("-max_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseMaxGapSecs),
    "maximum gap to be generated (in seconds)", "0");
  this->_registerArgument("-prob_gap=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseGapProbability),
    "gap probability (in [0.0, 1.0] range)", "0.0");
  
  this->_registerArgument("-signal=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseSignalLevel),
    "signal peak level (counts, >= 0.0)", "2^15 - 1");
  this->_registerArgument("-noise=", CLCOMMAND_PARSE_HANDLER(CLCommand_GenerateSOH::_parseNoiseLevel),
    "noise RMS level (counts, >= 0.0)", "0.0");
}

bool CLCommand_GenerateSOH::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_GenerateSOH::_parsePacketsCount(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_nPackets = ::atoi(arg);
  return true; 
}
bool CLCommand_GenerateSOH::_parseStartTimestamp(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_startTimestamp = ::atoll(arg);
  return true;
}

bool CLCommand_GenerateSOH::_parseMinGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_minGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateSOH::_parseMaxGapSecs(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_maxGapSecs = (uint32_t)::atoi(arg);
  return true;
}
bool CLCommand_GenerateSOH::_parseGapProbability(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_gapProbability = (float)::atof(arg);
  return true;
}
bool CLCommand_GenerateSOH::_parseSignalLevel(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_signalLevel = ::atof(arg);
  return true;
}
bool CLCommand_GenerateSOH::_parseNoiseLevel(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_noiseLevel = ::atof(arg);
  return true;
}

int CLCommand_GenerateSOH::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_nPackets == 0)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "No SOH packets count set ('-n=<count>)");
    return -1;
  }
  if (m_signalLevel < 0.0) {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Signal peak level must be >= 0.0 counts");
    return -1;
  }
  if (m_noiseLevel < 0.0) {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Noise RMS level must be >= 0.0 counts");
    return -1;
  }

  //tss_harv::prepare physical disk/block device for harvesting
  std::string libPath = PlatformUtils::getInstance()->fixDevicePath(m_libPath);
  libPath = PlatformUtils::getInstance()->mapLogicalPathToPhysical(libPath);
  PlatformUtils::getInstance()->unmountAll(libPath);

  //tss_harv::create PSF library
  std::shared_ptr<PSFLibrary> const pLibrary(PSFLibrary::create(libPath, m_hasher, m_logger, false));
  //tss_harv::restoring library
  if (pLibrary && pLibrary->restore())
  {
    GraphBuilder graphBuilder(m_logger);
    //tss_harv::build SOH data generation chain
    const auto chain = graphBuilder.buildHealthInputGenerationChain(pLibrary, m_startTimestamp, m_nPackets,
      std::make_shared<GapGenerator_Random>(m_minGapSecs, m_maxGapSecs, m_gapProbability),
      m_signalLevel, m_noiseLevel);
    if (chain != nullptr)
      chain->run(nullptr);
  }
  else
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
      "Failed to restore PSF library at '%s'", m_libPath.c_str());
  }

  return 1;
}

std::string CLCommand_GenerateSOH::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Generates and dumps SOH data (packets) to PSF lib");  
}
