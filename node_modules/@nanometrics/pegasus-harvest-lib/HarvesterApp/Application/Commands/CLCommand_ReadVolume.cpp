#include "CLCommand_ReadVolume.h"

#include <Operations/Operation_ReadVolume.h>

#include <Utils/psf_utils.h>
#include <Utils/JSONSerializer.h>
#include <Utils/JSONTransformer_None.h>

#include <cstring> // strncmp
#include <cinttypes>
#include <ctime>
#include <memory>

class ReadVolume_Delegate : public IProcessorDelegate
{
public:
  ReadVolume_Delegate(const std::shared_ptr<ILogger>& logger)
  : m_serializer(std::make_shared<JSONTransformer_None>())
  , m_logger(logger)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~ReadVolume_Delegate() = default;

  virtual void onPSFRead(const PSFDataElement* dataElement) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    // serialize data element into JSON-string
    const rapidjson::Value& json = m_serializer.serialize(dataElement);
    const std::string& jsonString = json_utils::to_string(json, true);
    m_logger->info(__THIS_FUNC__, "Message: '%s'", jsonString.c_str());
  }

  virtual void onCompleted(const eOperationStatus status) __OVERRIDES__(IProcessorDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_logger->info(__THIS_FUNC__, "Volume reading completed (status=%" PRIu32 ")", static_cast<uint32_t>(status));
  }

private:
  JSONSerializer m_serializer;
  const std::shared_ptr<ILogger> m_logger;
};


CLCommand_ReadVolume::CLCommand_ReadVolume(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("read-volume", logger)
,  m_libPath("")
,  m_volumeId((uint32_t)-1)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_ReadVolume::_parseLibPath), "PSF library path");
  //tss_harvcl::register "-id" argument with some common volume IDs information
  {
    char* volumeIDSStr = (char*)::malloc(512);
    ::snprintf(volumeIDSStr, 512,
      "        %" PRIu32 " = VOLUME_SENSOR_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_HEALTH_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_CLOCK_STATUS\n"
      "        %" PRIu32 " = VOLUME_HEALTH_DIGEST\n"
      "        %" PRIu32 " = VOLUME_OPERATION_LOG\n"
      "        %" PRIu32 " = VOLUME_HARVEST_LOG\n"
      "        %" PRIu32 " = VOLUME_FORENSIC_LOG\n"
      "        %" PRIu32 " = VOLUME_HEALTH_STATE\n"
      "        %" PRIu32 " = VOLUME_HEALTH_PDF\n"
      "        %" PRIu32 " = VOLUME_SEISMIC_PDF",
      PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES,
      PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES,
      PDB_eVolumeID::VOLUME_CLOCK_STATUS,
      PDB_eVolumeID::VOLUME_HEALTH_DIGEST,
      PDB_eVolumeID::VOLUME_OPERATION_LOG,
      PDB_eVolumeID::VOLUME_HARVEST_LOG,
      PDB_eVolumeID::VOLUME_FORENSIC_LOG,
      PDB_eVolumeID::VOLUME_HEALTH_STATE,
      PDB_eVolumeID::VOLUME_HEALTH_PDF,
      PDB_eVolumeID::VOLUME_SEISMIC_PDF);
    this->_registerArgument("-id=", CLCOMMAND_PARSE_HANDLER(CLCommand_ReadVolume::_parseVolumeId), "volume integer ID. e.i:\n" + std::string(volumeIDSStr));
    ::free(volumeIDSStr);
  }
}

bool CLCommand_ReadVolume::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_ReadVolume::_parseVolumeId(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_volumeId = ::atoi(arg);
  return true;
}

int CLCommand_ReadVolume::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_volumeId == (uint32_t)-1)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Volume ID (integer) not specified ('-id=<volume ID>')");
    return -1;
  }

  const std::shared_ptr<IOperation> op = std::make_shared<Operation_ReadVolume>(m_libPath, m_volumeId, std::make_shared<ReadVolume_Delegate>(m_logger));
  if (op->execute(m_hasher, m_logger))
  {
    return 1;
  }

  return -1;
}

std::string CLCommand_ReadVolume::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Reads volume's content");
}
