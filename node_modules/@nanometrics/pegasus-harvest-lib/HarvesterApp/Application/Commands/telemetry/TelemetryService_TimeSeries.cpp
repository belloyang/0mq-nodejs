#include "TelemetryService_TimeSeries.h"

#include <DataFilters/Writers/MiniSEEDWriterFilter_SensorInput.h>
#include <DataFilters/IPacketInfoProvider.h>

#include <DigitizerInfo.h>
#include <Utils/pdb_utils.h>
#include <Utils/psf_utils.h>
#include <Utils/endianness_utils.h>
#include <PlatformUtils/PlatformUtils.h>
#include <steim/steim1.h>
#include <steim/steim2.h>

#include <thread>
#include <cinttypes>
#include <cstring>
#include <chrono>

namespace
{
  const char THIS_CLASS_NAME[] = "TelemetryService_TimeSeries";
  const uint32_t POOL_SIZE = 12u; // triple buffer for sensor input packets (3 x 4 channels)

  enum SteimCompressions : uint32_t
  {
    NONE = 0,

    STEIM1_1x32 = BIT(0),
    STEIM1_2x16 = BIT(1),
    STEIM1_4x8  = BIT(2),

    STEIM2_1x30 = BIT(3),
    STEIM2_2x15 = BIT(4),
    STEIM2_3x10 = BIT(5),
    STEIM2_4x8  = BIT(6),
    STEIM2_5x6  = BIT(7),
    STEIM2_6x5  = BIT(8),
    STEIM2_7x4  = BIT(9),

    COUNT = 10
  };

  SteimCompressions getCompressionUncompressed(const uint32_t /*compression*/, const uint32_t /*dataset*/)
  {
    __DEV_CALLSTACK_FUNC__;
    return SteimCompressions::NONE;
  }

  SteimCompressions getCompressionSteim1(const uint32_t compression, const uint32_t /*dataset*/)
  {
    __DEV_CALLSTACK_FUNC__;
    __ASSERT__(compression != 0 && "compression shouldn't be 0 here");
    if (compression == steim1::_4x8_BITS) return SteimCompressions::STEIM1_4x8;
    if (compression == steim1::_2x16_BITS) return SteimCompressions::STEIM1_2x16;
    if (compression == steim1::_1x32_BITS) return SteimCompressions::STEIM1_1x32;
    __ASSERT__(false && "Invalid compression");
    return SteimCompressions::NONE;
  }

  SteimCompressions getCompressionSteim2(const uint32_t compression, const uint32_t dataset)
  {
    __DEV_CALLSTACK_FUNC__;
    if (compression == steim2::_4x8_BITS/*0b01*/) return SteimCompressions::STEIM2_4x8;
    const uint32_t nibble = dataset >> 30;
    if (compression == /*0b10*/0x2u)
    {
      switch (nibble)
      {
        case /*0b01*/0x1u: return SteimCompressions::STEIM2_1x30;
        case /*0b10*/0x2u: return SteimCompressions::STEIM2_2x15;
        case /*0b11*/0x3u: return SteimCompressions::STEIM2_3x10;
        default: __ASSERT__(false && "Invalid nibble");
      }
    }
    else if (compression == /*0b11*/0x3u)
    {
      switch (nibble)
      {
        case /*0b00*/0x0u: return SteimCompressions::STEIM2_5x6;
        case /*0b01*/0x1u: return SteimCompressions::STEIM2_6x5;
        case /*0b10*/0x2u: return SteimCompressions::STEIM2_7x4;
        default: __ASSERT__(false && "Invalid nibble");
      }
    }
    __ASSERT__(false && "invalid compression");
    return SteimCompressions::NONE;
  }

  struct MediaTypeInfo
  {
    std::string name;
    SteimCompressions(*compressionGetter)(const uint32_t compression, const uint32_t dataset);
  };
  const std::map<PDB_eMediaType_t, MediaTypeInfo> MEDIA_TYPES_INFO_MAP = {
    { PDB_eMediaType_t::MEDIA_UNCOMPRESSED, { "uncompressed/raw", &getCompressionUncompressed } },
    { PDB_eMediaType_t::MEDIA_STEIM1, { "Steim-1", &getCompressionSteim1 } },
    { PDB_eMediaType_t::MEDIA_STEIM2, { "Steim-2", &getCompressionSteim2 } }
  };

  std::string makeString(const char* input, uint32_t maxLen)
  {
    __DEV_CALLSTACK_FUNC__;
    if (input == nullptr || ::strnlen(input, maxLen) == 0)
    {
      return std::string("");
    }
    const size_t actualLen = ::strnlen(input, maxLen);
    return std::string(input, actualLen);
  }

  std::string compressionsMaskToString(const uint32_t mask)
  {
    __DEV_CALLSTACK_FUNC__;
    static char buffer[SteimCompressions::COUNT];
    for (uint32_t bit = 0; bit < SteimCompressions::COUNT; ++bit)
    {
      buffer[SteimCompressions::COUNT - 1 - bit] = (mask & (1u << bit)) ? '1' : '0';
    }
    return std::string(buffer, NUM_ELEMENTS(buffer));
  }

  class PacketInfoProvider_DigitizerInfo : public IPacketInfoProvider
  {
  public:
    PacketInfoProvider_DigitizerInfo(const DigitizerInfo& info)
    : IPacketInfoProvider()
    {
      __DEV_CALLSTACK_FUNC__;
      m_network = makeString(info.network, NUM_ELEMENTS(info.network));
      m_station = makeString(info.station, NUM_ELEMENTS(info.station));
      for (uint32_t i = 0; i < info.n_channels; ++i)
      {
        const auto& channelInfo = info.channels[i];
        m_channels[i] = {
            makeString(channelInfo.name, NUM_ELEMENTS(channelInfo.name)),
            makeString(channelInfo.location, NUM_ELEMENTS(channelInfo.location)),
        };
      }
    }
    virtual ~PacketInfoProvider_DigitizerInfo() = default;

    virtual void initialize(const sSequenceRange& /*range*/) { /*do nothing. Just reuse current DigitizerInfo set*/};

    virtual timestamp_t getTimestamp(const sPacketSlice& packetSlice) const __OVERRIDES__(IPacketInfoProvider)
    {
      __DEV_CALLSTACK_FUNC__;
      return packetSlice.timestamp;
    }
    virtual const std::string& getNetwork(const sPacketSlice& /*packetSlice*/) const __OVERRIDES__(IPacketInfoProvider)
    {
      __DEV_CALLSTACK_FUNC__;
      return m_network;
    }
    virtual const std::string& getStation(const sPacketSlice& /*packetSlice*/) const __OVERRIDES__(IPacketInfoProvider)
    {
      __DEV_CALLSTACK_FUNC__;
      return m_station;
    }
    virtual const std::string& getChannelName(const sPacketSlice& packetSlice) const __OVERRIDES__(IPacketInfoProvider)
    {
      __DEV_CALLSTACK_FUNC__;
      return m_channels[packetSlice.channelIndex].name;
    }
    virtual const std::string& getChannelLocation(const sPacketSlice& packetSlice) const __OVERRIDES__(IPacketInfoProvider)
    {
      __DEV_CALLSTACK_FUNC__;
      return m_channels[packetSlice.channelIndex].location;
    }

  private:
    std::string m_network;
    std::string m_station;
    struct {
      std::string name;
      std::string location;
    } m_channels[NUM_ELEMENTS(DigitizerInfo::channels)];
  };
}

TelemetryService_TimeSeries::TelemetryService_TimeSeries(const std::shared_ptr<TelemetryPacketsFactory>& factory,
  const std::shared_ptr<TelemetryPacketsProcessor>& processor,
  const std::shared_ptr<EventsQueue>& eventsQueue,
  const sHarvestParams& harvestParams,
  const std::shared_ptr<ILogger>& logger)
: ITelemetryService(THIS_CLASS_NAME, factory, processor, eventsQueue, logger)
, m_harvestParams(harvestParams)
, m_msgSensorInputsPool(new mem_pool_allocator_new<MsgSensorInput()>(), logger)
, m_pdbDescsPool(new mem_pool_allocator_new_init<PDBDataDesc(IPDBMsgObject*, sequence_number_t)>(), logger)
, m_bStopRequested(false)
, m_miniSEEDThreadRunning(false)
, m_sequenceNumber(0u)
{
  __DEV_CALLSTACK_FUNC__;
  m_requestsMap = {
    { TelemetryAPI::TimeSeries::START_STREAMING_REQUEST, "start streaming" },
    { TelemetryAPI::TimeSeries::STOP_STREAMING_REQUEST, "stop streaming" }
  };
  // register commands
  this->_registerCommand("start",
    Command {
      "start sensor time series streaming",
      Command::Functor(&TelemetryService_TimeSeries::_startStreaming, this)
    });
  this->_registerCommand("stop",
    Command {
      "stop sensor time series streaming",
      Command::Functor(&TelemetryService_TimeSeries::_stopStreaming, this)
  });
  // allocate buffer
  m_msgSensorInputsPool.allocate(POOL_SIZE);
  m_pdbDescsPool.allocate(POOL_SIZE, nullptr, 0);
}

bool TelemetryService_TimeSeries::processPacket(const TelemetryAPI::Packet& packet)
{
  __DEV_CALLSTACK_FUNC__;
  switch (packet.header.type)
  {
    case TelemetryAPI::TimeSeries::STREAMING_RESPONSE:
    {
      // log packet information
      this->_logPacket(packet);
      // queue PDB data for processing
      if (m_miniSEEDThreadRunning)
      {
        const auto& response = packet.timeSeries.streamingResponse;
        const MsgSensorInput::Header* const data = response.buffer;
        MsgSensorInput* const pInput = m_msgSensorInputsPool.new_object();
        if (pInput && pInput->init(*data))
        {
          PDBDataDesc* const pDataDesc = m_pdbDescsPool.new_object(pInput, m_sequenceNumber++);
          std::lock_guard<std::mutex> lock(m_mutex);
          m_dataDescs.push_back(pDataDesc);
          m_dataPushedEvent.notify_one();
        }
      }
    }
    return true;

    case TelemetryAPI::Info::RESPONSE:
    {
      // create packet info provider
      const DigitizerInfo info = *(packet.info.response.buffer);
      m_packetInfoProvider = std::make_shared<PacketInfoProvider_DigitizerInfo>(info);
    }
    return true;

    case TelemetryAPI::Acknowledgment::RESPONSE:
    {
      const auto& response = packet.acknowledgment.response;
      if ((response.request == TelemetryAPI::TimeSeries::START_STREAMING_REQUEST) &&
          (response.errorCode == TelemetryAPI::Error::ERROR_NONE))
      {
        // discard expected sequence numbers
        for (uint32_t i = 0; i < NUM_ELEMENTS(m_state.channels); ++i)
        {
          m_state.channels[i].expectedSequenceNumber = 0u;
        }
        // start miniSEED writer thread
        const std::shared_ptr<IBaseFilter> filter = std::make_shared<MiniSEEDWriterFilter_SensorInput>(
          m_packetInfoProvider,
          m_harvestParams, POOL_SIZE, m_logger);
        std::thread th(&TelemetryService_TimeSeries::_miniSEEDThread, this, filter);
        th.detach();
      }
    }
    return ITelemetryService::processPacket(packet);

    default:
      return ITelemetryService::processPacket(packet);
  }
  return false;
}

bool TelemetryService_TimeSeries::processEvent(const Event& event)
{
  __DEV_CALLSTACK_FUNC__;
  switch (event.id)
  {
    case EventID::REBOOT_DETECTED:
      m_logger->info(THIS_CLASS_NAME, "Re-requesting streaming due to possible reboot");
      m_state.isStreaming = false;
      return true;

    default:
      return ITelemetryService::processEvent(event);
  }
  return false;
}

void TelemetryService_TimeSeries::tick(const timestamp_t /*now*/)
{
  __DEV_CALLSTACK_FUNC__;
  if (!m_state.isStreaming)
  {
    this->_startStreaming();
    m_state.isStreaming = true;
  }
}

void TelemetryService_TimeSeries::stop()
{
  __DEV_CALLSTACK_FUNC__;
  m_bStopRequested = true;
  this->_stopStreaming();
  m_logger->info(THIS_CLASS_NAME, "service stopped");
  this->_printSummary();
}

void TelemetryService_TimeSeries::_miniSEEDThread(std::shared_ptr<IBaseFilter> filter)
{
  __DEV_CALLSTACK_FUNC__;
  m_miniSEEDThreadRunning = true;
  m_logger->info(m_name.c_str(), "miniSEED thread started");
  // create output path
  const std::string resolvedPath = PlatformUtils::getInstance()->resolvePath(m_harvestParams.outputDir);
  if (PlatformUtils::getInstance()->makePath(resolvedPath))
  {
    // run (start) filter
    IBaseFilter::Config config;
    {
      config.startTime = psf_utils::get_timestamp();
      config.volumeID = PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES;
      config.timeRange.lower = m_harvestParams.lower.time;
      config.timeRange.upper = m_harvestParams.upper.time;
      config.timeRange.valid = true;
      config.sequenceRange.lower = m_harvestParams.lower.sequence_number;
      config.sequenceRange.upper = m_harvestParams.upper.sequence_number;
    }
    filter->run(&config);
    // process data
    while (!m_bStopRequested)
    {
      std::unique_lock<std::mutex> lock(m_mutex);
      m_dataPushedEvent.wait(lock);
      std::vector<PDBDataDesc*> copy; copy.swap(m_dataDescs);
      lock.unlock();
      // process messages
      for (PDBDataDesc* desc : copy)
      {
        filter->processData(desc, nullptr);
      }
      filter->update();
    }
    m_logger->info(m_name.c_str(), "Finalizing harvesting...");
    // finalize data processing
    sHarvestOpReport report;
    {
      report.finishTime = psf_utils::get_timestamp();
      report.status = eOperationStatus::OP_STATUS_COMPLETED;
    }
    filter->finalize(&report);
  }
  else
  {
    const uint32_t errorCode = PlatformUtils::getInstance()->getLastErrorCode();
    m_logger->warning(m_name.c_str(),  "Failed to create output path '%s' (%" PRIu32 ": %s)", resolvedPath.c_str(),
      errorCode, PlatformUtils::getInstance()->getErrorString(errorCode).c_str());
  }
  // notify thread stopped
  m_logger->info(m_name.c_str(), "miniSEED thread stopped");
  m_miniSEEDThreadRunning = false;
  m_stoppedEvent.notify_one();
}

void TelemetryService_TimeSeries::_stopMiniSEEDThread()
{
  __DEV_CALLSTACK_FUNC__;
  m_bStopRequested = true;
  // wake-up miniSEED thread
  m_dataPushedEvent.notify_one();
  // wait for miniSEED thread
  std::unique_lock<std::mutex> lock(m_mutex);
  while (m_miniSEEDThreadRunning)
  {
    m_stoppedEvent.wait(lock);
  }
  m_bStopRequested = false;
}

void TelemetryService_TimeSeries::_startStreaming()
{
  __DEV_CALLSTACK_FUNC__;
  this->_stopMiniSEEDThread();
  TelemetryAPI::Packet packet = {};
  // request info
  m_packetsFactory->createDigitizerInfoRequest(packet);
  m_packetsProcessor->send(packet);
  // this server running on Pegasus needs small delay to process ifno requests and avoid buffer overrun
  std::this_thread::sleep_for(std::chrono::milliseconds(10u));
  // request start streaming
  m_packetsFactory->createTimeSeriesStartStreamingRequest(packet, TelemetryAPI::TimeSeries::ALL_SENSOR_INPUTS);
  m_packetsProcessor->send(packet);
}
void TelemetryService_TimeSeries::_stopStreaming()
{
  __DEV_CALLSTACK_FUNC__;
  TelemetryAPI::Packet packet = {};
  m_packetsFactory->createTimeSeriesStopStreamingRequest(packet);
  m_packetsProcessor->send(packet);
  this->_stopMiniSEEDThread();
}

void TelemetryService_TimeSeries::_logPacket(const TelemetryAPI::Packet& packet)
{
  __DEV_CALLSTACK_FUNC__;
  const auto& response = packet.timeSeries.streamingResponse;
  const MsgSensorInput::Header* const data = response.buffer;
  const uint32_t channel = static_cast<uint32_t>(data->input);
  auto& channelState = m_state.channels[channel];
  channelState.nPacketsReceived++;
  m_logger->info(THIS_CLASS_NAME, "Time series received (input = %" PRIu32 ", sequence = %" PRIu32 ", missed = %" PRIu32 ", received = %" PRIu32 ")",
    channel, response.header.sequenceNumber,
    channelState.nPacketsMissed, channelState.nPacketsReceived);
  // log details at debug level
  const double sampleRate = pdb_utils::decode_sample_rate(data->sample_rate);
  const auto& mediaTypeIt = MEDIA_TYPES_INFO_MAP.find(data->media_type);
  const uint32_t compressionsMask = this->_getCompressionsMask(data);
  m_logger->debug(THIS_CLASS_NAME, "Seismic packet details:\n"
    "  media type = %" PRIu32 " (%s)\n"
    "  compressions = 0b%s\n"
    "  flags = 0x%02x\n"
    "  sample rate = %" PRIu32 "Hz\n"
    "  n_samples = %" PRIu32 "\n",
    static_cast<uint32_t>(data->media_type), (mediaTypeIt != MEDIA_TYPES_INFO_MAP.end()) ? mediaTypeIt->second.name.c_str() : "UNKNOWN",
    compressionsMaskToString(compressionsMask).c_str(),
    data->flags,
    static_cast<uint32_t>(sampleRate),
    static_cast<uint32_t>(data->n_samples));
  // check if expected sequence number == actual
  const uint32_t expectedSequenceNumber = channelState.expectedSequenceNumber;
  if (expectedSequenceNumber != response.header.sequenceNumber)
  {
    const uint32_t nPacketsMissed = response.header.sequenceNumber - expectedSequenceNumber;
    channelState.nPacketsMissed += nPacketsMissed;
    m_logger->warning(THIS_CLASS_NAME, "Missing %" PRIu32 " packet(s) (%" PRIu32 " in total) on channel #%" PRIu32 ": expected=%" PRIu32 ", received=%" PRIu32,
      nPacketsMissed, channelState.nPacketsMissed, channel,
      expectedSequenceNumber, response.header.sequenceNumber);
  }
  channelState.expectedSequenceNumber = response.header.sequenceNumber + 1u;
}

uint32_t TelemetryService_TimeSeries::_getCompressionsMask(const MsgSensorInput::Header* packet) const
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(packet != nullptr && "packet cannot be nullptr here");
  uint32_t result = 0u;
  const auto& mediaTypeInfoIt = MEDIA_TYPES_INFO_MAP.find(packet->media_type);
  __ASSERT__(mediaTypeInfoIt != MEDIA_TYPES_INFO_MAP.end() && "invalid media type");
  const bool isBigEndian = (packet->flags & MsgSensorInput::Header::eFlags::FLAG_BIG_ENDIAN) != 0;
  for (uint32_t frameIdx = 0; frameIdx < NUM_ELEMENTS(packet->frames); ++frameIdx)
  {
    const SteimFrame_t& frame = packet->frames[frameIdx];
    // extract compression dataset
    const uint32_t compressionDataset = isBigEndian ? endianness_utils::swap<uint32_t>(frame[0]) : frame[0];
    // go over datasets
    for (uint32_t datasetIdx = 1; datasetIdx < steim::DATASETS_PER_FRAME; datasetIdx++)
    {
      const uint32_t dataset = (isBigEndian) ? endianness_utils::swap(frame[datasetIdx]) : frame[datasetIdx];
      const uint32_t nibbleOffset = (steim::DATASETS_PER_FRAME - 1 - datasetIdx) * 2;
      const uint32_t compression = (compressionDataset >> nibbleOffset) & 0x3u/*0b11*/;
      if (compression == 0) // special dataset (x0, xN)
      {
        continue;
      }
      result |= mediaTypeInfoIt->second.compressionGetter(compression, dataset);
    }
  }
  return result;
}

void TelemetryService_TimeSeries::_printSummary()
{
  __DEV_CALLSTACK_FUNC__;
  const auto& channels = m_state.channels;
  m_logger->info(THIS_CLASS_NAME, "Summary:\n"
    "  missing packets: [%" PRIu32 ", %" PRIu32 ", %" PRIu32 ", %" PRIu32 "]\n"
    "  errors: %" PRIu32,
    channels[0].nPacketsMissed, channels[1].nPacketsMissed, channels[2].nPacketsMissed, channels[3].nPacketsMissed,
    m_nErrorsLogged);
}
