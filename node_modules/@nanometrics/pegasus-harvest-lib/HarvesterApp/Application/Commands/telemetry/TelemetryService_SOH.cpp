#include "TelemetryService_SOH.h"

#include <LiveSohNotificationData.h>
#include <Utils/psf_utils.h>

#include <cinttypes>

namespace
{
  const char THIS_CLASS_NAME[] = "TelemetryService_SOH";
  const std::map<ClockStatusData::AntennaStatus, std::string> ANTENNA_STATUS_MAP = {
    { ClockStatusData::AntennaStatus::ANTENNA_STATUS_OK,    "OK" },
    { ClockStatusData::AntennaStatus::ANTENNA_STATUS_OPEN,  "OPEN" },
    { ClockStatusData::AntennaStatus::ANTENNA_STATUS_SHORT, "SHORT" },
    { ClockStatusData::AntennaStatus::ANTENNA_STATUS_OFF,   "OFF" },
  };
  const uint32_t SOH_REQUEST_INTERVAL_SEC = 10u; // request SOH each 10 second(s)
}

TelemetryService_SOH::TelemetryService_SOH(const std::shared_ptr<TelemetryPacketsFactory>& factory,
  const std::shared_ptr<TelemetryPacketsProcessor>& processor,
  const std::shared_ptr<EventsQueue>& eventsQueue,
  const std::shared_ptr<ILogger>& logger)
: ITelemetryService(THIS_CLASS_NAME, factory, processor, eventsQueue, logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_requestsMap = {
    { TelemetryAPI::SOH::REQUEST, "current SOH" }
  };
  // register commands
  this->_registerCommand("soh",
    Command {
      "request current SOH",
      Command::Functor(&TelemetryService_SOH::_requestSOH, this)
  });
  // set last SOH request time to the current one, to make "tick" loop to skip SOH request at startup
  // The digitizer is busy with other requests at this point, so doing it right away simply overruns digitizer's serial port
  m_state.lastSohRequestTime = psf_utils::get_timestamp();
}

bool TelemetryService_SOH::processPacket(const TelemetryAPI::Packet& packet)
{
  __DEV_CALLSTACK_FUNC__;
  switch (packet.header.type)
  {
    case TelemetryAPI::SOH::RESPONSE:
    {
      const auto& response = packet.soh.response;
      const LiveSohNotificationData* const data = response.buffer;
      m_state.nResponsesReceived++;
      m_state.waitsForResponse = false;
      m_logger->info(THIS_CLASS_NAME, "SOH received (version = %" PRIu32 ", uptime = %" PRIu64 ", lost = %" PRIu32 ", received = %" PRIu32 ")",
        static_cast<uint32_t>(data->version), data->uptime,
        m_state.nResponsesLost, m_state.nResponsesReceived);
      const auto& antennaStatusIt = ANTENNA_STATUS_MAP.find(data->clockStatus.antennaStatus);
      // log details at debug level
      m_logger->debug(THIS_CLASS_NAME, "SOH details:\n"
        "  health inputs:\n"
        "    battery = %.3fV\n"
        "    main current = %.3fA\n"
        "    sensor current = %.3fA\n"
        "    system pressure = %.3fP\n"
        "    temp = %.2fC\n"
        "  soh: [%.3fV, %.3fV, %.3fV, %.3fV]\n"
        "  clock status:\n"
        "    antenna status = 0x%02x (%s)\n"
        "    n_satellites = %" PRIu32 "\n"
        "    uncertainty = %" PRId32 "us\n"
        "    external antenna = %" PRIu32 "\n"
        "    location: [elevation = %+.4f, latitude = %+.4f, longitude = %+.4f]\n"
        "  extended timing:\n"
        "    flags = %" PRIu32 "\n"
        "    Seascan phase: [dt = %" PRIu32 "ns, range = %"  PRIu32 "ns]\n"
        "    GNSS PPS time: [GNSS = %" PRIu32 "s, system = %"  PRIu64 "ns]\n"
        "    last sync time = %" PRIu32 "s\n"
        "    lock duration = %" PRIu32 "s\n",
        data->healthInputs.batteryVolts, data->healthInputs.mainCurrentAmps, data->healthInputs.sensorCurrentAmps,
        data->healthInputs.systemPressurePascals, data->healthInputs.systemTempDegrees,
        data->sohLines.sohLine1Volts, data->sohLines.sohLine2Volts, data->sohLines.sohLine3Volts, data->sohLines.sohLine4Volts,
        data->clockStatus.antennaStatus, (antennaStatusIt != ANTENNA_STATUS_MAP.end()) ? antennaStatusIt->second.c_str() : "UNKNOWN",
        static_cast<uint32_t>(data->clockStatus.nSatellites),
        data->clockStatus.timeUncertaintyMicroSeconds,
        static_cast<uint32_t>(data->clockStatus.gnssExternalAntenna),
        data->clockStatus.location.altitude, data->clockStatus.location.latitude, data->clockStatus.location.longitude,
        static_cast<uint32_t>(data->extendedTiming.flags),
        data->extendedTiming.seascanPhase.dtNs, data->extendedTiming.seascanPhase.rangeNs,
        data->extendedTiming.gnssPpsTime.gnssSecs, data->extendedTiming.gnssPpsTime.systemNs,
        data->extendedTiming.lastSyncTimeSecs,
        data->extendedTiming.gnssLockDurationSeconds);
      // check possible reboot (uptime backward jump)
      if (data->uptime < m_state.lastKnownUptime)
      {
        m_logger->warning(THIS_CLASS_NAME, "Possible reboot detected. Uptime: %" PRIu64"(actual) <= %" PRIu64 "(last known)",
          data->uptime, m_state.lastKnownUptime);
        m_state.nReboots++;
        // send reboot detected event
        static const Event event{ EventID::REBOOT_DETECTED, nullptr };
        this->_pushEvent(event);
      }
      m_state.lastKnownUptime = data->uptime;
    }
    return true;

    default:
      return ITelemetryService::processPacket(packet);
  }
  return false;
}

void TelemetryService_SOH::tick(const timestamp_t now)
{
  __DEV_CALLSTACK_FUNC__;
  constexpr timediff_t sohRequestIntervalNs = static_cast<timediff_t>(1e9f * SOH_REQUEST_INTERVAL_SEC);
  if (now - m_state.lastSohRequestTime >= sohRequestIntervalNs)
  {
    // check if service still waits for SOH response
    if (m_state.waitsForResponse)
    {
      m_state.nResponsesLost++;
      m_logger->warning(THIS_CLASS_NAME, "Previous SOH request considered as timed out (total lost = %" PRIu32 ")",
        m_state.nResponsesLost);
    }
    // request SOH
    m_state.lastSohRequestTime = now;
    this->_requestSOH();
  }
}

void TelemetryService_SOH::stop()
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->info(THIS_CLASS_NAME, "service stopped");
  this->_printSummary();
}

void TelemetryService_SOH::_requestSOH()
{
  __DEV_CALLSTACK_FUNC__;
  TelemetryAPI::Packet packet = {};
  m_packetsFactory->createCurrentSOHRequest(packet);
  m_packetsProcessor->send(packet);
  m_state.nRequestsSent++;
  m_state.waitsForResponse = true;
}

void TelemetryService_SOH::_printSummary()
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->info(THIS_CLASS_NAME, "Summary:\n"
    "  sent = %" PRIu32 "\n"
    "  received = %" PRIu32 "\n"
    "  lost = %" PRIu32 "\n"
    "  reboots = %" PRIu32 "\n"
    "  errors = %" PRIu32,
    m_state.nRequestsSent, m_state.nResponsesReceived, m_state.nResponsesLost,
    m_state.nReboots,
    m_nErrorsLogged);
}
