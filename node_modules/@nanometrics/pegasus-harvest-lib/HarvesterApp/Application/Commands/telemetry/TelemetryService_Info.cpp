#include "TelemetryService_Info.h"

#include <cinttypes>

namespace
{
  const char THIS_CLASS_NAME[] = "TelemetryService_Info";
}

TelemetryService_Info::TelemetryService_Info(const std::shared_ptr<TelemetryPacketsFactory>& factory,
  const std::shared_ptr<TelemetryPacketsProcessor>& processor,
  const std::shared_ptr<EventsQueue>& eventsQueue,
  const std::shared_ptr<ILogger>& logger)
: ITelemetryService(THIS_CLASS_NAME, factory, processor, eventsQueue, logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_requestsMap = {
    { TelemetryAPI::Info::REQUEST, "get digitizer info" }
  };
  // register commands
  this->_registerCommand("info",
    Command {
      "request digitizer info",
      Command::Functor(&TelemetryService_Info::_requestInfo, this)
  });
}

bool TelemetryService_Info::processPacket(const TelemetryAPI::Packet& packet)
{
  __DEV_CALLSTACK_FUNC__;
  switch (packet.header.type)
  {
    case TelemetryAPI::Info::RESPONSE:
    {
      const auto& response = packet.info.response;
      const DigitizerInfo* const data = response.buffer;
      std::string channelsInfo = "";
      char buffer[64] = { 0 };
      for (uint32_t i = 0; i < data->n_channels; ++i)
      {
        const auto& channel = data->channels[i];
        ::snprintf(buffer, NUM_ELEMENTS(buffer), "    channel #%" PRIu32 ": name=%.*s, location=%.*s\n", i,
                   static_cast<int>(NUM_ELEMENTS(channel.name)), channel.name,
                   static_cast<int>(NUM_ELEMENTS(channel.location)), channel.location);
        channelsInfo += std::string(buffer);
      }
      m_logger->info(THIS_CLASS_NAME, "Digitizer info received (version=%" PRIu32 ")",
        static_cast<uint32_t>(data->version));
      // log details at debug level
      m_logger->debug(THIS_CLASS_NAME, "Digitizer info details:\n"
        "  serial = %.*s\n"
        "  bin = %.*s\n"
        "  FW version = %.*s\n"
        "  network = %.*s\n"
        "  station = %.*s\n"
        "  channels:\n%s",
        NUM_ELEMENTS(data->serial), data->serial,
        NUM_ELEMENTS(data->bin), data->bin,
        NUM_ELEMENTS(data->firmware), data->firmware,
        NUM_ELEMENTS(data->network), data->network,
        NUM_ELEMENTS(data->station), data->station,
        channelsInfo.c_str());
    }
    return true;

    default:
      return ITelemetryService::processPacket(packet);
  }
  return false;
}

void TelemetryService_Info::stop()
{
  __DEV_CALLSTACK_FUNC__;
  m_logger->info(THIS_CLASS_NAME, "service stopped");
}

void TelemetryService_Info::_requestInfo()
{
  __DEV_CALLSTACK_FUNC__;
  TelemetryAPI::Packet packet = {};
  m_packetsFactory->createDigitizerInfoRequest(packet);
  m_packetsProcessor->send(packet);
}
