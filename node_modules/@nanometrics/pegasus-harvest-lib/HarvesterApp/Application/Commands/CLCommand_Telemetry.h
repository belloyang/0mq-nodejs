#ifndef CLCommand_Telemetry_h__
#define CLCommand_Telemetry_h__

#include "CLCommandBase.h"

#include <TelemetryPacketsFactory.hpp>
#include <TelemetryPacketsProcessor.hpp>
#include "telemetry/ITelemetryService.h"

#include <mutex>
#include <atomic>
#include <condition_variable>

#include <string>
#include <memory>
#include <map>
#include <vector>

class CLCommand_Telemetry: public CLCommandBase
{
public:
  CLCommand_Telemetry(const std::shared_ptr<ILogger>& logger);
  virtual ~CLCommand_Telemetry() = default;

private:
  virtual int _runImpl() __OVERRIDES__(ICLCommand);
  virtual std::string _getDescriptionImpl() const __OVERRIDES__(ICLCommand);
  
  bool _parseOutput(const char* arg);
  bool _parsePattern(const char* arg);
  bool _parseDuration(const char* arg);
  bool _parsePortPath(const char* arg);
  bool _parseBaudRate(const char* arg);
  bool _parseStandalone(const char* arg);

  void _processCommand(const std::string& command);

  void _quit();
  void _help();

  void _receiverFunc();
  void _standaloneLoop();

  void _printPrompt();

private:
  sHarvestParams m_params;
  std::string m_portPath;
  uint32_t m_baudRate;
  bool m_bStandalone;
  const std::map<std::string, Command> m_commands;
  std::shared_ptr<TelemetryPacketsFactory> m_factory = nullptr;
  std::shared_ptr<TelemetryPacketsProcessor> m_processor = nullptr;
  std::shared_ptr<EventsQueue> m_eventsQueue = nullptr;
  std::mutex m_mutex;
  std::atomic<bool> m_bQuitRequested;
  std::atomic<bool> m_bReceiverStopped;
  std::condition_variable m_receiverStoppedEvent;
  std::vector< std::shared_ptr<ITelemetryService> > m_services;
};

#endif // CLCommand_Telemetry_h__
