#include "CLCommand_VolumeInfo.h"

#include <Operations/Operation_GetVolumeInfo.h>

#include <Utils/psf_utils.h>

#include <cstring> // strncmp
#include <cinttypes>
#include <ctime>

class GetVolumeInfo_Delegate : public Operation_GetVolumeInfo::IDelegate
{
public:
  GetVolumeInfo_Delegate(const std::shared_ptr<ILogger>& logger)
    : m_logger(logger)
    , m_prevSectionSequenceEnd(PSF_SEQUENCE_NUMBER_INVALID)
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~GetVolumeInfo_Delegate() = default;

  virtual void onInfoLoaded(IOperation* pOperation, const sVolumeInfo& info) __OVERRIDES__(GetVolumeInfo_Delegate::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    if (info.bTimeValid)
    {
      char lowerTimeBuff[32] = { 0 };
      {
        tm lowerTime; psf_utils::gmtime_from_timestamp(info.lowerTime, &lowerTime);
        std::strftime(lowerTimeBuff, sizeof(lowerTimeBuff), "%a, %d.%m.%Y %H:%M:%S", &lowerTime);
      }
      char upperTimeBuff[32] = { 0 };
      {
        tm upperTime; psf_utils::gmtime_from_timestamp(info.upperTime, &upperTime);
        std::strftime(upperTimeBuff, sizeof(upperTimeBuff), "%a, %d.%m.%Y %H:%M:%S", &upperTime);
      }
      m_logger->info(pOperation->getName().c_str(), "Volume %" PRIu32 " info:\n"
        "    name = %.*s\n"
        "    size = %" PRIu32 " (chapters)\n"
        "    lower time = %" PRId64 " (%s GMT)\n"
        "    upper time = %" PRId64 " (%s GMT)\n",
        info.uniqueId,
        NUM_ELEMENTS(info.label), info.label,
        info.sizeInChapters,
        info.lowerTime, lowerTimeBuff,
        info.upperTime, upperTimeBuff);
    }
    else
    {
      m_logger->info(pOperation->getName().c_str(), "Volume %" PRIu32 " info:\n"
        "    name = %.*s\n"
        "    size = %" PRIu32 " (chapters)",
        info.uniqueId,
        NUM_ELEMENTS(info.label), info.label,
        info.sizeInChapters);
    }
  }

  virtual void onSectionLoaded(IOperation* pOperation, const uint32_t sectionIndex, const PSFSection* pSection)
  {
    __DEV_CALLSTACK_FUNC__;
    if (pSection != nullptr)
    {
      const sPSFSectionHeader_t* const pHeader = pSection->getHeader();
      //tss_harv::sequence number consistency check (not empty section and sequence index is growing (no wrap around in between sections)
      if (!pSection->isEmpty() && (pHeader->sequenceStart > m_prevSectionSequenceEnd && pHeader->sequenceStart != m_prevSectionSequenceEnd + 1))
      {
        m_logger->error(pOperation->getName().c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED, 
          "Sequence index inconsistency detected!\n"
          "   expected start = %" PRIu32 "\n"
          "   actual start = %" PRIu32,
          m_prevSectionSequenceEnd + 1,
          pHeader->sequenceStart);
      }
      //tss_harv::print section info
      m_logger->info(pOperation->getName().c_str(), "Section %" PRIu32 "\n"
        "    hash = 0x%08x\n"
        "    next_page = %" PRIu32 "\n"
        "    sequences range = [%" PRIu32 ", %" PRIu32 "]",
        sectionIndex,
        pHeader->hash.value,
        pHeader->nextPage,
        pHeader->sequenceStart, pHeader->sequenceEnd);

      //tss_harvl::updated prevSequenceEnd;
      m_prevSectionSequenceEnd = pHeader->sequenceEnd;
    }
    else
    {
      m_logger->error(pOperation->getName().c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_FAILED,
        "Failed to load %" PRIu32 " section", 
        sectionIndex);
    }
  }

  virtual void onCompleted(IOperation* /*pOperation*/, const eOperationStatus /*status*/) __OVERRIDES__(GetVolumeInfo_Delegate::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
  }

private:
  const std::shared_ptr<ILogger> m_logger;
  uint32_t m_prevSectionSequenceEnd;
};


CLCommand_VolumeInfo::CLCommand_VolumeInfo(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("volume-info", logger)
,  m_libPath("")
,  m_volumeId((uint32_t)-1)
,  m_nSectionsToLoad(0)
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_VolumeInfo::_parseLibPath), "PSF library path");
  //tss_harvcl::register "-id" argument with some common volume IDs information
  {
    char* volumeIDSStr = (char*)::malloc(512);
    ::snprintf(volumeIDSStr, 512,
      "        %" PRIu32 " = VOLUME_SENSOR_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_HEALTH_TIME_SERIES\n"
      "        %" PRIu32 " = VOLUME_CLOCK_STATUS\n"
      "        %" PRIu32 " = VOLUME_HEALTH_DIGEST\n"
      "        %" PRIu32 " = VOLUME_OPERATION_LOG\n"
      "        %" PRIu32 " = VOLUME_HARVEST_LOG\n"
      "        %" PRIu32 " = VOLUME_FORENSIC_LOG\n"
      "        %" PRIu32 " = VOLUME_HEALTH_STATE\n"
      "        %" PRIu32 " = VOLUME_HEALTH_PDF\n"
      "        %" PRIu32 " = VOLUME_SEISMIC_PDF",
      PDB_eVolumeID::VOLUME_SENSOR_TIME_SERIES,
	    PDB_eVolumeID::VOLUME_HEALTH_TIME_SERIES,
	    PDB_eVolumeID::VOLUME_CLOCK_STATUS,
	    PDB_eVolumeID::VOLUME_HEALTH_DIGEST,
      PDB_eVolumeID::VOLUME_OPERATION_LOG,
      PDB_eVolumeID::VOLUME_HARVEST_LOG,
      PDB_eVolumeID::VOLUME_FORENSIC_LOG,
	    PDB_eVolumeID::VOLUME_HEALTH_STATE,
	    PDB_eVolumeID::VOLUME_HEALTH_PDF,
	    PDB_eVolumeID::VOLUME_SEISMIC_PDF);
    this->_registerArgument("-id=", CLCOMMAND_PARSE_HANDLER(CLCommand_VolumeInfo::_parseVolumeId), "volume integer ID. e.i:\n" + std::string(volumeIDSStr));
    ::free(volumeIDSStr);
  }
  this->_registerArgument("-s=", CLCOMMAND_PARSE_HANDLER(CLCommand_VolumeInfo::_parseLoadSections), "amount of sections to load (-1 = maximum/all sections)", "0");
}

bool CLCommand_VolumeInfo::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_VolumeInfo::_parseVolumeId(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_volumeId = ::atoi(arg);
  return true;
}
bool CLCommand_VolumeInfo::_parseLoadSections(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  /*
  Although number of sections in a volume is full range(uint32_t), this command line option will exclude the first(0th) section of the volume.
  This command line option only deals with data sections, so the header section is not included.
  Therefore, for data sections the range is limited to[0, 2 ^ 32 - 2] and the crude cast from - 1 to uint32_t is satisfactory in this case.
  */
  m_nSectionsToLoad = ::atoi(arg);
  return true;
}

int CLCommand_VolumeInfo::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }
  if (m_volumeId == (uint32_t)-1)
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT, 
      "Volume ID (integer) not specified ('-id=<volume ID>')");
    return -1;
  }

  const std::shared_ptr<Operation_GetVolumeInfo> op = std::make_shared<Operation_GetVolumeInfo>(m_libPath, m_volumeId, m_nSectionsToLoad,
    std::make_shared<GetVolumeInfo_Delegate>(m_logger));
  if (op->execute(m_hasher, m_logger))
    return 1;

  return -1;
}

std::string CLCommand_VolumeInfo::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Prints volume's info");
}
