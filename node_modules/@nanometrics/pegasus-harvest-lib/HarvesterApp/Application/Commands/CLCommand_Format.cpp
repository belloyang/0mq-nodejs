#include "CLCommand_Format.h"

#include <Operations/Operation_Format.h>

#include <cstring> // strncmp
#include <cinttypes>

class Format_Delegate : public Operation_Format::IDelegate
{
public:
  Format_Delegate(const std::shared_ptr<ILogger>& logger)
    : m_logger(logger)
    , m_stageNames {
      "Parsing configuration",
      "Creating FAT32",
      "Creating PSF",
      "Completed"
     }
  {
    __DEV_CALLSTACK_FUNC__;
  }
  virtual ~Format_Delegate() = default;
  
  virtual void onStageChanged(IOperation* pOperation, const eStage currentStage) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_logger->info(pOperation->getName().c_str(), "Entering stage '%s'...", m_stageNames[currentStage].c_str());
  }

  virtual void onCompleted(IOperation* pOperation, const eOperationStatus status) __OVERRIDES__(Operation_GetDigitizerInfo::IDelegate)
  {
    __DEV_CALLSTACK_FUNC__;
    m_logger->info(pOperation->getName().c_str(), "completed with status %" PRIu32, static_cast<uint32_t>(status));
  }

private:
  const std::shared_ptr<ILogger> m_logger;
  const std::string m_stageNames[eStage::STAGES_COUNT];
};


CLCommand_Format::CLCommand_Format(const std::shared_ptr<ILogger>& logger)
:  CLCommandBase("format", logger)
,  m_libPath("")
,  m_bCreatePSF(true)
,  m_configJSON("")
{
  __DEV_CALLSTACK_FUNC__;
  this->_registerArgument("-i=", CLCOMMAND_PARSE_HANDLER(CLCommand_Format::_parseLibPath), 
    "PSF library path");
  this->_registerArgument("-psf=", CLCOMMAND_PARSE_HANDLER(CLCommand_Format::_parseCreatePSF),
    "creates PSF structure (1|0)", "1");
  this->_registerArgument("-json=", CLCOMMAND_PARSE_HANDLER(CLCommand_Format::_parseConfigJSON),
    "json configuration file", "none");
}

bool CLCommand_Format::_parseLibPath(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_libPath = std::string(arg);
  return true;
}
bool CLCommand_Format::_parseCreatePSF(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_bCreatePSF = (::atoi(arg) == 1);
  return true;
}
bool CLCommand_Format::_parseConfigJSON(const char* arg)
{
  __DEV_CALLSTACK_FUNC__;
  m_configJSON = std::string(arg);
  return true;
}

int CLCommand_Format::_runImpl()
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check parsed arguments
  if (m_libPath.empty())
  {
    m_logger->error(m_name.c_str(), eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_MISSING_ARGUMENT,
      "Library path is not specified ('-i=<psf path>')");
    return -1;
  }

  //tss_harv::create Format operation and execute it
  const std::shared_ptr<IOperation> op = std::make_shared<Operation_Format>(m_libPath, m_bCreatePSF, m_configJSON,
      std::make_shared<Format_Delegate>(m_logger));
  if (op->execute(m_hasher, m_logger))
    return 1;
  
  return -1;
}

std::string CLCommand_Format::_getDescriptionImpl() const
{
  __DEV_CALLSTACK_FUNC__;
  return std::string("Creates PSF structure at specified path");
}
