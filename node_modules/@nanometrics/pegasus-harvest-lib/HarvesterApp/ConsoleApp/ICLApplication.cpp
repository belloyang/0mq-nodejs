#include "ICLApplication.h"

ICLApplication::ICLApplication(const std::shared_ptr<ILogger>& logger)
:  m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

int ICLApplication::run(int argc, char** argv)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::1st (0th) argument as it's executable file by itself -> check if any argument is specified
  if (argc <= 1)
  {
    m_logger->warning(__THIS_FUNC__, "No commands specified!. Use 'help' to see available commands list");
    return -1;
  }

  //tss_harv::fetch command name and create the command
  const std::string commandName = argv[1];
  //tss_harv::process 'help' command
  if (commandName == "help")
  {
    for (const auto& cmd : m_commandCreators)
    {
      ICLCommand* const pCommand = (this->*cmd.second)();
      if (pCommand != nullptr)
      {
        //tss_harv::print help
        pCommand->printHelp();
        delete pCommand;
      }
    }
    return 1;
  }

  //tss_harv::create certain/requested command and execute it
  ICLCommand* const pCommand = this->_createCommand(commandName);
  if (pCommand != nullptr)
  {
    //tss_harv::execute command (skip executable path and command name)
    const int iRet = pCommand->run(argc - 2, &argv[2]);
    //tss_harv::cleanup command
    delete pCommand;
    //tss_harv::return command result
    return iRet;
  }

  //tss_harv:::report an error
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_UNKNOWN, 
    "Command '%s' cannot be run",
    commandName.c_str());
  return -1;
}

void ICLApplication::_registerCommand(const std::string& name, CLCommandCreator creator)
{
  __DEV_CALLSTACK_FUNC__;
  //tss_harv::check if command is already registered
  const auto foundIt = m_commandCreators.find(name);
  if (foundIt != m_commandCreators.end())
    m_logger->warning(__THIS_FUNC__, "Command '%s' has been already registered. Re-registering is being done!!!");
  //tss_harv::register command creator
  m_commandCreators.insert(std::make_pair(name, creator));
}

ICLCommand* ICLApplication::_createCommand(const std::string& name) const
{
  __DEV_CALLSTACK_FUNC__;
  const auto foundIt = m_commandCreators.find(name);
  if (foundIt != m_commandCreators.end())
  {
    //tss_harv::create command using creator
    return (this->*foundIt->second)();
  }

  //tss_harv::notify that command is not created
  m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_COMMAND_UNKNOWN,
    "Command '%s' is not supported",
    name.c_str());
  return nullptr;
}

