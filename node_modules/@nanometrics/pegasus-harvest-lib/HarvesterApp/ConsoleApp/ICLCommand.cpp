#include "ICLCommand.h"

#include <Meters/Timers/TimerNs.h>

#include <string.h>
#include <cstring>
#include <Utils/pdb_utils.h>

ICLCommand::ICLCommand(const std::string& name, const std::shared_ptr<ILogger>& logger)
:  m_name(name)
,  m_logger(logger)
,  m_timer(std::make_shared<TimerNs>())
{
  __DEV_CALLSTACK_FUNC__;
}

int ICLCommand::run(int argc, char** argv)
{
  __DEV_CALLSTACK_FUNC__
  //tss_harv::check if help is requested -> print help string
  if (argc >= 1 && (::strcmp(argv[0], "help") == 0))
  {
    this->printHelp();
    return 1;
  }

  //tss_harv::parse arguments
  if (!this->_parseArgs(argc, argv))
  {
    m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT,
      "Failed to parse arguments!");
    return -1;
  }

  //tss_harv::execute command
  const timestamp_t startTimeNs = m_timer->now();
  const int iRet = this->_runImpl();
  const timediff_t elapsedNs = m_timer->getElapsed(startTimeNs);
  m_logger->info(m_name.c_str(), "Finished in %.2f seconds", pdb_utils::nanoseconds_to_seconds(elapsedNs));
  return iRet;
}

void ICLCommand::_registerArgument(const std::string& name, const ParseHandler handler,
    const std::string& description, const std::string& defaultValue)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(!name.empty() && handler != nullptr && "Cannot register argument witouh name or parsing handler");
  sArgument arg;
  {
    arg.name = name;
    arg.parseHandler = handler;
    arg.description = description;
    arg.defaultValue = defaultValue;
  }
  m_registeredArgs.push_back(arg);
}

bool ICLCommand::_parseArgs(int argc, char** argv)
{
  __DEV_CALLSTACK_FUNC__;
  for (int i = 0; i < argc; i++)
  {
    bool bParserFound = false;
    //tss_harv::find appropriate parser handler
    for (const auto& registeredArg : m_registeredArgs)
    {
      const std::string& regArgName = registeredArg.name;
      if (::strncmp(regArgName.c_str(), argv[i], regArgName.length()) == 0)
      {
        bParserFound = true;
        //tss_harv::check if parsing failed and finish parsing arguments
        if ((this->*registeredArg.parseHandler)(argv[i] + regArgName.length()) == false)
        {
          m_logger->error(__THIS_FUNC__, eErrorCategory::ERROR_CATEGORY_LIBRARY, eHarvCLErrorCode::HARVCL_ERROR_INVALID_ARGUMENT, 
            "Failed to parse '%s'", argv[i]);
          return false;
        }
        //tss_harv::goto the next argument
        break;
      }
    }
    //tss_harv::print warning if parser for argument hasn't been found
    if (!bParserFound)
      m_logger->warning(__THIS_FUNC__, "Unrecognized argument '%s' will be skipped!", argv[i]);
  }
  
  return true;
}

int ICLCommand::printHelp() const
{
  __DEV_CALLSTACK_FUNC__;
  std::string argsString = "";
  for (const auto& arg : m_registeredArgs)
  {
    const std::string argDesc = (arg.defaultValue.empty()) ? 
        std::string("    ") + arg.name + "<" + arg.description + ">\n" :
        std::string("    [") + arg.name + "<" + arg.description + ", " + arg.defaultValue + " by default>]\n";
    argsString += argDesc;
  }
  const std::string& description = this->_getDescriptionImpl();
  m_logger->info(m_name.c_str(), "%s.\nUsage:  %s <parameters>\n%s", description.c_str(),
      m_name.c_str(), argsString.c_str());
  return 1;
}
