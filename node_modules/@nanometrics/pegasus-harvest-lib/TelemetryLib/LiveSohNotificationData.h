#ifndef LiveSohNotificationData_h__
#define LiveSohNotificationData_h__

#include <DataTypes/HealthDigest/MsgHealthDigest.h>
#include <DataTypes/HealthTimeSeries/MsgSohData.h>

typedef MsgSohData::Header::SohDataV0::HealthInputsV0 HealthInputsData;
typedef MsgSohData::Header::SohDataV0::ClockStatusV0 ClockStatusData;

#pragma pack(push, 1)

//! Live SOH data structure. Is designed to be sent over BLE to mobile app
struct LiveSohNotificationData
{
  static const uint32_t VERSION = 3u;
  //! common data
  uint16_t version = 0u;
  int64_t timestamp = 0ll;
  uint64_t uptime = 0ull;

  //! only several metrics are being taken from SOH HealthInput packet
  struct HealthInputs
  {
    float batteryVolts = 0.f;
    float mainCurrentAmps = 0.f;
    float systemTempDegrees = 0.f;
    float sensorCurrentAmps = 0.f;
    float systemPressurePascals = 0.f;
  } healthInputs;

  //! current SOH digest
  struct Digest
  {
    MsgHealthDigest::Header::sDigest current;
  } digest;

  //! clock status data
  //
  // NOTE:
  // Should only contain plain-old-data as may be used with placement new for
  // efficient initialisation of existing objects.
  struct ClockStatus
  {
    ClockStatusData::AntennaStatus antennaStatus = ClockStatusData::AntennaStatus::ANTENNA_STATUS_OFF;
    uint8_t nSatellites = 0;
    int32_t timeUncertaintyMicroSeconds = 0;
    uint8_t gnssExternalAntenna = 0;
    struct GNSSLocation
    {
      double latitude  = 0.0; // arc-degrees [ -90 , +90 ]
      double longitude = 0.0; // arc-degrees [ -180 , +180 )
      float  altitude  = 0.f; // meters above mean sea level
    } location;
  } clockStatus;

  //! Sensor SOH lines
  struct SOHLines
  {
    float sohLine1Volts = 0.f;
    float sohLine2Volts = 0.f;
    float sohLine3Volts = 0.f;
    float sohLine4Volts = 0.f;
  } sohLines;

  //! OBS and other extended timing status (extension)
  struct ExtendedTiming
  {
    enum Flags : uint8_t
    {
      NONE = 0,
      SYSTEM_READY          = 1 << 0, // indicates readiness of the timing subsystem to accept the 'gnssCtrl' command
      VCXO_CONVERGED        = 1 << 1, // indicates convergence of the VCXO frequency discipline function
      PHASE_ERROR_EST_READY = 1 << 2, // indicates readiness of dT (phase error, SeascanPhase structure) estimation
      GNSS_ALWAYS_ON        = 1 << 3, // Land only: indicates GNSS is forced always on
      // The following enum is provided for information only.
      // The timing subsystem will only accept the 'obsSync' command when all flags are set.
      OBS_SYNC_ALLOWED = SYSTEM_READY | VCXO_CONVERGED | PHASE_ERROR_EST_READY,
    };
    uint8_t flags = Flags::NONE;
    struct SeascanPhase
    {
      uint32_t dtNs    = 0u; // Estimate of dT over the last 30 seconds (rolling window). Units are nanoseconds. Valid range is [0, 1e9).
      uint32_t rangeNs = 0u; // max(dT) - min(dT) for the last 30 seconds (rolling window). Units are nanoseconds.  Valid range is [0, 1500].
    } seascanPhase;
    struct GnssPpsTime
    {
      uint32_t gnssSecs = 0u; // POSIX time value for current GNSS time in seconds.
                              // POSIX epoch (Jan 1st 1970, midnight) indicates GNSS time is unavailable.
      uint64_t systemNs = 0u; // POSIX time value for current system time used for data recording in nanoseconds.
                              // This value is always available since the digitizer is designed to commence data recording from power-on.
    } gnssPpsTime;
    uint32_t lastSyncTimeSecs = 0u; // POSIX time value when the system was last synchronised to GNSS time in seconds.
    uint32_t gnssLockDurationSeconds = 0u; // Elapsed time since GNSS lock was achieved. This counter is reset to zero when the GNSS lock is lost.
  } extendedTiming;
};
#pragma pack(pop)

#endif //LiveSohNotificationData_h__
