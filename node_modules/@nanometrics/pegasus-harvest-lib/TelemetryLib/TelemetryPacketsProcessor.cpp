#include "TelemetryPacketsProcessor.hpp"

#include "telemetry_utils.hpp"

#include "LiveSohNotificationData.h"
#include <DataTypes/SensorTimeSeries/MsgSensorInput.h>
#include <Hasher/CRCDriver/CRCDriver_CRC16_CCITT.h>

#include <cstring>
#include <cinttypes>

namespace
{
  const char THIS_CLASS_NAME[] = "TelemetryPacketsProcessor";
}

TelemetryPacketsProcessor::TelemetryPacketsProcessor(const std::shared_ptr<ISerialPort>& serialPort,
  const std::shared_ptr<IResponseBufferProvider>& bufferProvider,
  const std::shared_ptr<ILogger>& logger)
: m_serialPort(serialPort)
, m_bufferProvider(bufferProvider)
, m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
  m_rxState.crcDriver = std::make_shared<CRCDriver_CRC16_CCITT>(m_logger);
  m_txState.crcDriver = std::make_shared<CRCDriver_CRC16_CCITT>(m_logger);
}

TelemetryAPI::Error TelemetryPacketsProcessor::_validateHeader(const TelemetryAPI::Packet& packet) const
{
  __DEV_CALLSTACK_FUNC__;
  // Header arrives here in big-endian (network byte order);
  if (::memcmp(packet.header.start, TelemetryAPI::PACKET_START_ID, sizeof(TelemetryAPI::PACKET_START_ID)) != 0)
  {
    m_logger->warning(THIS_CLASS_NAME, "Invalid packet (start='%.*s')",
      NUM_ELEMENTS(packet.header.start), packet.header.start);
    return TelemetryAPI::Error::ERROR_MALFORMED_PACKET;
  }

  // check packet type and payload size match
  uint16_t packetType = packet.header.type;
  telemetry_utils::swap(packetType);
  uint16_t payloadSize = packet.header.payloadSize;
  telemetry_utils::swap(payloadSize);
  switch (packetType)
  {
    case TelemetryAPI::TimeSeries::START_STREAMING_REQUEST:
      return (payloadSize > 0u) && (payloadSize <= sizeof(packet.timeSeries.startStreamingRequest)) ?
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::TimeSeries::STREAMING_RESPONSE:
      return (payloadSize == (sizeof(packet.timeSeries.streamingResponse.header) + sizeof(MsgSensorInput::Header))) ?
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::TimeSeries::STOP_STREAMING_REQUEST:
      return (payloadSize == 0) ? // no payload
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::SOH::REQUEST:
      return (payloadSize == 0) ? // no payload
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::SOH::RESPONSE:
      return (payloadSize == sizeof(LiveSohNotificationData)) ?
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::Info::REQUEST:
      return (payloadSize == 0) ? // no payload
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::Info::RESPONSE:
      return (payloadSize == sizeof(DigitizerInfo)) ?
        TelemetryAPI::Error::ERROR_NONE :  TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    case TelemetryAPI::Acknowledgment::RESPONSE:
      return (payloadSize == sizeof(packet.acknowledgment.response)) ?
        TelemetryAPI::Error::ERROR_NONE : TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE;
    default:
      m_logger->warning(THIS_CLASS_NAME, "Unknown packet type 0x%04x", packetType);
      return TelemetryAPI::Error::ERROR_UNKNOWN_PACKET_TYPE;
  }

  m_logger->warning(THIS_CLASS_NAME, "Unknown error");
  return TelemetryAPI::Error::ERROR_UNKNOWN;
}

uint32_t TelemetryPacketsProcessor::_receiveData(void* buffer, const uint32_t size, const bool logWarning/*=true*/)
{
  __DEV_CALLSTACK_FUNC__;
  const uint32_t nBytesReceived = m_serialPort->receive(buffer, size);
  if ((nBytesReceived != size) && logWarning)
  {
    m_logger->warning(THIS_CLASS_NAME, "Incomplete data received (expected=%" PRIu32 ", actual=%" PRIu32 ")",
      size, nBytesReceived);
  }
  return nBytesReceived;
}

uint32_t TelemetryPacketsProcessor::receive(TelemetryAPI::Packet& packet, TelemetryAPI::Error& retCode)
{
  __DEV_CALLSTACK_FUNC__;
  uint32_t checksum = 0u;
  uint32_t nBytesRead = 0u;
  TelemetryAPI::Packet& rxPacket = m_rxState.packet;
  const auto& crcDriver = m_rxState.crcDriver;
  // receive header
  // 1: receive 'packet start id' byte by byte for re-sync
  constexpr uint32_t packetStartIdSize = NUM_ELEMENTS(TelemetryAPI::PACKET_START_ID);
  for (uint32_t i = 0; i < packetStartIdSize; ++i)
  {
    char value = 0;
    nBytesRead += this->_receiveData(&value, sizeof(value), (nBytesRead > 0u));
    if (nBytesRead == 0) // no data read from port -> assume no data -> return 0
    {
      return nBytesRead;
    }
    rxPacket.header.start[i] = value;
    if (value != TelemetryAPI::PACKET_START_ID[i])
    {
      // check sync lost after this byte read
      if (m_syncState.isSynced)
      {
        m_syncState.isSynced = false;
        m_logger->warning(THIS_CLASS_NAME, "Unexpected packet start. Sync lost. Resync in progress...");
      }
      m_syncState.nBytesTillResynced += nBytesRead;
      retCode = TelemetryAPI::Error::ERROR_MALFORMED_PACKET;
      return nBytesRead;
    }
  }
  // packet start ID has been read ok by now. Check if sync restored here -> report info
  if (!m_syncState.isSynced)
  {
    m_logger->info(THIS_CLASS_NAME, "Sync restored after %" PRIu32 " bytes", m_syncState.nBytesTillResynced);
    m_syncState.isSynced = true;
    m_syncState.nBytesTillResynced = 0;
  }

  // 2: receive the header remainder (type, payload size)
  nBytesRead += this->_receiveData(&rxPacket.header.type, sizeof(rxPacket.header) - packetStartIdSize);
  // check that entire header received
  if (nBytesRead != sizeof(rxPacket.header))
  {
    retCode = TelemetryAPI::Error::ERROR_UNKNOWN;
    return nBytesRead;
  }

  // receive and verify header CRC
  uint16_t expectedHeaderCRC = 0u;
  nBytesRead += this->_receiveData(&expectedHeaderCRC, sizeof(expectedHeaderCRC));
  telemetry_utils::swap(expectedHeaderCRC);
  uint32_t headerCRC = crcDriver->calculate(&rxPacket.header, sizeof(rxPacket.header));
  headerCRC = crcDriver->finalize(headerCRC);
  if (static_cast<uint16_t>(headerCRC) != expectedHeaderCRC)
  {
    m_logger->warning(THIS_CLASS_NAME, "Header hash mismatch (calculated=0x%04x, expected=0x%04x)",
      headerCRC, expectedHeaderCRC);
    retCode = TelemetryAPI::Error::ERROR_INVALID_HEADER_CRC;
    return nBytesRead;
  }

  // packet header passed CRC - continue processing
  retCode = this->_validateHeader(rxPacket);
  telemetry_utils::swap(rxPacket.header);
  const uint16_t payloadSize = rxPacket.header.payloadSize;
  if (retCode != TelemetryAPI::Error::ERROR_NONE)
  {
    if (retCode == TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE)
    {
      m_logger->warning(THIS_CLASS_NAME, "Invalid payload size %d for packet 0x%04X",
        rxPacket.header.payloadSize, rxPacket.header.type);
    }

    // wrong payload size or unknown packet - drain the packet payload and crc if there is a payload
    if (rxPacket.header.payloadSize > 0u)
    {
      uint16_t remainingBytes = rxPacket.header.payloadSize + sizeof(uint16_t);
      while (remainingBytes)
      {
        uint8_t drainByte;
        nBytesRead += this->_receiveData(&drainByte, sizeof(drainByte));
        remainingBytes--;
      }
    }
    // copy working packet header (swapped to little-endian) into result
    ::memcpy(&packet.header, &rxPacket.header, sizeof(rxPacket.header));
    return nBytesRead;
  }

  // everything good so far - receive payload and calculate checksum down the track
  switch (rxPacket.header.type)
  {
    case TelemetryAPI::TimeSeries::START_STREAMING_REQUEST:
    {
      auto& request = rxPacket.timeSeries.startStreamingRequest;
      nBytesRead += this->_receiveData(&request, payloadSize);
      // no swap needed here, all the fields are 1-byte long
      checksum = crcDriver->calculate(&request, payloadSize);
    }
    break;

    case TelemetryAPI::TimeSeries::STREAMING_RESPONSE:
    {
      auto& response = rxPacket.timeSeries.streamingResponse;
      nBytesRead += this->_receiveData(&response.header, sizeof(response.header));
      checksum = crcDriver->calculate(&response.header, sizeof(response.header));
      telemetry_utils::swap(response.header.sequenceNumber);
      // get response buffer from the client to receive response body (live waveforms)
      MsgSensorInput::Header* pHeader = (m_bufferProvider != nullptr) ? m_bufferProvider->getTimeSeriesBuffer() : nullptr;
      if (pHeader != nullptr)
      {
        // receive content
        nBytesRead += this->_receiveData(pHeader, sizeof(*pHeader));
        checksum = crcDriver->accumulate(pHeader, sizeof(*pHeader));
        telemetry_utils::swap(*pHeader);
      }
      else  // no buffer for response -> drain serial port response
      {
        constexpr uint32_t metadataSize = __builtin_offsetof(MsgSensorInput::Header, frames);
        __ATTR_ALIGNED__(32) uint8_t metadataBuffer[metadataSize] = { 0 };
        // receive and drain metadata
        nBytesRead += this->_receiveData(metadataBuffer, metadataSize);
        checksum = crcDriver->accumulate(metadataBuffer, metadataSize);
        // receive and drain frames
        __ATTR_ALIGNED__(32) SteimFrame_t frame;
        for (uint16_t i = 0; i < NUM_ELEMENTS(MsgSensorInput::Header::frames); ++i)
        {
          nBytesRead += this->_receiveData(&frame, sizeof(frame));
          checksum = crcDriver->accumulate(&frame, sizeof(frame));
        }
      }
      response.buffer = pHeader;
    }
    break;

    case TelemetryAPI::TimeSeries::STOP_STREAMING_REQUEST:
      // no payload
      break;

    case TelemetryAPI::SOH::REQUEST:
      // no payload
      break;

    case TelemetryAPI::SOH::RESPONSE:
    {
      auto& response = rxPacket.soh.response;
      // get response buffer from the client to receive response body (current SOH)
      LiveSohNotificationData* data = (m_bufferProvider != nullptr) ? m_bufferProvider->getSohBuffer() : nullptr;
      if (data != nullptr)
      {
        nBytesRead += this->_receiveData(data, sizeof(*data));
        checksum = crcDriver->calculate(data, sizeof(*data));

        // swap fields using intermediate copy of struct
        // TODO: this is a work-around for a potential alignment bug in Raspberry Pi building. Investigate if this can be removed
        {
          LiveSohNotificationData tmp = *data;
          telemetry_utils::swap(tmp);
          *data = tmp;
        }
      }
      else // no buffer for response -> drain serial port response
      {
        LiveSohNotificationData tmp;
        nBytesRead += this->_receiveData(&tmp, sizeof(tmp));
        checksum = crcDriver->calculate(&tmp, sizeof(tmp));
      }
      response.buffer = data;
    }
    break;

    case TelemetryAPI::Info::REQUEST:
      // no payload
      break;

    case TelemetryAPI::Info::RESPONSE:
    {
      auto& response = rxPacket.info.response;
      // get response buffer from the client to receive response body (digitizer info)
      DigitizerInfo* data = (m_bufferProvider != nullptr) ? m_bufferProvider->getInfoBuffer() : nullptr;
      if (data != nullptr)
      {
        nBytesRead += this->_receiveData(data, sizeof(*data));
        checksum = crcDriver->calculate(data, sizeof(*data));
        // no fields to swap here
      }
      else // no buffer for response -> drain serial port response
      {
        DigitizerInfo tmp;
        nBytesRead += this->_receiveData(&tmp, sizeof(tmp));
        checksum = crcDriver->calculate(&tmp, sizeof(tmp));
      }
      response.buffer = data;
    }
    break;

    case TelemetryAPI::Acknowledgment::RESPONSE:
    {
      auto& response = rxPacket.acknowledgment.response;
      nBytesRead += this->_receiveData(&response, payloadSize);
      checksum = crcDriver->calculate(&response, payloadSize);
      telemetry_utils::swap(response.request);
      telemetry_utils::swap(response.errorCode);
    }
    break;

    default:
      m_logger->warning(THIS_CLASS_NAME, "Unknown packet type");
      retCode = TelemetryAPI::Error::ERROR_UNKNOWN_PACKET_TYPE;
      return nBytesRead;
  }
  // receive expected payload checksum and compare it to calculated
  if (payloadSize > 0)
  {
    checksum = crcDriver->finalize(checksum);
    uint16_t expectedChecksum = 0;
    nBytesRead += this->_receiveData(&expectedChecksum, sizeof(expectedChecksum));
    telemetry_utils::swap(expectedChecksum);
    if (static_cast<uint16_t>(checksum) != expectedChecksum)
    {
      m_logger->warning(THIS_CLASS_NAME, "Payload hash mismatch for 0x%04x (calculated=0x%04x, expected=0x%04x)",
        rxPacket.header.type, checksum, expectedChecksum);
      retCode = TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_CRC;
      // data read entirely by now -> report the error but return the actual data letting the client decide how to handle this case
      ::memcpy(&packet, &rxPacket, sizeof(rxPacket));
      return nBytesRead;
    }
  }
  // copy working packet (swapped to little-endian) into result
  ::memcpy(&packet, &rxPacket, sizeof(rxPacket));
  retCode = TelemetryAPI::Error::ERROR_NONE;
  return nBytesRead;
}

uint32_t TelemetryPacketsProcessor::_sendData(const void* buffer, const uint32_t size, const bool logWarning/*=true*/)
{
  __DEV_CALLSTACK_FUNC__;
  const uint32_t nBytesSent = m_serialPort->send(buffer, size);
  if ((nBytesSent != size) && logWarning)
  {
    m_logger->warning(THIS_CLASS_NAME, "Incomplete data sent (expected=%" PRIu32 ", actual=%" PRIu32 ")",
      size, nBytesSent);
  }
  return nBytesSent;
}

bool TelemetryPacketsProcessor::send(const TelemetryAPI::Packet& packet)
{
  __DEV_CALLSTACK_FUNC__;
  const uint16_t packetType = packet.header.type;
  const uint16_t payloadSize = packet.header.payloadSize;
  TelemetryAPI::Packet& txPacket = m_txState.packet;
  const auto& crcDriver = m_txState.crcDriver;
  // copy content into working packet and swap header part
  ::memcpy(&txPacket, &packet, sizeof(packet));
  telemetry_utils::swap(txPacket.header);
  const TelemetryAPI::Error errCode = this->_validateHeader(txPacket);
  if (errCode != TelemetryAPI::Error::ERROR_NONE)
  {
    if (errCode == TelemetryAPI::Error::ERROR_INVALID_PAYLOAD_SIZE)
    {
      m_logger->warning(THIS_CLASS_NAME, "Invalid payload size %d for packet 0x%04X",
        txPacket.header.payloadSize, txPacket.header.type);
    }
    return false;
  }
  // send header and CRC
  {
    this->_sendData(&txPacket.header, sizeof(txPacket.header));
    uint16_t headerCRC = crcDriver->calculate(&txPacket.header, sizeof(txPacket.header));
    telemetry_utils::swap(headerCRC);
    this->_sendData(&headerCRC, sizeof(headerCRC));
  }

  // send payload and calculate payload checksum down the track
  uint32_t checksum = 0u;
  switch (packetType)
  {
    case TelemetryAPI::TimeSeries::START_STREAMING_REQUEST:
      // no swap needed here, all the fields are 1-byte long
      this->_sendData(&txPacket.timeSeries.startStreamingRequest, payloadSize);
      checksum = crcDriver->calculate(&txPacket.timeSeries.startStreamingRequest, payloadSize);
      break;

    case TelemetryAPI::TimeSeries::STREAMING_RESPONSE:
    {
      auto& response = txPacket.timeSeries.streamingResponse;
      // swap and send payload header
      telemetry_utils::swap(response.header.sequenceNumber);
      this->_sendData(&response.header, sizeof(response.header));
      checksum = crcDriver->calculate(&response.header, sizeof(response.header));
      // send seismic packet
      const MsgSensorInput::Header* const pHeader = response.buffer;
      // swap send metadata portion
      constexpr uint32_t metadataSize = __builtin_offsetof(MsgSensorInput::Header, frames);
      static uint8_t metadata[metadataSize] = {0};
      ::memcpy(metadata, pHeader, metadataSize);
      telemetry_utils::swap(*reinterpret_cast<MsgSensorInput::Header*>(metadata));
      this->_sendData(metadata, metadataSize);
      checksum = crcDriver->accumulate(metadata, metadataSize);
      // send frames portion (no swap)
      this->_sendData(pHeader->frames, sizeof(pHeader->frames));
      checksum = crcDriver->accumulate(pHeader->frames, sizeof(pHeader->frames));
    }
    break;

    case TelemetryAPI::TimeSeries::STOP_STREAMING_REQUEST:
      // no payload
      break;

    case TelemetryAPI::SOH::REQUEST:
      // no payload
      break;

    case TelemetryAPI::SOH::RESPONSE:
    {
      auto& response = txPacket.soh.response;
      LiveSohNotificationData data = *response.buffer;
      telemetry_utils::swap(data);
      this->_sendData(&data, sizeof(data));
      checksum = crcDriver->calculate(&data, sizeof(data));
    }
    break;

    case TelemetryAPI::Info::REQUEST:
      // no payload
      break;

    case TelemetryAPI::Info::RESPONSE:
    {
      auto& response = txPacket.info.response;
      // nothing to swap in DigitizerInfo structure
      this->_sendData(response.buffer, sizeof(*response.buffer));
      checksum = crcDriver->calculate(response.buffer, sizeof(*response.buffer));
    }
    break;

    case TelemetryAPI::Acknowledgment::RESPONSE:
    {
      auto& response = txPacket.acknowledgment.response;
      telemetry_utils::swap(response.request);
      telemetry_utils::swap(response.errorCode);
      this->_sendData(&response, sizeof(response));
      checksum = crcDriver->calculate(&response, sizeof(response));
    }
    break;

    default:
      m_logger->warning(THIS_CLASS_NAME, "Unknown packet type 0x%04x", packetType);
      return false;
  }
  // send payload checksum if payload is present
  if (payloadSize > 0)
  {
    uint16_t actualChecksum = crcDriver->finalize(checksum);
    telemetry_utils::swap(actualChecksum);
    this->_sendData(&actualChecksum, sizeof(actualChecksum));
  }
  return true;
}
