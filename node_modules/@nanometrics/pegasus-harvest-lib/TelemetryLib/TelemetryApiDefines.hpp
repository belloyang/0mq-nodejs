#ifndef TelemetryApiDefines_hpp__
#define TelemetryApiDefines_hpp__

#include "LiveSohNotificationData.h"
#include "DigitizerInfo.h"
#include <DataTypes/SensorTimeSeries/MsgSensorInput.h>

/*
 * This defines structures and constants described in the doc:
 * https://docs.google.com/document/d/1AHWFuqgZ-7APwgEFJUcKeG6Ma_4-81okONNNtUWWuQk/edit#heading=h.7pi0em9vtg1k
 */
#include "../shared_defines.h"

namespace TelemetryAPI
{
#pragma pack(push, 1)
  const uint16_t MAX_SAMPLE_RATE = 500u; // 500Hz (limitation imposed by RS232)
  const char PACKET_START_ID[4]  = { 'P', 'T', '0', '1' };

  enum Error : uint16_t
  {
    ERROR_NONE                 = 0x0000, // no error. Request accepted

    ERROR_MALFORMED_PACKET     = 0x0001,
    ERROR_UNKNOWN_PACKET_TYPE  = 0x0002, // packet type is unknown
    ERROR_INVALID_PAYLOAD_SIZE = 0x0003, // invalid payload size
    ERROR_INVALID_HEADER_CRC   = 0x0004, // header CRC-check failed
    ERROR_INVALID_PAYLOAD_CRC  = 0x0005, // payload CRC-check failed
    ERROR_INVALID_ARGUMENT     = 0x0006, // packet is valid but provided arguments are not
    ERROR_REQUEST_REJECTED     = 0x0007, // unable to fulfill request

    ERROR_UNKNOWN              = 0xFFFF
  };

  namespace TimeSeries
  {
    enum PacketType : uint16_t
    {
      START_STREAMING_REQUEST = 0x0001, // start time series streaming
      STOP_STREAMING_REQUEST  = 0x0002, // stop time series streaming
      STREAMING_RESPONSE      = 0x8001, // time series response/data
    };

    enum Channels : uint8_t		// corresponds to Chariot's channel definitions
    {
      SENSOR_INPUT_1 = BIT(0),     // CHANNEL_1_PRIMARY
      SENSOR_INPUT_2 = BIT(1),     // CHANNEL_2_PRIMARY
      SENSOR_INPUT_3 = BIT(2),     // CHANNEL_3_PRIMARY
      SENSOR_INPUT_4 = BIT(3),     // CHANNEL_4_AUX
      ALL_SENSOR_INPUTS = SENSOR_INPUT_1 | SENSOR_INPUT_2 | SENSOR_INPUT_3 | SENSOR_INPUT_4,
    };

    union Payload
    {
      struct
      {
        uint8_t channels = 0;      // uses enum Channels above
      } startStreamingRequest;
      struct { } stopStreamingRequest;
      struct {
        struct
        {
          uint32_t sequenceNumber = 0;
        } header;
        const MsgSensorInput::Header* buffer = nullptr;
      } streamingResponse;
    };
  }

  namespace SOH
  {
    enum PacketType : uint16_t
    {
      REQUEST  = 0x0003, // current SOH request
      RESPONSE = 0x8003, // current SOH response
    };

    union Payload
    {
      struct { } request;
      struct
      {
        const LiveSohNotificationData* buffer = nullptr;
      } response;
    };
  }

  namespace Info
  {
    enum PacketType : uint16_t
    {
      REQUEST  = 0x0004, // digitizer information request
      RESPONSE = 0x8004, // digitizer information response
    };

    union Payload
    {
      struct { } request;
      struct
      {
        const DigitizerInfo* buffer = nullptr;
      } response;
    };
  }

  namespace Acknowledgment
  {
    enum PacketType : uint16_t
    {
      RESPONSE = 0x8000
    };
    union Payload
    {
      struct
      {
        uint16_t request = 0u;
        uint16_t errorCode = Error::ERROR_NONE;
      } response;
    };
  }

  // general packet
  struct Packet
  {
    struct Header
    {
      char start[4] = { 0 }; // should be packet start id ('PT01') for valid packet
      uint16_t type = 0; // request/response type
      uint16_t payloadSize = 0; // request/response size (payload + header/this)
    } header;
    // uint16_t crc follows the header during the packet transfer (send/receive)
    union // payload
    {
      TimeSeries::Payload timeSeries;
      SOH::Payload soh;
      Info::Payload info;
      Acknowledgment::Payload acknowledgment;
    };
    // uint16_t crc follows non-empty payload during the packet transfer (send/receive)
  };
#pragma pack(pop) // #pragma pack(push, 1)
}

#endif // TelemetryApiDefines_hpp__
