#include "TelemetryPacketsFactory.hpp"

#include <cinttypes>

namespace
{
  const char THIS_CLASS_NAME[] = "TelemetryPacketsFactory";
}

TelemetryPacketsFactory::TelemetryPacketsFactory(const std::shared_ptr<ILogger>& logger)
: m_logger(logger)
{
  __DEV_CALLSTACK_FUNC__;
}

void TelemetryPacketsFactory::_startPacket(TelemetryAPI::Packet& output, const uint16_t type) const
{
  __DEV_CALLSTACK_FUNC__;
  ::memcpy(output.header.start, TelemetryAPI::PACKET_START_ID, sizeof(TelemetryAPI::PACKET_START_ID));
  output.header.type = type;
}

void TelemetryPacketsFactory::_finalizePacket(TelemetryAPI::Packet& output, const uint16_t payloadSize) const
{
  __DEV_CALLSTACK_FUNC__;
  output.header.payloadSize = payloadSize;
}

bool TelemetryPacketsFactory::createTimeSeriesStartStreamingRequest(TelemetryAPI::Packet& output, const uint8_t channels)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(channels > 0u && (channels & ~TelemetryAPI::TimeSeries::ALL_SENSOR_INPUTS) == 0u && "Invalid channels vector");
  this->_startPacket(output, TelemetryAPI::TimeSeries::START_STREAMING_REQUEST);
  output.timeSeries.startStreamingRequest.channels = channels;
  this->_finalizePacket(output, sizeof(output.timeSeries.startStreamingRequest));
  return true;
}

bool TelemetryPacketsFactory::createTimeSeriesStopStreamingRequest(TelemetryAPI::Packet& output)
{
  __DEV_CALLSTACK_FUNC__;
  // build packet (no payload)
  this->_startPacket(output, TelemetryAPI::TimeSeries::STOP_STREAMING_REQUEST);
  this->_finalizePacket(output, 0);
  return true;
}

bool TelemetryPacketsFactory::createTimeSeriesStreamingResponse(TelemetryAPI::Packet& output, const MsgSensorInput::Header* data, const uint32_t sequenceNumber)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  this->_startPacket(output, TelemetryAPI::TimeSeries::STREAMING_RESPONSE);
  auto& response = output.timeSeries.streamingResponse;
  {
    response.header.sequenceNumber = sequenceNumber;
    response.buffer = data; // zero-copy: assign the pointer to seismic packet
  }
  this->_finalizePacket(output, sizeof(response.header) + sizeof(MsgSensorInput::Header));
  return true;
}

bool TelemetryPacketsFactory::createCurrentSOHRequest(TelemetryAPI::Packet& output)
{
  __DEV_CALLSTACK_FUNC__;
  // build packet (no payload)
  this->_startPacket(output, TelemetryAPI::SOH::REQUEST);
  this->_finalizePacket(output, 0);
  return true;
}

bool TelemetryPacketsFactory::createCurrentSOHResponse(TelemetryAPI::Packet& output, const LiveSohNotificationData* data)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  this->_startPacket(output, TelemetryAPI::SOH::RESPONSE);
  {
    output.soh.response.buffer = data; // zero-copy: assign the pointer to LiveSOH packet
  }
  this->_finalizePacket(output, sizeof(*data));
  return true;
}

bool TelemetryPacketsFactory::createDigitizerInfoRequest(TelemetryAPI::Packet& output)
{
  __DEV_CALLSTACK_FUNC__;
  // build packet (no payload)
  this->_startPacket(output, TelemetryAPI::Info::REQUEST);
  this->_finalizePacket(output, 0);
  return true;
}

bool TelemetryPacketsFactory::createDigitizerInfoResponse(TelemetryAPI::Packet& output, const DigitizerInfo* data)
{
  __DEV_CALLSTACK_FUNC__;
  __ASSERT__(data != nullptr && "'data' cannot be nullptr here");
  this->_startPacket(output, TelemetryAPI::Info::RESPONSE);
  {
    output.info.response.buffer = data; // zero-copy: assign the pointer to Info packet
  }
  this->_finalizePacket(output, sizeof(*data));
  return true;
}


bool TelemetryPacketsFactory::createAcknowledgmentResponse(TelemetryAPI::Packet& output, const uint16_t requestType,
		TelemetryAPI::Error errorCode)
{
  __DEV_CALLSTACK_FUNC__;
  this->_startPacket(output, TelemetryAPI::Acknowledgment::RESPONSE);
  auto& response = output.acknowledgment.response;
  {
    response.request = requestType;
    response.errorCode = errorCode;
  }
  this->_finalizePacket(output, sizeof(response));
  return true;
}
