#ifndef TelemetryPacketsProcessor_hpp__
#define TelemetryPacketsProcessor_hpp__

#include "TelemetryApiDefines.hpp"
#include "ISerialPort.hpp"
#include "IResponseBufferProvider.hpp"

#include <Hasher/CRCDriver/ICRCDriver.h>
#include <Logger/ILogger.h>

#include <memory>

/**
 * This class represents the telemetry packets processor (packet sender/receiver).
 * It's shared between the MCU and Telemetry Client code base.
 * That's why we have abstractions for all platform-specific things (ISerialPort, ICRCDriver, IResponseBufferProvider, ILogger).
 * The external client is responsible to implement that (reuse implemented from LibIO)
 */
class TelemetryPacketsProcessor
{
public:
  TelemetryPacketsProcessor(const std::shared_ptr<ISerialPort>& serialPort,
                      const std::shared_ptr<IResponseBufferProvider>& bufferProvider,
                      const std::shared_ptr<ILogger>& logger);
  virtual ~TelemetryPacketsProcessor() = default;

  uint32_t receive(TelemetryAPI::Packet& packet, TelemetryAPI::Error& retCode);
  bool send(const TelemetryAPI::Packet& packet);

private:
  TelemetryAPI::Error _validateHeader(const TelemetryAPI::Packet& packet) const;
  uint32_t _receiveData(void* buffer, const uint32_t size, const bool logWarning = true);
  uint32_t _sendData(const void* buffer, const uint32_t size, const bool logWarning = true);


  const std::shared_ptr<ISerialPort> m_serialPort;
  const std::shared_ptr<IResponseBufferProvider> m_bufferProvider;
  const std::shared_ptr<ILogger> m_logger;
  // working/proxy packets and CRC driver instances for data receiving/sending.
  // The separate states allow Rx and Tx to be performed on different threads in parallel
  struct
  {
    TelemetryAPI::Packet packet = {};
    std::shared_ptr<ICRCDriver> crcDriver = nullptr;
  } m_rxState, m_txState;
  struct
  {
    bool isSynced = true;
    uint32_t nBytesTillResynced = 0u;
  } m_syncState;
};

#endif // TelemetryPacketsProcessor_hpp__
